C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MODECONFIG
OBJECT MODULE PLACED IN .\Bin\ModeConfig.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Sys\ModeConfig.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\App;.\App\OSD;.
                    -\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Component;.\Phy\SI\NVT\
                    -Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT68870_MODULE,LVIEW_256
                    -0X1440,FLASH_BANK=8) PRINT(.\Lst\ModeConfig.lst) TABS(2) OBJECT(.\Bin\ModeConfig.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          
  14          //******************************************************************************
  15          // M A C R O   D E F I N I T I O N S
  16          //******************************************************************************
  17          
  18          //******************************************************************************
  19          // G L O B A L   V A R I A B L E S
  20          //******************************************************************************
  21          
  22          //******************************************************************************
  23          // S T A T I C   V A R I A B L E S
  24          //******************************************************************************
  25          
  26          //******************************************************************************
  27          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  28          //******************************************************************************
  29          
  30          //******************************************************************************
  31          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  32          //******************************************************************************
  33          static void CheckInvalidParameter(void);
  34          
  35          //******************************************************************************
  36          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  37          //******************************************************************************
  38          
  39          //******************************************************************************
  40          // F U N C T I O N   B O D Y S
  41          //******************************************************************************
  42          
  43          /**************************************************************************//**
  44           * Setup capture window and post display.
  45           * @return TRUE if system can show image normally. FASLE if OOR happens.
  46           ******************************************************************************/
  47          BOOL ModeConfig(void)
  48          {
  49   1          BOOL result;
  50   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
  51   1          UCHAR currentinterface = GetCurrInputInterface();
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 2   

  52   1      #endif
  53   1      
  54   1          if (GetInputSyncMode() == DIG_SYNC) { //Digital input
  55   2              PowerDownAnalogInput();
  56   2              SetDVIPLL();
  57   2          #if (DVI_MODE==DVI_HV_MODE) || (DVI_MODE==DVI_HVDE_MODE)
  58   2              DVIAutoPosition();
  59   2          #endif
  60   2          #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT
             -_INTERFACE&INPUT_DP3)
  61   2              // power off DP or Digital sync?
  62   2          // Sequence : Run DPConfigFIFO() after DVIAutoPosition() 
  63   2              if ((currentinterface == DISPLAY_PORT_INPUT) || (currentinterface == DISPLAY_PORT_INPUT1)
  64   2               || (currentinterface == DISPLAY_PORT_INPUT2) || (currentinterface == DISPLAY_PORT_INPUT3)) {
  65   3                  PowerDownDigitalInput();
  66   3                  DP_AudioMNCheckerInit();
  67   3      #if IS_NT68810_SERIES || IS_NT68870_SERIES
  68   3                  SC_DP_AUDIO_FIFO_CTRL |= BIT6;  // 0x1050
  69   3                  usAudioMuteDelay = DP_AUDIODELAY;
  70   3              }
  71   2              else {
  72   3                  SC_HDMI_MUTE |= BIT1; // 0x737
  73   3                  usAudioMuteDelay = HDMI_AUDIODELAY;
  74   3      #endif
  75   3              }
  76   2              //DPConfigFIFO();
  77   2              DPConfigCRC(); // CTS for Cut2/3 Use Only
  78   2          #endif
  79   2          #if ENABLE_HDMI == ON
  80   2              ClearHDMIStatus();
  81   2          #endif
  82   2      #if ENABLE_NR_BYTIMING == ON    
  83   2              SetNRByDigitalTiming();
  84   2      #endif
  85   2          }
  86   1          else { //Analog Input
  87   2              PowerDownDigitalInput();
  88   2      #if IS_NT68810_SERIES || IS_NT68870_SERIES
  89   2              AphyPowerOff(FALSE);
  90   2      #endif
  91   2              CheckInvalidParameter();
  92   2              SetADCPLL(InputTiming.usHTotal);
  93   2              SetADCPhase(InputTiming.ucPhase);
  94   2              SetNRByAnalogTiming();
  95   2              SetMinMax();
  96   2              SetHP(InputTiming.usHStart);
  97   2              SetVP(InputTiming.usVStart);
  98   2          }
  99   1      
 100   1      #if ENABLE_OVERSCAN == ON
 101   1          CheckOverScan();
 102   1      #else
                  SetCaptureSize(InputTiming.usCapHActive, InputTiming.usCapVActive);
              #endif
 105   1          SetHmask();
 106   1      
 107   1      #if 0//ENABLE_SR == ON
                  UserSetSR();
              #endif
 110   1      
 111   1      //#if !IS_NT68770_SERIES && !IS_NT68850_SERIES && !IS_NT68655_SERIES && !IS_NT68790_SERIES && !IS_NT68658_
             -SERIES
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 3   

 112   1      #if IS_NT68770_SERIES_EARLIER || IS_NT68661_SERIES
                  SetColorSpace();
              #endif
 115   1      
 116   1          result = SetupDisplayTiming(InputTiming.usHTotal50);
 117   1      
 118   1      #if ENABLE_SR == ON
 119   1          UserSetSR();
 120   1      #endif
 121   1      
 122   1      #if ENABLE_SCALER_3D == ON
                  SC3DAPI_Setup3DMode();
              #endif
 125   1      #if ENABLE_AUTO_CONTROL == ON
                  DisableDclkSSC();
              #endif
 128   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
 129   1          // 0x1046 = 0x17, DPConfigFIFO() after SetupDisplayTiming()???
 130   1          if ((currentinterface == DISPLAY_PORT_INPUT) || (currentinterface == DISPLAY_PORT_INPUT1)
 131   1           || (currentinterface == DISPLAY_PORT_INPUT2) || (currentinterface == DISPLAY_PORT_INPUT3)) {
 132   2              DPConfigFIFO();
 133   2          }
 134   1      #endif
 135   1      
 136   1          return result;
 137   1      }
 138          #if OSDTYPE == OSD_BENQ_V1 || OSDTYPE == OSD_BENQ_V2
 139          BOOL IsHDMIVideoTiming(void)
 140          {
 141   1          UCHAR CurrInSrc;
 142   1      
 143   1          CurrInSrc = UserGetInputSource();
 144   1      
 145   1      
 146   1      #if (INPUT_INTERFACE&INPUT_MHL_MASK)
                       if ( (GetInputSyncMode() == DIG_SYNC) && MHL_IsMHLInput() ) {
                             return TRUE;
                      }
              #endif   
 151   1      
 152   1      #if ENABLE_HDMI == ON //20130715_1006_SYS#6
 153   1          if((CurrInSrc == INPUT_SC_HDMI)||(CurrInSrc == INPUT_SC_HDMI1)||(CurrInSrc == INPUT_SC_HDMI2)||(CurrIn
             -Src == INPUT_SC_HDMI3)) {
 154   2          if(IsHDMIVideo() && IsVideoTiming()){
 155   3              return TRUE;
 156   3          }
 157   2          }
 158   1      #endif
 159   1      
 160   1          return FALSE;
 161   1      }
 162          #endif
 163          BOOL IsNativeTiming(void)
 164          {
 165   1      #if 1
 166   1      #if !lrd_dis_benq
                  BOOL result;
                xdata InputTimingFormat *pthisInputTiming;
                pthisInputTiming = pInputTiming;
                pInputTiming = GetModeHandleInputTiming(_MainChannel);
                  if (GetScalerSyncMode(_MainChannel) != DIG_SYNC) {
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 4   

                  result = BEST_RESOLUTION_VGA;
                  pInputTiming = pthisInputTiming;
                      return result;
                  }
                  else {
                  result = BEST_RESOLUTION_DIG;
                  pInputTiming = pthisInputTiming;
                      return result;
                  }
              #else
 182   1          BOOL result;
 183   1          if(GetInputSyncMode() != DIG_SYNC)
 184   1              result = BEST_RESOLUTION_VGA;
 185   1          else  
 186   1              result = BEST_RESOLUTION_DIG;
 187   1          return result;
 188   1      #endif
 189   1      #else
                  if (pInputTiming->usModeIndex == _2560X1440_60HZ) {
                      return TRUE;
                  }
                  return FALSE;
              #endif    
 195   1      }
 196          
 197          BOOL IsComponentTiming(void)
 198          {
 199   1      #if !lrd_dis_benq
                  if  ((pInputTiming->usModeIndex == _720x480I_60HZ)  ||
                      (pInputTiming->usModeIndex == _720x576I_50HZ)   ||
                      (pInputTiming->usModeIndex == _640x480_60HZ)    ||         
                      (pInputTiming->usModeIndex == _720x480P_60HZ)   ||
                      (pInputTiming->usModeIndex == _720x576P_50HZ)   ||
                      (pInputTiming->usModeIndex == _1280x720P_50HZ)  ||
                      (pInputTiming->usModeIndex == _1280x720P_60HZ)  || 
                      (pInputTiming->usModeIndex == _1920x1080I_50HZ) ||
                      (pInputTiming->usModeIndex == _1920x1080I_60HZ) ||           
                      (pInputTiming->usModeIndex == _1920x1080I_50HZ125)||
                      (pInputTiming->usModeIndex == _1920x1080P_50HZ) ||   
                      (pInputTiming->usModeIndex == _1920x1080P_60HZ))
              #else
 213   1          if  ((InputTiming.usModeIndex == _720x480I_60HZ)  ||
 214   1              (InputTiming.usModeIndex == _720x576I_50HZ)   ||
 215   1              (InputTiming.usModeIndex == _640x480_60HZ)    ||         
 216   1              (InputTiming.usModeIndex == _720x480P_60HZ)   ||
 217   1              (InputTiming.usModeIndex == _720x576P_50HZ)   ||
 218   1              (InputTiming.usModeIndex == _1280x720P_50HZ)  ||
 219   1              (InputTiming.usModeIndex == _1920x1080I_50HZ) ||
 220   1              (InputTiming.usModeIndex == _1920x1080I_60HZ) ||           
 221   1              (InputTiming.usModeIndex == _1920x1080I_50HZ125)||
 222   1              (InputTiming.usModeIndex == _1920x1080P_50HZ) ||   
 223   1              (InputTiming.usModeIndex == _1920x1080P_60HZ))
 224   1      #endif
 225   1          {
 226   2              return TRUE;
 227   2          }
 228   1      
 229   1          return FALSE;
 230   1      }
 231          BOOL IsComponentInput(void)
 232          {
 233   1          UCHAR interface;
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 5   

 234   1          interface = GetCurrInputInterface();
 235   1          if (IsComponentTiming()&&((interface == ANALOG_SOG_INPUT0)||(interface == ANALOG_SOG_INPUT1))) {
 236   2              return TRUE;
 237   2          }
 238   1          return FALSE;    
 239   1      }
 240          
 241          
 242          BOOL IsPreSetModeTiming(void)
 243          {
 244   1      #if !lrd_dis_benq
                  if ((pInputTiming->usModeIndex == _640x350_70HZ)    ||
                      (pInputTiming->usModeIndex == _640x480_60HZ)    ||        
                      (pInputTiming->usModeIndex == _640x480_75HZ)    ||
                      (pInputTiming->usModeIndex == _720x400_70HZ)    ||
                      (pInputTiming->usModeIndex == _832x624_75HZ)    ||
                      (pInputTiming->usModeIndex == _800x600_60HZ)    ||
                      (pInputTiming->usModeIndex == _800x600_75HZ)    ||
                      (pInputTiming->usModeIndex == _1024x576_60HZ)   ||
                      (pInputTiming->usModeIndex == _1024x600_60HZ)   ||        
                      (pInputTiming->usModeIndex == _1024x768_60HZ)   ||
                      (pInputTiming->usModeIndex == _1024x768_75HZ)   ||
                      (pInputTiming->usModeIndex == _1152x720_60HZ)   ||
                      (pInputTiming->usModeIndex == _1152x864_75HZ)   ||
                      (pInputTiming->usModeIndex == _1152x870_75HZ)   ||
                      (pInputTiming->usModeIndex == _1152x900_66HZ)   ||
                      (pInputTiming->usModeIndex == _1280x720_60HZ)   ||        
                      (pInputTiming->usModeIndex == _1280x720P_60HZ)  ||                
                      (pInputTiming->usModeIndex == _1280x720_75HZ)   ||
                      (pInputTiming->usModeIndex == _1280x768_60HZ_RB) ||                
                      (pInputTiming->usModeIndex == _1280x800_60HZ)   ||                
                      (pInputTiming->usModeIndex == _1280x800_75HZ)   ||
                      (pInputTiming->usModeIndex == _1280x960_60HZ)   ||
                      (pInputTiming->usModeIndex == _1280x1024_60HZ)  ||
                      (pInputTiming->usModeIndex == _1280x1024_75HZ)  ||
                      (pInputTiming->usModeIndex == _1366x768_60HZ)   ||
                      (pInputTiming->usModeIndex == _1360x768_60HZ)   ||
                      (pInputTiming->usModeIndex == _1440x900_60HZ_RB) ||
                      (pInputTiming->usModeIndex == _1440x900_60HZ)   ||
                      (pInputTiming->usModeIndex == _1440x900_75HZ)   ||
                      (pInputTiming->usModeIndex == _1600x900_60HZ_RB)||
                      (pInputTiming->usModeIndex == _1600x1000_60HZ_RB)||
                      (pInputTiming->usModeIndex == _1600x1200_60HZ)  ||
                      (pInputTiming->usModeIndex == _1680x1050_60HZ)  ||
                      (pInputTiming->usModeIndex == _1680x1050_75HZ)  ||
                      (pInputTiming->usModeIndex == _1920x1080_60HZ_RB)||
                      (pInputTiming->usModeIndex == _1920x1080_60HZ)  ||
                      (pInputTiming->usModeIndex == _1920x1080P_60HZ) ||
                      (pInputTiming->usModeIndex == _1920x1200_50HZ_RB)||        
                      (pInputTiming->usModeIndex == _1920x1200_60HZ)  ||
                      (pInputTiming->usModeIndex == _1920x1200_60HZ_RB)||
                      (pInputTiming->usModeIndex == _1920x1200_60HZ_2)||
                      (pInputTiming->usModeIndex == _2048x1280_60HZ_RB)||
                      (pInputTiming->usModeIndex == _2560X1440_60HZ)) {
                      return TRUE;
                  }
                  if (pInputTiming->usModeHActive == 1024 && pInputTiming->usModeVActive == 600 && (pInputTiming->usVSyn
             -cFreq >590 && pInputTiming->usVSyncFreq <610)) {
                      return TRUE;
                  }
                  if (pInputTiming->usModeHActive == 1152 && pInputTiming->usModeVActive == 720 && (pInputTiming->usVSyn
             -cFreq >590 && pInputTiming->usVSyncFreq <610)) {
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 6   

                      return TRUE;
                  }
                  if(pInputTiming->usCapHActive == 1024 && pInputTiming->usCapVActive == 768 && pInputTiming->usVSyncFre
             -q > 740 && pInputTiming->usVSyncFreq <760){
                      return TRUE;
                  }
                  if(pInputTiming->usCapHActive == 1280 && pInputTiming->usCapVActive == 960 && pInputTiming->usVSyncFre
             -q > 590 && pInputTiming->usVSyncFreq <610){
                      return TRUE;
                  }
                  if(pInputTiming->usCapHActive == 1440 && pInputTiming->usCapVActive == 900 && pInputTiming->usVSyncFre
             -q > 590 && pInputTiming->usVSyncFreq <610){
                      return TRUE;
                  }
                  
                  if(pInputTiming->usCapHActive == 2560 && pInputTiming->usCapVActive ==1440 && pInputTiming->usVSyncFre
             -q > 590 && pInputTiming->usVSyncFreq <610){
                      return TRUE;
                  }
                  if (IsComponentInput() == TRUE) {  //Input Component timing doesn't show Resnotice & non preset mode
                      return TRUE;
                  }
              #else
 313   1          if ((InputTiming.usModeIndex == _640x350_70HZ)    ||
 314   1              (InputTiming.usModeIndex == _640x480_60HZ)    ||        
 315   1              (InputTiming.usModeIndex == _640x480_75HZ)    ||
 316   1              (InputTiming.usModeIndex == _720x400_70HZ)    ||
 317   1              (InputTiming.usModeIndex == _832x624_75HZ)    ||
 318   1              (InputTiming.usModeIndex == _800x600_60HZ)    ||
 319   1              (InputTiming.usModeIndex == _800x600_75HZ)    ||
 320   1              (InputTiming.usModeIndex == _1024x600_60HZ)   ||        
 321   1              (InputTiming.usModeIndex == _1024x768_60HZ)   ||
 322   1              (InputTiming.usModeIndex == _1024x768_75HZ)   ||
 323   1              (InputTiming.usModeIndex == _1152x720_60HZ)   ||
 324   1              (InputTiming.usModeIndex == _1152x864_75HZ)   ||
 325   1              (InputTiming.usModeIndex == _1152x870_75HZ)   ||
 326   1              (InputTiming.usModeIndex == _1152x900_66HZ)   ||
 327   1              (InputTiming.usModeIndex == _1280x720_60HZ)   ||        
 328   1              (InputTiming.usModeIndex == _1280x720_75HZ)   ||
 329   1              (InputTiming.usModeIndex == _1280x768_60HZ_RB) ||                
 330   1              (InputTiming.usModeIndex == _1280x800_60HZ)   ||                
 331   1              (InputTiming.usModeIndex == _1280x800_75HZ)   ||
 332   1              (InputTiming.usModeIndex == _1280x960_60HZ)   ||
 333   1              (InputTiming.usModeIndex == _1280x1024_60HZ)  ||
 334   1              (InputTiming.usModeIndex == _1280x1024_75HZ)  ||
 335   1              (InputTiming.usModeIndex == _1366x768_60HZ)   ||
 336   1              (InputTiming.usModeIndex == _1360x768_60HZ)   ||
 337   1              (InputTiming.usModeIndex == _1440x900_60HZ_RB) ||
 338   1              (InputTiming.usModeIndex == _1440x900_60HZ)   ||
 339   1              (InputTiming.usModeIndex == _1440x900_75HZ)   ||
 340   1              (InputTiming.usModeIndex == _1600x1000_60HZ_RB)||
 341   1              (InputTiming.usModeIndex == _1600x1200_60HZ)  ||
 342   1              (InputTiming.usModeIndex == _1680x1050_60HZ)  ||
 343   1              (InputTiming.usModeIndex == _1680x1050_75HZ)  ||
 344   1              (InputTiming.usModeIndex == _1920x1080_60HZ_RB)||
 345   1              (InputTiming.usModeIndex == _1920x1080_60HZ)  ||
 346   1              (InputTiming.usModeIndex == _1920x1080P_60HZ) ||
 347   1              (InputTiming.usModeIndex == _1920x1200_50HZ_RB)||        
 348   1              (InputTiming.usModeIndex == _1920x1200_60HZ)  ||
 349   1              (InputTiming.usModeIndex == _1920x1200_60HZ_RB)
 350   1          )
 351   1        {
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 7   

 352   2              return TRUE;
 353   2          }
 354   1          if (InputTiming.usModeHActive == 1024 && InputTiming.usModeVActive == 600 && (InputTiming.usVSyncFreq 
             ->590 && InputTiming.usVSyncFreq <610)) {
 355   2              return TRUE;
 356   2          }
 357   1          if (InputTiming.usModeHActive == 1152 && InputTiming.usModeVActive == 720 && (InputTiming.usVSyncFreq 
             ->590 && InputTiming.usVSyncFreq <610)) {
 358   2              return TRUE;
 359   2          }
 360   1          if(InputTiming.usCapHActive == 1024 && InputTiming.usCapVActive == 768 && InputTiming.usVSyncFreq > 74
             -0 && InputTiming.usVSyncFreq <760){
 361   2              return TRUE;
 362   2          }
 363   1          if(InputTiming.usCapHActive == 1280 && InputTiming.usCapVActive == 960 && InputTiming.usVSyncFreq > 59
             -0 && InputTiming.usVSyncFreq <610){
 364   2              return TRUE;
 365   2          }
 366   1          if(InputTiming.usCapHActive == 1440 && InputTiming.usCapVActive == 900 && InputTiming.usVSyncFreq > 59
             -0 && InputTiming.usVSyncFreq <610){
 367   2              return TRUE;
 368   2          }
 369   1          
 370   1          if(InputTiming.usCapHActive == 2560 && InputTiming.usCapVActive ==1440 && InputTiming.usVSyncFreq > 59
             -0 && InputTiming.usVSyncFreq <610){
 371   2              return TRUE;
 372   2          }
 373   1          if (IsComponentInput() == TRUE) {  //Input Component timing doesn't show Resnotice & non preset mode
 374   2              return TRUE;
 375   2          }
 376   1      #endif
 377   1          return FALSE;
 378   1      }
 379          /**************************************************************************//**
 380           * Determine current input timing is video timing or not.
 381           * @return TRUE if input timing is video timing else FALSE.
 382           ******************************************************************************/
 383          #if (!defined(ENABLE_FPGA_MODE))
 384          BOOL IsVideoTiming(void)
 385          {
 386   1      
 387   1      #if (INPUT_INTERFACE&INPUT_MHL_MASK) 
                   if ( (GetInputSyncMode() == DIG_SYNC) && MHL_IsMHLInput() ) {
                         return TRUE;
                  }
              #endif   
 392   1         
 393   1          if ((InputTiming.usModeIndex == _720x480I_60HZ)   ||
 394   1              (InputTiming.usModeIndex == _1440x480I_60HZ)  ||
 395   1              (InputTiming.usModeIndex == _2880x480I_60HZ)  ||
 396   1              (InputTiming.usModeIndex == _720x480P_60HZ)   ||
 397   1              (InputTiming.usModeIndex == _720x576I_50HZ)   ||
 398   1              (InputTiming.usModeIndex == _1440x576I_50HZ)  ||
 399   1              (InputTiming.usModeIndex == _2880x576I_50HZ)  ||
 400   1              (InputTiming.usModeIndex == _720x576P_50HZ)   ||
 401   1              (InputTiming.usModeIndex == _1280x720P_50HZ)  ||
 402   1              (InputTiming.usModeIndex == _1280x720_60HZ)   ||
 403   1              (InputTiming.usModeIndex == _1920x1080P_60HZ) ||
 404   1              (InputTiming.usModeIndex == _1920x1080P_50HZ) ||
 405   1              (InputTiming.usModeIndex == _1920x1080I_50HZ) ||
 406   1              (InputTiming.usModeIndex == _1920x1080I_50HZ_RB)) {
 407   2              return TRUE;
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 8   

 408   2          }
 409   1      
 410   1          return FALSE;
 411   1      }
 412          #endif
 413          
 414          /**************************************************************************//**
 415           * Determine current input timing is "Out Of Range" or not.
 416           * @return TRUE if input timing is OOR else FALSE.
 417           ******************************************************************************/
 418          BOOL IsOutOfRange(void)
 419          {
 420   1      #if (!defined(ENABLE_FPGA_MODE))
 421   1      #if ENABLE_SCALER_3D == ON
                  if (SC3DAPI_IsHDMI3DMode()) {
                      return FALSE;
                  }
              #endif
 426   1      #if ENABLE_DVI_DUAL_LINK == ON
 427   1          if (TMDS_IsDualLink()) {
 428   2              return FALSE;
 429   2          }
 430   1      #endif
 431   1      
 432   1          if (IsVideoTiming()) {
 433   2              return FALSE;
 434   2          }
 435   1      
 436   1          //Check HSync Frequency
 437   1          if (InputTiming.usHSyncFreq < MIN_H_FREQ) {
 438   2              return TRUE;
 439   2          }
 440   1          if (InputTiming.usHSyncFreq > MAX_H_FREQ) {
 441   2              return TRUE;
 442   2          }
 443   1          //Check VSync Frequency
 444   1          if (InputTiming.usVSyncFreq < MIN_V_FREQ) {
 445   2              return TRUE;
 446   2          }
 447   1          if (InputTiming.usVSyncFreq > MAX_V_FREQ) {
 448   2              return TRUE;
 449   2          }
 450   1          //Check ADC clock frequency
 451   1          if (GetInputSyncMode() != DIG_SYNC) {
 452   2              if (CheckADCPLLOutOfRange(InputTiming.usHTotal) == TRUE) {
 453   3                  return TRUE;
 454   3              }
 455   2          }
 456   1      #endif
 457   1          return FALSE;
 458   1      }
 459          
 460          /**************************************************************************//**
 461           * Define the minimum and maximum value of HTotal, HStart and VStart
 462           ******************************************************************************/
 463          void SetMinMax(void)
 464          {
 465   1          USHRT temp;
 466   1      
 467   1          temp = InputTiming.usHTotal50 > 50 ? 50 : InputTiming.usHTotal50;
 468   1          InputTiming.usHTotalMin = InputTiming.usHTotal50 - temp;
 469   1          InputTiming.usHTotalMax = InputTiming.usHTotal50 + temp;
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 9   

 470   1      
 471   1          temp = InputTiming.usHStart50 > 50 ? 50 : InputTiming.usHStart50;
 472   1          InputTiming.usHStartMin = InputTiming.usHStart50 - temp;
 473   1          InputTiming.usHStartMax = InputTiming.usHStart50 + temp;
 474   1      
 475   1          temp = InputTiming.usVStart50 > 20 ? 20 : InputTiming.usVStart50-1;
 476   1          InputTiming.usVStartMin = InputTiming.usVStart50 - temp;
 477   1          InputTiming.usVStartMax = InputTiming.usVStart50 + temp;
 478   1      }
 479          
 480          /**************************************************************************//**
 481           * Verify the present HTotal, HStart and VStart.
 482           * The criteria is
 483           *   If HTotal > 2*HActive, HTotal is invalid and HTotal = HActive * 3 / 2.
 484           *   If HStart > 0.5*HTotal, HStart is invalid and HStart = (HTotal - HActive) / 2.
 485           *   If VStart > 0.5*VTotal, VStart is invalid and VStart = (VTotal - VActive) / 2.
 486           ******************************************************************************/
 487          void CheckInvalidParameter(void)
 488          {
 489   1          USHRT temp;
 490   1          temp = InputTiming.usCapHActive << 1;
 491   1          if (InputTiming.usHTotal > temp) {
 492   2              temp = InputTiming.usCapHActive >> 1;
 493   2              InputTiming.usHTotal = InputTiming.usCapHActive + temp;
 494   2          }
 495   1          temp = InputTiming.usHTotal >> 1;
 496   1          if (InputTiming.usHStart > temp) {
 497   2              InputTiming.usHStart = (InputTiming.usHTotal - InputTiming.usCapHActive) / 2;
 498   2          }
 499   1          temp = InputTiming.usVTotal >> 1;
 500   1          if (InputTiming.usVStart > temp) {
 501   2              InputTiming.usVStart = (InputTiming.usVTotal - InputTiming.usCapVActive) / 2;
 502   2          }
 503   1      }
 504          
 505          #if ENABLE_OVERSCAN == ON
 506          /**************************************************************************//**
 507           * Perform over-scan with some conditions.
 508           ******************************************************************************/
 509          #if !lrd_dis
              void CheckOverScan(void)
              {
              #if ((ENABLE_HDMI == ON) && !((INPUT_INTERFACE&INPUT_DP)||(INPUT_INTERFACE&INPUT_DP)))
                  if ((GetInputSyncMode() == DIG_SYNC) && IsHDMIVideo() && IsOverScan())
              #else
                  if ((GetInputSyncMode() == DIG_SYNC) && IsOverScan())
              #endif
                  {
                      SetOverScanRatio(OVER_SCAN_RATIO);
                  }
                  else{
                      SetOverScanRatio(0);
                  }
              }
              #else
 525          void SetHSVSOffset(USHRT modeIndex)
 526           {
 527   1              
 528   1          switch (modeIndex){
 529   2              case _1920x1080P_60HZ:
 530   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+47;;  //OK           
 531   2                  break;
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 10  

 532   2              case _1920x1080P_50HZ:
 533   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+45;;  //OK             
 534   2      
 535   2                  break;            
 536   2              case _1920x1080I_60HZ:
 537   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+44;  //OK             
 538   2                  //(InputTiming.usVStart) = (InputTiming.usVStart)-1;            
 539   2                  break;            
 540   2              case _1920x1080I_50HZ:
 541   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+44;  //OK             
 542   2                  //(InputTiming.usVStart) = (InputTiming.usVStart)-1;            
 543   2                  break;
 544   2             // case _1280x720P_60HZ:
 545   2             //     (InputTiming.usHStart) = (InputTiming.usHStart)+40;  //OK           
 546   2                  break;
 547   2              case _1280x720P_50HZ:
 548   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+40; //OK
 549   2                  break;      
 550   2              case _720x576P_50HZ:
 551   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+1; //OK
 552   2      
 553   2                  break;      
 554   2              case _720x576I_50HZ:         
 555   2                  //(InputTiming.usVStart) = (InputTiming.usVStart)+2;   //OK
 556   2      
 557   2                  break;                        
 558   2              case _720x480P_60HZ:
 559   2                  (InputTiming.usHStart) = (InputTiming.usHStart)-1;      //V up  down  
 560   2                  //(InputTiming.usVStart) = (InputTiming.usVStart)+1;
 561   2                  break;
 562   2              case _720x480I_60HZ:
 563   2                  (InputTiming.usHStart) = (InputTiming.usHStart)+2; //V up down
 564   2                  (InputTiming.usVStart) = (InputTiming.usVStart)-1;  
 565   2                  if ((SC_GI_SYNC_CTRL3 & BIT0) == 0x00) {
 566   3                      SC_GI_SYNC_CTRL3 |= BIT0;
 567   3                  }
 568   2                  SC_GPORT_CTRL |= BIT6;
 569   2                  break;
 570   2              default:
 571   2                  break;
 572   2           }
 573   1          //printf("Offset HS %d VS %d\r\n",(InputTiming.usHStart),(InputTiming.usVStart));
 574   1       }
 575          
 576          void SetVGAOverScanRatio(UCHAR ratio)
 577          {
 578   1          USHRT hstart, vstart;
 579   1      
 580   1          if (ratio != 0) { //On
 581   2              hstart = InputTiming.usModeHActive * ratio / 100 / 2;
 582   2              InputTiming.usHStart = hstart + InputTiming.usHStart50;
 583   2              InputTiming.usCapHActive = InputTiming.usModeHActive - hstart * 2;
 584   2              InputTiming.usCapHActive &= 0xFFFE;
 585   2      
 586   2              vstart = InputTiming.usModeVActive * ratio / 100 / 2;
 587   2              InputTiming.usVStart = vstart + InputTiming.usVStart50;
 588   2              if (IsInterlaced() == TRUE) {
 589   3                  InputTiming.usCapVActive = InputTiming.usModeVActive - vstart * 4;
 590   3              }
 591   2              else {
 592   3                  InputTiming.usCapVActive = InputTiming.usModeVActive - vstart * 2;
 593   3              }
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 11  

 594   2              
 595   2              //For YPbPr
 596   2              {
 597   3                  SetHSVSOffset((InputTiming.usModeIndex));
 598   3              }
 599   2            
 600   2              SetCaptureSize(InputTiming.usCapHActive, InputTiming.usCapVActive);
 601   2              SetHP(InputTiming.usHStart);
 602   2              SetVP(InputTiming.usVStart);
 603   2              DelayVTime(2);
 604   2          }
 605   1          else { //Off
 606   2           InputTiming.usCapHActive = InputTiming.usModeHActive;
 607   2           InputTiming.usCapVActive = InputTiming.usModeVActive;
 608   2              InputTiming.usHStart = InputTiming.usHStart50;
 609   2              InputTiming.usVStart = InputTiming.usVStart50;
 610   2      
 611   2              //For YPbPr
 612   2              {
 613   3                  //printf("Modeconfig HS %d VS %d\r\n",(InputTiming.usHStart),(InputTiming.usVStart));
 614   3                  //printf("modeindex %x\r\n\n",(InputTiming.usModeIndex));  
 615   3                  SetHSVSOffset((InputTiming.usModeIndex));
 616   3              }
 617   2              //
 618   2              
 619   2              SetCaptureSize(InputTiming.usCapHActive, InputTiming.usCapVActive);        
 620   2              SetHP(InputTiming.usHStart);
 621   2              SetVP(InputTiming.usVStart);
 622   2              DelayVTime(2);        
 623   2          }
 624   1      }
 625          
 626          BOOL IsOverScan(void)
 627          {
 628   1          if(IsComponentInput()){
 629   2              return UserData.bSOGOverScan;
 630   2          }
 631   1          else{
 632   2              return UserData.bOverScan;
 633   2          }
 634   1      }
 635          
 636          void CheckOverScan(void)
 637          {
 638   1      #if ((ENABLE_HDMI == ON) && !(INPUT_INTERFACE&INPUT_DP_MASK))
                  if ((GetInputSyncMode() == DIG_SYNC) && IsHDMIVideo() && IsOverScan())
              #else
 641   1          //    if (((GetInputSyncMode() == DIG_SYNC)||((GetInputSyncMode() == SOG_SYNC)&&IsComponentTiming()))&
             -& IsOverScan())
 642   1          if ((GetInputSyncMode() == DIG_SYNC || IsComponentInput())&& IsOverScan())
 643   1      #endif
 644   1          {
 645   2      #if ENABLE_PIP == ON
                      if (GetChannelIndex() == _PIPChannel) {
                          SetOverScanRatio(0);
                      }
                      else
              #endif
 651   2              {
 652   3                  if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT)||(GetCurrInputInterface() == DISPLAY_PORT_
             -INPUT1)) {//DP
 653   4                  //SetOverScanRatio(OVER_SCAN_RATIO);
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 12  

 654   4                      SetOverScanRatio(0);                        
 655   4                  }
 656   3                  else if (IsComponentInput()) {//Ypbpr
 657   4                      SetVGAOverScanRatio(OVER_SCAN_RATIO);
 658   4                  }            
 659   3                  else {
 660   4                      if (IsHDMI()) {//HDMI
 661   5                          SetOverScanRatio(OVER_SCAN_RATIO);             
 662   5                      }
 663   4                      else {//TMDS wihtout info frame
 664   5                          SetOverScanRatio(0);
 665   5                      }
 666   4                  }
 667   3              }
 668   2          }
 669   1          else {
 670   2              if (IsComponentInput()) {
 671   3                  SetVGAOverScanRatio(0);
 672   3              }
 673   2              else {
 674   3                  SetOverScanRatio(0);
 675   3              }
 676   2          }
 677   1      }
 678          
 679          #endif
 680          
 681          /**************************************************************************//**
 682           * Update capture-related parameters.
 683           ******************************************************************************/
 684          static void UpdateCaptureInfo(void)
 685          {
 686   1          USHRT vactive = GetDigInputVActive();
 687   1          if (IsInterlaced()) {
 688   2              vactive = vactive * 2;
 689   2          }
 690   1      
 691   1          InputTiming.usModeHActive = GetDigInputHActive();
 692   1          InputTiming.usModeVActive = vactive;
 693   1          InputTiming.usCapHActive = InputTiming.usModeHActive;
 694   1          InputTiming.usCapVActive = InputTiming.usModeVActive;
 695   1          InputTiming.usHStart = GetInputHStart();
 696   1          InputTiming.usVStart = GetInputVStart();
 697   1          InputTiming.usHStart50 = InputTiming.usHStart;
 698   1          InputTiming.usVStart50 = InputTiming.usVStart;
 699   1      }
 700          
 701          /**************************************************************************//**
 702           * Perform over-scan.
 703           * Over-scan procedures must follow the following steps.
 704           *   1. Disable over-scan.
 705           *   2. Set capture window.
 706           *   3. Wait for a VSync duty (20ms).
 707           *   4. Enable over-scan.
 708           * @param ratio Over-scan ratio.
 709           ******************************************************************************/
 710          void SetOverScanRatio(UCHAR ratio)
 711          {
 712   1          USHRT hstart, vstart;
 713   1      
 714   1          if (ratio != 0) { //On
 715   2              DisableOverSample();
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 13  

 716   2              DVIAutoPosition();
 717   2              UpdateCaptureInfo();
 718   2              hstart = InputTiming.usCapHActive * ratio / 100 / 2;
 719   2              vstart = InputTiming.usCapVActive * ratio / 100 / 2;
 720   2              InputTiming.usHStart = hstart;
 721   2              InputTiming.usCapHActive = InputTiming.usCapHActive - hstart * 2;
 722   2              InputTiming.usCapHActive &= 0xFFFE;
 723   2              InputTiming.usVStart = GetInputVStart();
 724   2      #if NEW_OVS_MODE == ON
 725   2              WriteShortScaler(&SC_NEW_OVS_VBEG_LO, vstart);//new mode
 726   2              SC_OVERSCAN_MODE |= BIT7;
 727   2      #else
                      InputTiming.usVStart += vstart;
              #endif
 730   2              if (IsInterlaced() == TRUE) {
 731   3                  InputTiming.usCapVActive = InputTiming.usCapVActive - vstart * 4;
 732   3              }
 733   2              else {
 734   3                  InputTiming.usCapVActive = InputTiming.usCapVActive - vstart * 2;
 735   3              }
 736   2              SetHP(InputTiming.usHStart);
 737   2              SetVP(InputTiming.usVStart);
 738   2              SetCaptureSize(InputTiming.usCapHActive, InputTiming.usCapVActive);
 739   2              DelayVTime(2);
 740   2              EnableOverSample();
 741   2          }
 742   1          else { //Off
 743   2      #if NEW_OVS_MODE == ON
 744   2              SC_OVERSCAN_MODE &= ~BIT7;
 745   2      #endif
 746   2              if (IsOverSample() == TRUE) {
 747   3                  DisableOverSample();
 748   3                  DVIAutoPosition();
 749   3                  UpdateCaptureInfo();
 750   3              }
 751   2              SetCaptureSize(InputTiming.usCapHActive, InputTiming.usCapVActive);
 752   2          }
 753   1      }
 754          
 755          
 756          #endif
 757          //******************************************************************************
 758          // Prototype:
 759          //  BOOL CheckVSyncWidthChange(void)
 760          // Parameters:
 761          //  None
 762          // Return:
 763          //  TRUE/FALSE
 764          // Purpose:
 765          //  Check Vsync width change
 766          // Notes:
 767          //  v31_1106221_2200_SYS#2
 768          //******************************************************************************
 769          /*
 770          BOOL CheckVSyncWidthChange(void)
 771          {
 772          #define VS_WID_DIFF_CNT 4
 773          
 774              UCHAR uctemp_Vs_wid;
 775              if (GetModeHandleState() == WAIT_MODE_CHANGE) {
 776                  if (((InputTiming.usModeHActive == 1360) ||(InputTiming.usModeHActive == 1366)) && (InputTiming.us
             -ModeVActive == 768)) { //v31_110627_2225_SYS#7
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 14  

 777                      uctemp_Vs_wid = GetInputVSyncWidth();
 778                      if (uctemp_Vs_wid != Custom_System.ucVs_wid) {
 779                          Custom_System.ucVs_wid_diff_cnt ++;
 780                      }
 781                      else {
 782                          Custom_System.ucVs_wid_diff_cnt = 0;
 783                      }
 784                      if ( Custom_System.ucVs_wid_diff_cnt > VS_WID_DIFF_CNT) {
 785                          return TRUE;
 786                      }
 787                  }
 788              }
 789              return FALSE;
 790          }
 791          */
 792          
 793          
 794          
 795          BOOL isOnlyFullAspectRatio(void)
 796          {
 797   1      #if !lrd_dis_benq
                  if (pInputTiming->usModeHActive == PANEL_WIDTH && pInputTiming->usModeVActive == PANEL_HEIGHT) {
              #else
 800   1        if (InputTiming.usModeHActive == PANEL_WIDTH && InputTiming.usModeVActive == PANEL_HEIGHT) {
 801   2      #endif
 802   2              if (DetectAspectRatio() == DSP_SIZE_FULL){
 803   3                  return TRUE;
 804   3              }
 805   2              else{
 806   3                  return FALSE;
 807   3              }
 808   2          }
 809   1          else{
 810   2              return FALSE;
 811   2          }
 812   1      }
 813          
 814          UCHAR DetectAspectRatio(void)
 815          {
 816   1          enum DisplayRatio
 817   1          {
 818   1              _Aspect_5_4 = 125,
 819   1              _Aspect_4_3 = 133,
 820   1              _Aspect_3_2 = 150,
 821   1              _Aspect_16_10 = 160,
 822   1              _Aspect_16_9 = 177
 823   1          };
 824   1      
 825   1          UCHAR Ratio;
 826   1          if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT)||(GetCurrInputInterface() == DISPLAY_PORT_INPUT1))
             - {
 827   2                       if (IsInterlaced() == TRUE) {
 828   3                      Ratio =  (ULONG)GetDPInputHDEImmediate()*100 / (GetDPInputVDEImmediate()*2);     
 829   3                      }
 830   2                      else{
 831   3              Ratio =  (ULONG)GetDPInputHDEImmediate()*100 / GetDPInputVDEImmediate();     
 832   3                      }
 833   2              //printf("(%d,%d)\r\n",(USHRT)GetDPInputHDEImmediate(),(USHRT) GetDPInputVDEImmediate());         
             -           
 834   2          }
 835   1          else { 
 836   2          #if !lrd_dis_benq
C51 COMPILER V9.54   MODECONFIG                                                            01/06/2017 14:56:41 PAGE 15  

                      pInputTiming = GetModeHandleInputTiming(_MainChannel);
                  #endif
 839   2          #if !lrd_dis_benq   
                      Ratio = (ULONG)pInputTiming->usModeHActive*100/pInputTiming->usModeVActive;
                  #else
 842   2              Ratio = (ULONG)InputTiming.usModeHActive*100/InputTiming.usModeVActive;
 843   2          #endif
 844   2              //printf("(%d,%d)\r\n",(USHRT)pInputTiming->usModeHActive,(USHRT)pInputTiming->usModeVActive);    
             -        
 845   2          }    
 846   1          switch(Ratio) {
 847   2              case _Aspect_5_4:
 848   2              case _Aspect_4_3:
 849   2              case _Aspect_3_2:
 850   2      #if ENABLE_ASPECT_16_10_AS_4_3 == ON
                      case _Aspect_16_10:
              #endif
 853   2                  Ratio = DSP_SIZE_43;
 854   2                  break;
 855   2              default:
 856   2      #if ENABLE_ASPECT_16_10_AS_4_3 == OFF
 857   2              case _Aspect_16_10:
 858   2      #endif          
 859   2              case _Aspect_16_9:
 860   2                  Ratio = DSP_SIZE_FULL;
 861   2                  break;
 862   2          }
 863   1          //printf("DetectAspectRatio=%d\r\n",(USHRT)Ratio);
 864   1          return Ratio;
 865   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2755    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
