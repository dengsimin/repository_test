C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCALER_CSC
OBJECT MODULE PLACED IN .\Bin\Scaler_CSC.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Lib\NT68810 Series\Scaler_CSC.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\
                    -App;.\App\OSD;.\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Componen
                    -t;.\Phy\SI\NVT\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT68870_M
                    -ODULE,LVIEW_2560X1440,FLASH_BANK=8) PRINT(.\Lst\Scaler_CSC.lst) TABS(2) OBJECT(.\Bin\Scaler_CSC.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          #include "ScalerProfile.h"
  14          
  15          //******************************************************************************
  16          // M A C R O   D E F I N I T I O N S
  17          //******************************************************************************
  18          #define CSC_SIM_CTRL BIT7 //0x055
  19          
  20          //******************************************************************************
  21          // G L O B A L   V A R I A B L E S
  22          //******************************************************************************
  23          
  24          //******************************************************************************
  25          // S T A T I C   V A R I A B L E S
  26          //******************************************************************************
  27          static xdata CSCColorSpace ucCSCClrSpace = CSC_HDMI_AUTO_CLR_SPACE; /*!< Variable of CSC mode. */
  28          
  29          //******************************************************************************
  30          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  31          //******************************************************************************
  32          
  33          //******************************************************************************
  34          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  35          //******************************************************************************
  36          static xdata UCHAR ucAVIClrSpace = 0xFF;
  37          
  38          //******************************************************************************
  39          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  40          //******************************************************************************
  41          
  42          //******************************************************************************
  43          // F U N C T I O N   B O D Y S
  44          //******************************************************************************
  45          static void SetHDMISRCSC(void);
  46          static void SetVGADVISRCSC(void);
  47          #if ((INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_IN
             -TERFACE&INPUT_DP3)) && ENABLE_SR == ON
  48          static void SetDPSRCSC(void);
  49          #endif
  50          
  51          #if ENABLE_HDMI == ON
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 2   

  52          //******************************************************************************
  53          // Prototype: 
  54          //  void GetScalerColorSpace(void)
  55          // Parameters:
  56          //  None
  57          // Return:
  58          //  None
  59          // Purpose:
  60          //  None
  61          // Notes:
  62          //******************************************************************************
  63          UCHAR GetScalerColorSpace(void)
  64          {
  65   1         return ucAVIClrSpace;
  66   1      }
  67          
  68          /**************************************************************************//**
  69           * Configure the CSC mode.
  70           * @param csc CSC mode.
  71           ******************************************************************************/
  72          void SetCSCColorSpace(CSCColorSpace csc)
  73          {
  74   1          ucCSCClrSpace = csc;
  75   1          SetColorSpace();
  76   1      }
  77          
  78          #endif
  79          
  80          /**************************************************************************//**
  81           * According to ucCSCClrSpace, set color space automatically.
  82           * If CSC mode is auto:
  83           *  - If input interface is HDMI, the color space is configured automatically according to AVI packets.
  84           *  - If input interface is DVI, forcing the color space as RGB.
  85           *  - If input interface is YPbPr, the color space is configured automatically according to input resoluti
             -on.
  86           *  - If input interface is DSub, forcing the color space as RGB.
  87           * If CSC mode is manual:
  88           *  - If input interface is HDMI, the color space is configured manually.
  89           *  - If input interface is DVI, the color space is configured manually.
  90           *  - If input interface is YPbPr, the color space is configured manually.
  91           *  - If input interface is DSub, forcing the color space as RGB.
  92           ******************************************************************************/
  93          
  94          #if (OSDTYPE == OSD_BENQ_V2) || (OSDTYPE == OSD_BENQ_V1) || (OSDTYPE == OSD_BENQ) // lrd_change_scaler_cod
             -e
  95          static xdata UCHAR ucCSCInputFormat = CSCInput_Unknown;
  96          
  97          /**************************************************************************//**
  98           * Configure Capture CSC.
  99           * Always convert color space to YCbCr
 100           ******************************************************************************/
 101          static void CSC_SetCaptureCSC(void)
 102          {
 103   1          if (ucCSCClrSpace == CSC_OFF) {
 104   2              SC_CSC_CTRL1 = 0x00;
 105   2              SC_CSC_CTRL2 = 0x00;
 106   2          }
 107   1          else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {
 108   2              switch(ucCSCInputFormat) {
 109   3                  case CSCInput_Unknown:
 110   3                      SC_CSC_CTRL1 = 0x00;                //by pass
 111   3                      SC_CSC_CTRL2 = ~BIT0;  
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 3   

 112   3                      SC_CSC_CTRL2 &= ~BIT5;                          
 113   3                      break;
 114   3                  case CSCInput_601_Full_444:
 115   3                  case CSCInput_709_Full_444:
 116   3                  case CSCInput_xvYCC709_Full_444:
 117   3                  case CSCInput_xvYCC601_Full_444:
 118   3                      SC_CSC_CTRL1 = 0x00;                //by pass
 119   3                      SC_CSC_CTRL2 &= ~BIT0;
 120   3                      SC_CSC_CTRL2 &= ~BIT5;                          
 121   3                      break;
 122   3                  case CSCInput_601_Full_422:
 123   3                  case CSCInput_709_Full_422:
 124   3                  case CSCInput_xvYCC709_Full_422:
 125   3                  case CSCInput_xvYCC601_Full_422:
 126   3                      SC_CSC_CTRL1 = 0x00;                //by pass
 127   3                      SC_CSC_CTRL2 &= ~BIT0;        
 128   3                  SC_CSC_CTRL2 |= BIT5;
 129   3                      break;
 130   3                  case CSCInput_601_Limit_444:
 131   3                  case CSCInput_709_Limit_444:
 132   3                  case CSCInput_xvYCC709_Limit_444:
 133   3                  case CSCInput_xvYCC601_Limit_444:
 134   3                      SC_CSC_CTRL1 = 0x00;                //by pass
 135   3                      SC_CSC_CTRL2 &= ~BIT0;
 136   3                      SC_CSC_CTRL2 &= ~BIT5;       
 137   3                      /*
 138   3                      SC_CSC_CTRL1 = 0xB0;                  //limit to full 
 139   3                      SC_CSC_CTRL2 = 0x19;        
 140   3                      SC_CSC_CTRL2 &= ~BIT5;                                              
 141   3                      */
 142   3                      break;
 143   3                  case CSCInput_601_Limit_422:
 144   3                  case CSCInput_709_Limit_422:
 145   3                  case CSCInput_xvYCC709_Limit_422:
 146   3                  case CSCInput_xvYCC601_Limit_422:
 147   3                      SC_CSC_CTRL1 = 0x00;                //by pass
 148   3                      SC_CSC_CTRL2 &= ~BIT0;
 149   3                      SC_CSC_CTRL2 |= BIT5;    
 150   3                      /*
 151   3                      SC_CSC_CTRL1 = 0xB0;                 //limit to full
 152   3                      SC_CSC_CTRL2 = 0x19|BIT5;        
 153   3                      */
 154   3                      break;            
 155   3                  case CSCInput_RGB_Full:
 156   3                      SC_CSC_CTRL1 = 0xF8;//full to limit 601
 157   3                      SC_CSC_CTRL2 = 0x19;
 158   3                      SC_CSC_CTRL2 &= ~BIT5;                                              
 159   3                      break;            
 160   3                  case CSCInput_RGB_Limit:
 161   3                      SC_CSC_CTRL1 = 0x88;//RGB to 601
 162   3                      SC_CSC_CTRL2 = 0x19;
 163   3                      SC_CSC_CTRL2 &= ~BIT5;                                              
 164   3                      break;
 165   3                  default:
 166   3                      SC_CSC_CTRL1 = 0x00;//by pass
 167   3                      SC_CSC_CTRL2 &= ~BIT0;  
 168   3                      SC_CSC_CTRL2 &= ~BIT5;                                              
 169   3                      break;                
 170   3              }
 171   2          }
 172   1          else {
 173   2              SC_CSC_CTRL1 = BIT7 | ((ucCSCClrSpace & 0x0F) << 3);
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 4   

 174   2              SC_CSC_CTRL2 = 0x19;          
 175   2          }
 176   1      }
 177          
 178          /**************************************************************************//**
 179           * Configure Scaler CSC.
 180           * Since 370 cannot use 0x600/0x601 for CSC settings 
 181           *            -> we need to use 0x049~0x053 to configure scaler CSC
 182           ******************************************************************************/
 183          static void CSC_SetScalerCSC(void)
 184          {
 185   1          CSC_COEFE csc_coefe_set;
 186   1      
 187   1      #if !lrd_dis_benq
                  code CSC_COEFE color709toRGBcolor_coefe = {
                      //0x629, 0x1D6, 0x0BB, 0x744, 0x400, 0
                      0x18A4, 0x0758, 0x02EE, 0x1D0E, 0x1000, 0
                  };
              
                  code CSC_COEFE colorlimit709toRGBcolor_coefe = {
                      //0x72C, 0x1223, 0x10DA, 0x876, 0x4A8, 1
                      0x1CB0, 0x088B, 0x0368, 0x21D7, 0x12A0, 1 
                  };
                  
                  code CSC_COEFE color601toRGBcolor_coefe = {
                      //0x57C, 0x2CB, 0x158, 0x6EE, 0x400, 0
                  0x15F0, 0x0B2B, 0x0560, 0x1BB6, 0x1000, 0
                  };
              
                  code CSC_COEFE colorlimit601toRGBcolor_coefe = {
                      //0x662, 0x341, 0x190, 0x812, 0x4A8, 1
                  0x1989, 0x0D02, 0x0642, 0x204A, 0x12A0, 1
                  };
              
                  code CSC_COEFE xvYCC709toRGBcolor_coefe = {
                      //0x64D, 0x1DF, 0x0C0, 0x76C, 0x400, 0
                  0x1932, 0x077D, 0x02FF, 0x1DB1, 0x1000, 0
                  };
              
                  code CSC_COEFE xvYCC709limittoRGBcolor_coefe = {
                  0x1D57, 0x08B9, 0x037D, 0x2292, 0x12A0, 1
                  };
              
                  code CSC_COEFE xvYCC601toRGBcolor_coefe = {
                      //0x59C, 0x2DB, 0x160, 0x717, 0x400, 0
                      0x166F, 0x0B6D, 0x0581, 0x1C5A, 0x1000, 0
                  };
              
                  code CSC_COEFE xvYCC601limittoRGBcolor_coefe = {
                  0x1A1F, 0x0D4E, 0x0669, 0x2104, 0x12A0, 1
                  };
              
                  //if ((((SC_HDMI_DET & BIT1) != 0) && ((SC_HDMI_INT_STATE1[3] & BIT0) != 0)) ||
                      //(SC_DISPLAY_MUTE_CTRL & 0x03) != 0) { //when mute
              #else
 229   1      
 230   1      code CSC_COEFE color709toRGBcolor_coefe = {
 231   1          0x629, 0x1D6, 0x0BB, 0x744, 0x400, 0
 232   1      };
 233   1      
 234   1      code CSC_COEFE color601toRGBcolor_coefe = {
 235   1          0x57C, 0x2CB, 0x158, 0x6EE, 0x400, 0
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 5   

 236   1      };
 237   1      
 238   1      code CSC_COEFE colorlimit601toRGBcolor_coefe = {
 239   1          0x662, 0x341, 0x190, 0x812, 0x4A8, 1
 240   1      };
 241   1      
 242   1      code CSC_COEFE xvYCC709toRGBcolor_coefe = {
 243   1          0x64D, 0x1DF, 0x0C0, 0x76C, 0x400, 0
 244   1      };
 245   1      code CSC_COEFE xvYCC601toRGBcolor_coefe = {
 246   1          0x59C, 0x2DB, 0x160, 0x717, 0x400, 0
 247   1      };
 248   1      
 249   1      #endif
 250   1      #if !lrd_dis_benq
                  switch(ucCSCInputFormat) {
                      case CSCInput_709_Limit_444:
                      case CSCInput_709_Limit_422:
                          csc_coefe_set = colorlimit709toRGBcolor_coefe;
                          break;
              
                      case CSCInput_709_Full_444:
                      case CSCInput_709_Full_422:
                          csc_coefe_set = color709toRGBcolor_coefe;            
                          break;            
                          
                      case CSCInput_xvYCC601_Limit_444:
                      case CSCInput_xvYCC601_Limit_422:
                          csc_coefe_set = xvYCC601limittoRGBcolor_coefe;  
                          break;
              
                      case CSCInput_xvYCC601_Full_444:
                      case CSCInput_xvYCC601_Full_422:
                          csc_coefe_set = xvYCC601toRGBcolor_coefe;              
                          break;            
                          
                      case CSCInput_xvYCC709_Limit_444:
                      case CSCInput_xvYCC709_Limit_422:
                          csc_coefe_set = xvYCC709limittoRGBcolor_coefe;                     
                          break;
              
                      case CSCInput_xvYCC709_Full_444:
                      case CSCInput_xvYCC709_Full_422:
                          csc_coefe_set = xvYCC709toRGBcolor_coefe;     
                          break;
                          
                      case CSCInput_RGB_Limit: //601 limit range
                      case CSCInput_RGB_Full:            
                          csc_coefe_set = colorlimit601toRGBcolor_coefe;
                          break;
              
                      case CSCInput_601_Limit_444:
                      case CSCInput_601_Limit_422:
                          csc_coefe_set = colorlimit601toRGBcolor_coefe;            
                          break;
                          
                      case CSCInput_601_Full_444:
                      case CSCInput_601_Full_422:              
                      default:     //601
                          csc_coefe_set = color601toRGBcolor_coefe;
                          break;
                  }
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 6   

              #else
 299   1          switch(ucCSCInputFormat) {
 300   2              case CSCInput_709_Limit_444:
 301   2              case CSCInput_709_Full_444:
 302   2              case CSCInput_709_Limit_422:
 303   2              case CSCInput_709_Full_422:
 304   2                  csc_coefe_set = color709toRGBcolor_coefe;
 305   2                  break;
 306   2                  
 307   2              case CSCInput_xvYCC601_Limit_444:
 308   2              case CSCInput_xvYCC601_Full_444:
 309   2              case CSCInput_xvYCC601_Limit_422:
 310   2              case CSCInput_xvYCC601_Full_422:
 311   2                  csc_coefe_set = xvYCC601toRGBcolor_coefe;  
 312   2                  break;
 313   2                  
 314   2              case CSCInput_xvYCC709_Limit_444:
 315   2              case CSCInput_xvYCC709_Full_444:
 316   2              case CSCInput_xvYCC709_Limit_422:
 317   2              case CSCInput_xvYCC709_Full_422:
 318   2                  csc_coefe_set = xvYCC709toRGBcolor_coefe;                     
 319   2                  break;
 320   2      
 321   2              case CSCInput_RGB_Limit: //601 limit range
 322   2              case CSCInput_RGB_Full:            
 323   2                  csc_coefe_set = colorlimit601toRGBcolor_coefe;
 324   2                  break;
 325   2      
 326   2              case CSCInput_601_Limit_444:
 327   2              case CSCInput_601_Full_444:
 328   2              case CSCInput_601_Limit_422:
 329   2              case CSCInput_601_Full_422:              
 330   2              default:     //601
 331   2                  csc_coefe_set = color601toRGBcolor_coefe;
 332   2                  break;
 333   2          }
 334   1      #endif    
 335   1          //printf("SetScalerCSC_Coef    GetChannelIndex() = %bx %bx \r\n", ch, GetChannelIndex());
 336   1      
 337   1          WriteShortScaler(&SC_DEI_COLOR_COFFA_LO, csc_coefe_set.COEFE_A);
 338   1          WriteShortScaler(&SC_DEI_COLOR_COFFB_LO, csc_coefe_set.COEFE_B);
 339   1          WriteShortScaler(&SC_DEI_COLOR_COFFC_LO, csc_coefe_set.COEFE_C);
 340   1          WriteShortScaler(&SC_DEI_COLOR_COFFD_LO, csc_coefe_set.COEFE_D);       
 341   1          WriteShortScaler(&SC_DEI_COLOR_COFFE_LO, csc_coefe_set.COEFE_E);
 342   1      
 343   1          if (csc_coefe_set.COEFE_OFFSET == 1) {
 344   2              SC_DEI_COLOR_COFFE_HI |= BIT6;
 345   2          }
 346   1          else {
 347   2              SC_DEI_COLOR_COFFE_HI &= ~BIT6;
 348   2          }
 349   1      
 350   1          if (ucCSCInputFormat == CSCInput_Unknown) {
 351   2              SC_DEI_CSC_CTRL &= ~BIT0;
 352   2          }
 353   1          else {
 354   2               SC_DEI_CSC_CTRL = 0x09;//diasble CSC dither //0x19;
 355   2          }
 356   1      }
 357          
 358          /**************************************************************************//**
 359           *configure HDMI repetition
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 7   

 360           ******************************************************************************/
 361          static void CSC_SetRepetition(void)
 362          {
 363   1          UCHAR ch,  repeat;
 364   1      
 365   1          if ((SC_HDMI_DET & BIT1) != 0) {
 366   2              //Set repeat for Manual CSC mode
 367   2              ch = SC_HDMI_AVI[4] & 0x0F;
 368   2              repeat = SC_HDMI_CLK_INT & 0x0F;//default: No Repetition
 369   2              if (ch == 0x01) {//pixel sent 2 times
 370   3                  repeat |= 0x50;
 371   3              }
 372   2              else if (ch == 0x03) {//pixel sent 4 times
 373   3                  repeat |= 0xF0;
 374   3              }
 375   2              SC_HDMI_CLK_INT = repeat;
 376   2          }
 377   1          else {
 378   2              SC_HDMI_CLK_INT &= 0x0F;
 379   2          }
 380   1      }
 381          
 382          /**************************************************************************//**
 383           *configure Post pattern color to prevent abnormal display when mode change
 384           ******************************************************************************/
 385          static void CSC_SetPostPatternColor(void)
 386          {
 387   1          if (ucCSCClrSpace == CSC_OFF) {
 388   2              // Set video mute data for AVMute
 389   2              SC_VIDEO_BLANK_BLUE = 0x00;
 390   2              SC_VIDEO_BLANK_GREEN = 0x00;
 391   2              SC_VIDEO_BLANK_RED = 0x00;
 392   2          }
 393   1          else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {        
 394   2              if (IsHDMIVideo()) { //HDMI & YCbCr color
 395   3                  // Set video mute data for AVMute
 396   3                  SC_VIDEO_BLANK_BLUE = 0x80;
 397   3                  SC_VIDEO_BLANK_GREEN = 0x00;
 398   3                  SC_VIDEO_BLANK_RED = 0x80;
 399   3              }
 400   2                      else {
 401   3                  SC_VIDEO_BLANK_BLUE = 0x00;
 402   3                  SC_VIDEO_BLANK_GREEN = 0x00;
 403   3                  SC_VIDEO_BLANK_RED = 0x00;
 404   3              }
 405   2          }
 406   1          else {
 407   2              // Set video mute data for AVMute
 408   2              switch(ucCSCClrSpace) {
 409   3                  case CSC_YPbPr601_TO_RGB:
 410   3                  case CSC_YPbPr601_TO_RGB_FULL:
 411   3                  case CSC_YPbPr709_TO_RGB:
 412   3                  case CSC_YPbPr709_TO_RGB_FULL:
 413   3                  case CSC_YPbPr_TO_YPbPr_FULL:
 414   3                  case CSC_xvYCC601_TO_RGB:
 415   3                  case CSC_xvYCC601_TO_RGB_FULL:
 416   3                  case CSC_xvYCC709_TO_RGB:
 417   3                  case CSC_xvYCC709_TO_RGB_FULL:
 418   3                      SC_VIDEO_BLANK_BLUE = 0x80;
 419   3                      SC_VIDEO_BLANK_GREEN = 0x00;
 420   3                      SC_VIDEO_BLANK_RED = 0x80;
 421   3                      break;
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 8   

 422   3                  default :
 423   3                      SC_VIDEO_BLANK_BLUE = 0x00;
 424   3                      SC_VIDEO_BLANK_GREEN = 0x00;
 425   3                      SC_VIDEO_BLANK_RED = 0x00;
 426   3                      break;
 427   3              }
 428   2          }
 429   1      }
 430          
 431          /**************************************************************************//**
 432           * Check Input color format by each interface.
 433           ******************************************************************************/
 434          static void CSC_CheckInputFormat(UCHAR input_interface)
 435          {
 436   1          USHRT input_hactive, input_vactive;
 437   1      
 438   1          if ((input_interface == DIGITAL_INPUT0) || (input_interface == DIGITAL_INPUT1) ||
 439   1              (input_interface == DIGITAL_INPUT2) || (input_interface == DIGITAL_INPUT3)) {
 440   2      
 441   2      
 442   2              ucAVIClrSpace = (SC_HDMI_AVI[0] & 0x60); 
 443   2              
 444   2              if (IsHDMIVideo()) { //HDMI & YCbCr color 
 445   3                  ucCSCInputFormat = CSCInput_601_Limit_444;
 446   3                  if ((SC_HDMI_AVI[1] & 0xC0) == 0xC0) {//others => xvYCC709 or xvYCC601
 447   4                      ucCSCInputFormat+=8;
 448   4      
 449   4                      if ((SC_HDMI_AVI[2] & 0x70) == 0x10) { // xvYCC709
 450   5                          ucCSCInputFormat+=4;
 451   5                      }
 452   4                  }
 453   3                  else if ((SC_HDMI_AVI[1] & 0xC0) == 0x80) {//709
 454   4                      ucCSCInputFormat+=4;
 455   4                  }
 456   3      
 457   3                  if ((SC_HDMI_AVI[2] & 0x0C) != 0x04) { // not limit range
 458   4                      if((SC_HDMI_AVI[2] & 0x0C) == 0x00) { //default => check VIC
 459   5                          if ((SC_HDMI_AVI[3] & 0x7F) == 0x01) { //not video timing => full range
 460   6                              ucCSCInputFormat+=1;                                    
 461   6                          }
 462   5                      }
 463   4                      else {//full range
 464   5                          ucCSCInputFormat+=1;
 465   5                      }
 466   4                  }
 467   3      
 468   3                  if (ucAVIClrSpace == BIT5) {//4:2:2                    
 469   4                      ucCSCInputFormat+=2;            
 470   4                  }            
 471   3              }
 472   2              else { //DVI | HDMI RGB color
 473   3                  if ((SC_HDMI_DET & BIT1) != 0) {
 474   4                  //if (UserData.ucInputSource == INPUT_SC_HDMI){
 475   4                      if (UserData.ucHDMIRGBRange == COLOR_LIMIT){//if ((SC_HDMI_AVI[2] & 0x0C) == 0x04) { // Li
             -mit RGB to Full RGB
 476   5                          ucCSCInputFormat = CSCInput_RGB_Limit;
 477   5                      }
 478   4                      else if(UserData.ucHDMIRGBRange == COLOR_FULL){                 
 479   5                          ucCSCInputFormat = CSCInput_RGB_Full;
 480   5                      }
 481   4                      else{
 482   5                          if ((SC_HDMI_AVI[2] & 0x0C) == 0x08) { // Limit RGB to Full RGB
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 9   

 483   6                              ucCSCInputFormat =CSCInput_RGB_Full;
 484   6                          }
 485   5                          else {
 486   6                              ucCSCInputFormat = CSCInput_RGB_Limit;
 487   6                          }
 488   5                      }
 489   4                  }
 490   3                  else {
 491   4                      ucCSCInputFormat = CSCInput_RGB_Full;
 492   4                  }   
 493   3              }
 494   2          }
 495   1          else if ((input_interface == ANALOG_YPBPR_INPUT0) || (input_interface == ANALOG_YPBPR_INPUT1)) {
 496   2              input_hactive = ReadShortScaler(&SC_GI_CAP_HWID_LO);
 497   2              input_vactive = ReadShortScaler(&SC_GI_CAP_VLEN_LO);
 498   2              
 499   2              if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input_vac
             -tive == 720)))
 500   2              {
 501   3                  SC_CLAMP_BEGIN = 0x24;
 502   3              }
 503   2              else{
 504   3                  SC_CLAMP_BEGIN = 0x01;
 505   3              }
 506   2              Sleep(20);
 507   2              
 508   2              if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input_vac
             -tive == 720)))
 509   2              { 
 510   3                  ucCSCInputFormat = CSCInput_709_Full_444;
 511   3              }
 512   2              else { //ITU601
 513   3                  ucCSCInputFormat = CSCInput_601_Full_444;
 514   3              }
 515   2          }
 516   1      #if (INPUT_INTERFACE&INPUT_DP_MASK)
 517   1          else if ( input_interface == DISPLAY_PORT_INPUT || input_interface == DISPLAY_PORT_INPUT1 ) {
 518   2              if (SC_DP_MSA_MISC1&BIT7) { //Y only...
 519   3                  ucCSCInputFormat = CSCInput_RGB_Full;
 520   3              }
 521   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x0A) {
 522   3                  ucCSCInputFormat = CSCInput_601_Limit_422;            
 523   3              }
 524   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x1A) {
 525   3                  ucCSCInputFormat = CSCInput_709_Limit_422;            
 526   3              }
 527   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x0C) {
 528   3                  ucCSCInputFormat = CSCInput_601_Limit_444;            
 529   3              }
 530   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x1C) {
 531   3                  ucCSCInputFormat = CSCInput_709_Limit_444;
 532   3              }
 533   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x02) {
 534   3                  ucCSCInputFormat = CSCInput_xvYCC601_Limit_422;
 535   3              }
 536   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x12) {
 537   3                  ucCSCInputFormat = CSCInput_xvYCC709_Limit_422;
 538   3              }
 539   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x04) {
 540   3                  ucCSCInputFormat = CSCInput_xvYCC601_Limit_444;
 541   3              }
 542   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x14) {
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 10  

 543   3                  ucCSCInputFormat = CSCInput_xvYCC709_Limit_444;
 544   3              }
 545   2              else if((SC_DP_MSA_MISC0 & 0x1E) == 0x08) {
 546   3                  ucCSCInputFormat = CSCInput_RGB_Limit;
 547   3              }        
 548   2              else {
 549   3                  ucCSCInputFormat = CSCInput_RGB_Full;
 550   3              }
 551   2          }
 552   1      #endif
 553   1          else { // VGA
 554   2              SC_CLAMP_BEGIN = 0x01;    
 555   2              if (IsComponentInput()) {
 556   3                  if (Custom_System.bisColorFormatRGB == FALSE) {
 557   4                      UserData.bColorFormat = COLOR_YUV;
 558   4                  }
 559   3                  else {
 560   4                      Custom_System.bisColorFormatRGB = FALSE;
 561   4                  }
 562   3                      
 563   3                  if (UserData.bColorFormat == COLOR_RGB) { // only work in OS function
 564   4                      ucCSCInputFormat = CSCInput_RGB_Full;
 565   4                      SC_ADC_MID_CH_SEL = 0x00;
 566   4                  }
 567   3                  else {
 568   4                      SC_ADC_MID_CH_SEL = 0x03;
 569   4                      #if !lrd_dis_benq
                              input_hactive = pInputTiming->usModeHActive;
                              input_vactive = pInputTiming->usModeVActive;
                              #else 
 573   4                      input_hactive = InputTiming.usModeHActive;
 574   4                      input_vactive = InputTiming.usModeVActive;
 575   4                      #endif
 576   4                      if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (i
             -nput_vactive == 720)))
 577   4                      {
 578   5                          SC_CLAMP_BEGIN = 0x24;
 579   5                      }
 580   4                      else {                            
 581   5                          SC_CLAMP_BEGIN = 0x01;
 582   5                      }
 583   4                      Sleep(20);      
 584   4                      if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (i
             -nput_vactive == 720)))
 585   4                      { 
 586   5                          ucCSCInputFormat = CSCInput_709_Full_444;
 587   5                      }
 588   4                      else { //ITU601
 589   5                          ucCSCInputFormat = CSCInput_601_Full_444;
 590   5                      }
 591   4                  }
 592   3              }
 593   2              else{
 594   3                  ucCSCInputFormat = CSCInput_RGB_Full;
 595   3                  SC_ADC_MID_CH_SEL = 0x00;
 596   3              }
 597   2          }
 598   1      }
 599          
 600          static void SetColorSpace_Osd_HDMI_RGB_PC_Range(void)
 601          {
 602   1          UCHAR current_input_interface;
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 11  

 603   1         // UCHAR reg029; //lrd dis
 604   1          
 605   1          current_input_interface = GetCurrInputInterface();
 606   1      
 607   1        //  reg029 = SC_CHANNEL_INDEX; //lrd dis
 608   1         //SC_CHANNEL_INDEX &= ~BIT7;//don't set link path in all channel. //lrd dis
 609   1         // SetTMDSLinkPath(current_input_interface); //lrd dis
 610   1      
 611   1          CSC_CheckInputFormat(current_input_interface);
 612   1          CSC_SetPostPatternColor();
 613   1          CSC_SetRepetition();
 614   1          
 615   1      //#if ENABLE_SR == ON //input--->(Capture CSC)--->YCbCr--->(Scaler CSC)--->RGB
 616   1          if (ucCSCInputFormat != CSCInput_Unknown) {
 617   2              SC_HDMI_AUTO_CTRL &= ~BIT2; //disable auto csc
 618   2              SC_TMDS_AUTO_CSC &= ~BIT1; //use manual CSC
 619   2              SC_SR_AUTO_CSC_CTRL &= ~BIT0;
 620   2              SC_DP_CSC_AUTO_CONF &= ~BIT0;       
 621   2          }
 622   1          else {
 623   2              SC_HDMI_AUTO_CTRL |= BIT2; //enable auto csc
 624   2              SC_TMDS_AUTO_CSC = 0x0E; //use auto CSC
 625   2              SC_SR_AUTO_CSC_CTRL |= BIT0;
 626   2              SC_DP_CSC_AUTO_CONF |= BIT0;     
 627   2          }
 628   1      
 629   1          CSC_SetScalerCSC();
 630   1          CSC_SetCaptureCSC();
 631   1          
 632   1      //#else //input--->(Scaler CSC)--->RGB
 633   1      //#endif
 634   1      
 635   1      
 636   1         // SC_CHANNEL_INDEX = reg029;  //lrd dis
 637   1      
 638   1      }
 639          
 640          void SetColorSpace(void)
 641          {
 642   1      #if !IS_NT68150_SERIES
 643   1      
 644   1          
 645   1          SetColorSpace_Osd_HDMI_RGB_PC_Range();
 646   1      
 647   1      
 648   1      #else
                  code int SDTVcolorTab[] = {
                      1.371*1024+0.5,0.698*1024+0.5,0.336*1024+0.5,1.732*1024+0.5,
                  };
              
                  code int HDTVcolorTab[] = {
                      1.540*1024+0.5,0.459*1024+0.5,0.183*1024+0.5,1.816*1024+0.5,
                  };
              
                  UCHAR current_input_interface;
                  USHRT input_hactive, input_vactive;
              
                  current_input_interface = GetCurrInputInterface();
                  if ((current_input_interface == ANALOG_YPBPR_INPUT0) || (current_input_interface == ANALOG_YPBPR_INPUT
             -1)) {
                      input_hactive = ReadShortScaler(&SC_GI_CAP_HWID_LO);// 0x36
                      input_vactive = ReadShortScaler(&SC_GI_CAP_VLEN_LO);// 0x32
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 12  

                    if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input_vactiv
             -e == 720))){
                      SC_CLAMP_BEGIN = 0x24;// 0x021
                    }
                    else{
                      SC_CLAMP_BEGIN = 0x01;// 0x021
                    }
                      Sleep(20);
                      
                      if (ucCSCClrSpace == CSC_OFF) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                      }
                      else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_DEI_CSC_CTRL = 0x09; // 0x53
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                          if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input
             -_vactive == 720))){ //ITU709
                              WriteShortScaler(&SC_DEI_COLOR_COFFA_LO,HDTVcolorTab[0]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFB_LO,HDTVcolorTab[1]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFC_LO,HDTVcolorTab[2]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFD_LO,HDTVcolorTab[3]);
                          }
                          else {//ITU 601
                              WriteShortScaler(&SC_DEI_COLOR_COFFA_LO,SDTVcolorTab[0]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFB_LO,SDTVcolorTab[1]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFC_LO,SDTVcolorTab[2]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFD_LO,SDTVcolorTab[3]);
                          }
                      }
                      else {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = BIT7 | ((ucCSCClrSpace & 0x0F) << 3); // 0x54
                          SC_CSC_CTRL2 = 0x19; // 0x55
                      }
                  }
                  else { // VGA
              /*
                      SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC    // 0x11b
                      SC_DEI_CSC_CTRL = 0x00; // 0x53
                      SC_CSC_CTRL1 = 0x00; // 0x54
                      SC_CSC_CTRL2 = 0x00;
              */
                      SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC    // 0x11b
              #if ENABLE_SR == ON
                      SetVGADVISRCSC();
              #else
                      SC_CSC_CTRL2 = 0x00|CSC_SIM_CTRL; // 0x55
                      SC_DEI_CSC_CTRL = 0x00; // 0x53
                      SC_CSC_CTRL1 = 0x00; // 0x54
                      SC_TMDS_AUTO_CSC = 0x00;  // 0x600
                      SC_SR_AUTO_CSC_CTRL |= BIT0; // 0x601
              #endif
                  }
              #endif
 720   1      
 721   1          //CSCDitherManualModeEn();
 722   1      }
 723          
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 13  

 724          #else
              void SetColorSpace(void)
              {
              #if !IS_NT68150_SERIES
                  UCHAR current_input_interface, ch, repeat;
                  USHRT input_hactive, input_vactive;
              
              
                  current_input_interface = GetCurrInputInterface();
                  if ((current_input_interface == DIGITAL_INPUT0) || (current_input_interface == DIGITAL_INPUT1)
                   || (current_input_interface == DIGITAL_INPUT2) || (current_input_interface == DIGITAL_INPUT3)) {
                      
                       ucAVIClrSpace = (SC_HDMI_AVI[0] & 0x60);  // 0x744
                       
                      if (ucCSCClrSpace == CSC_OFF) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC   // 0x11b
                          SC_CSC_CTRL1 = 0x00;  // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                          // Set video mute data for AVMute
                          SC_VIDEO_BLANK_BLUE = 0x00;  // 0x64b
                          SC_VIDEO_BLANK_GREEN = 0x00;
                          SC_VIDEO_BLANK_RED = 0x00;
                      }
                      else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {
                          if (IsHDMIVideo()) { //HDMI & YCbCr color
                              // --------------------------
                              // Auto IN_CSC with SR mode
              #if ENABLE_SR == ON
                              SetHDMISRCSC();
              #else
                              SC_HDMI_AUTO_CTRL |= BIT2; //set auto csc// 0x6b5
                              SC_TMDS_AUTO_CSC = 0x0E;  // 0x600
              #endif
                              // Set video mute data for AVMute
                              SC_VIDEO_BLANK_BLUE = 0x80; // 0x64b
                              SC_VIDEO_BLANK_GREEN = 0x00;
                              SC_VIDEO_BLANK_RED = 0x80;
                          }
                          else { //DVI | HDMI RGB color
                              SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC  // 0x11b
              #if ENABLE_SR == ON
                              if ((SC_HDMI_DET & BIT1) != 0) { //HDMI RGB color // 0x734
                                  SetHDMISRCSC();
                              }
                              else { //dvi
                                  SetVGADVISRCSC();
                              }
              #else
              //                SC_HDMI_AUTO_CTRL |= BIT2; //set auto csc// 0x6b5
              //                SC_TMDS_AUTO_CSC = 0x0E;  // 0x600
                              SC_HDMI_AUTO_CTRL &= ~BIT2; //set auto csc// 0x6b5
                              SC_TMDS_AUTO_CSC = 0x0E;  // 0x600
                              if ((SC_HDMI_DET & BIT1) != 0) {// 0x734
                                  if ((SC_HDMI_AVI[2] & 0x0C) == 0x04) { // Limit RGB to Full RGB// 0x746
                                      SC_CSC_CTRL1 = 0xB8; // 0x54
                                      SC_CSC_CTRL2 = 0x19; // 0x55
                                  }
                                  else {
                                      SC_CSC_CTRL1 = 0x00; // 0x54
                                      SC_CSC_CTRL2 = 0x00;
                                  }
                              }
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 14  

                              else {
                                  SC_CSC_CTRL1 = 0x00; // 0x54
                                  SC_CSC_CTRL2 = 0x00; // 0x55
                              }
              #endif
                              // Set video mute data for AVMute
                              SC_VIDEO_BLANK_BLUE = 0x00; // 0x64b
                              SC_VIDEO_BLANK_GREEN = 0x00;
                              SC_VIDEO_BLANK_RED = 0x00;
                          }
                      }
                      else {
                          SC_VI_AUTO_CTRL |= BIT5; // Set auto-detection data path after CSC// 0x11b
                          SC_CSC_CTRL1 = BIT7 | ((ucCSCClrSpace & 0x0F) << 3); // 0x54
                          SC_CSC_CTRL2 = 0x19; // 0x55
              
                          // Set video mute data for AVMute
                          switch(ucCSCClrSpace) {
                              case CSC_YPbPr601_TO_RGB:
                              case CSC_YPbPr601_TO_RGB_FULL:
                              case CSC_YPbPr709_TO_RGB:
                              case CSC_YPbPr709_TO_RGB_FULL:
                              case CSC_YPbPr_TO_YPbPr_FULL:
                              case CSC_xvYCC601_TO_RGB:
                              case CSC_xvYCC601_TO_RGB_FULL:
                              case CSC_xvYCC709_TO_RGB:
                              case CSC_xvYCC709_TO_RGB_FULL:
                                  SC_VIDEO_BLANK_BLUE = 0x80; // 0x64b
                                  SC_VIDEO_BLANK_GREEN = 0x00;
                                  SC_VIDEO_BLANK_RED = 0x80;
                                  break;
                              default :
                                  SC_VIDEO_BLANK_BLUE = 0x00; // 0x64b
                                  SC_VIDEO_BLANK_GREEN = 0x00;
                                  SC_VIDEO_BLANK_RED = 0x00;
                                  break;
                          }
                      }
              //////////////////////////////////////////////////////////////////////////
                      if ((SC_HDMI_DET & BIT1) != 0) {// 0x734
                          if (ucAVIClrSpace == BIT5) {//4:2:2
                              SC_CSC_CTRL2 |= BIT5; // 0x55
                          }
                          //Set repeat for Manual CSC mode
                          ch = SC_HDMI_AVI[4] & 0x0F;// 0x748
                          repeat = SC_HDMI_CLK_INT & 0x0F;//default: No Repetition  // 0x608
                          if (ch == 0x01) {//pixel sent 2 times
                              repeat |= 0x50;
                          }
                          else if (ch == 0x03) {//pixel sent 4 times
                              repeat |= 0xF0;
                          }
                          SC_HDMI_CLK_INT = repeat;// 0x608
                      }
                      else {
                          SC_HDMI_CLK_INT &= 0x0F;// 0x608
                      }
              ///////////////////////////////////////////////////////////////////////////
                  }
                  else if ((current_input_interface == ANALOG_YPBPR_INPUT0) || (current_input_interface == ANALOG_YPBPR_
             -INPUT1)) {
                      input_hactive = ReadShortScaler(&SC_GI_CAP_HWID_LO);// 0x36
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 15  

                      input_vactive = ReadShortScaler(&SC_GI_CAP_VLEN_LO);// 0x32
                    if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input_vactiv
             -e == 720))){
                      SC_CLAMP_BEGIN = 0x24;// 0x021
                    }
                    else{
                      SC_CLAMP_BEGIN = 0x01;// 0x021
                    }
                      Sleep(20);
                      
                      if (ucCSCClrSpace == CSC_OFF) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                      }
                      else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
              
                          SC_DEI_CSC_CTRL = 0x19;  // 0x53
                          SC_CSC_CTRL2 = 0x00;//|CSC_SIM_CTRL; // 0x55
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input
             -_vactive == 720))){ //ITU709
                              SC_SR_AUTO_CSC_CTRL = 0x31;  // 0x601
                          }
                          else { //ITU601
                              SC_SR_AUTO_CSC_CTRL = 0x01; // 0x601
                          }
                      }
                      else {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = BIT7 | ((ucCSCClrSpace & 0x0F) << 3); // 0x54
                          SC_CSC_CTRL2 = 0x19; // 0x55
                      }
                  }
              #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
                  else if (current_input_interface == DISPLAY_PORT_INPUT) {
              #if ENABLE_SR == ON
                      SetDPSRCSC();
              #else
                      SC_DP_CSC_AUTO_CONF |= BIT0;  // 0x1040
              #endif
                  }
              #endif
                  else { // VGA
                      SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC    // 0x11b
              #if ENABLE_SR == ON
                      SetVGADVISRCSC();
              #else
                      SC_CSC_CTRL2 = 0x00|CSC_SIM_CTRL; // 0x55
                      SC_DEI_CSC_CTRL = 0x00; // 0x53
                      SC_CSC_CTRL1 = 0x00; // 0x54
                      SC_TMDS_AUTO_CSC = 0x00;  // 0x600
                      SC_SR_AUTO_CSC_CTRL |= BIT0; // 0x601
              #endif
                  }
              #else
                  code int SDTVcolorTab[] = {
                      1.371*1024+0.5,0.698*1024+0.5,0.336*1024+0.5,1.732*1024+0.5,
                  };
              
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 16  

                  code int HDTVcolorTab[] = {
                      1.540*1024+0.5,0.459*1024+0.5,0.183*1024+0.5,1.816*1024+0.5,
                  };
              
                  UCHAR current_input_interface;
                  USHRT input_hactive, input_vactive;
              
                  current_input_interface = GetCurrInputInterface();
                  if ((current_input_interface == ANALOG_YPBPR_INPUT0) || (current_input_interface == ANALOG_YPBPR_INPUT
             -1)) {
                      input_hactive = ReadShortScaler(&SC_GI_CAP_HWID_LO);// 0x36
                      input_vactive = ReadShortScaler(&SC_GI_CAP_VLEN_LO);// 0x32
                    if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input_vactiv
             -e == 720))){
                      SC_CLAMP_BEGIN = 0x24;// 0x021
                    }
                    else{
                      SC_CLAMP_BEGIN = 0x01;// 0x021
                    }
                      Sleep(20);
                      
                      if (ucCSCClrSpace == CSC_OFF) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                      }
                      else if (ucCSCClrSpace == CSC_HDMI_AUTO_CLR_SPACE) {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_DEI_CSC_CTRL = 0x09; // 0x53
                          SC_CSC_CTRL1 = 0x00; // 0x54
                          SC_CSC_CTRL2 = 0x00; // 0x55
                          if (((input_hactive == 1920) && (input_vactive == 1080)) || ((input_hactive == 1280) && (input
             -_vactive == 720))){ //ITU709
                              WriteShortScaler(&SC_DEI_COLOR_COFFA_LO,HDTVcolorTab[0]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFB_LO,HDTVcolorTab[1]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFC_LO,HDTVcolorTab[2]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFD_LO,HDTVcolorTab[3]);
                          }
                          else {//ITU 601
                              WriteShortScaler(&SC_DEI_COLOR_COFFA_LO,SDTVcolorTab[0]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFB_LO,SDTVcolorTab[1]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFC_LO,SDTVcolorTab[2]);
                              WriteShortScaler(&SC_DEI_COLOR_COFFD_LO,SDTVcolorTab[3]);
                          }
                      }
                      else {
                          SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC// 0x11b
                          SC_CSC_CTRL1 = BIT7 | ((ucCSCClrSpace & 0x0F) << 3); // 0x54
                          SC_CSC_CTRL2 = 0x19; // 0x55
                      }
                  }
                  else { // VGA
              /*
                      SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC    // 0x11b
                      SC_DEI_CSC_CTRL = 0x00; // 0x53
                      SC_CSC_CTRL1 = 0x00; // 0x54
                      SC_CSC_CTRL2 = 0x00;
              */
                      SC_VI_AUTO_CTRL &= ~BIT5; // Set auto-detection data path before CSC    // 0x11b
              #if ENABLE_SR == ON
                      SetVGADVISRCSC();
              #else
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 17  

                      SC_CSC_CTRL2 = 0x00|CSC_SIM_CTRL; // 0x55
                      SC_DEI_CSC_CTRL = 0x00; // 0x53
                      SC_CSC_CTRL1 = 0x00; // 0x54
                      SC_TMDS_AUTO_CSC = 0x00;  // 0x600
                      SC_SR_AUTO_CSC_CTRL |= BIT0; // 0x601
              #endif
                  }
              #endif
              
                  //CSCDitherManualModeEn();
              }
              #endif
 977          
 978          #if !((OSDTYPE == OSD_BENQ_V2) || (OSDTYPE == OSD_BENQ_V1) || (OSDTYPE == OSD_BENQ) )
              
              #if ENABLE_HDMI == ON
              /**************************************************************************//**
               * Set HDMI SR CSC
               ******************************************************************************/
               
              void SetHDMISRCSC(void)
              {
                  UCHAR Reg0x1ED, ch, Reg0x600, Reg0x649;
              //    if ((SC_DISPLAY_MUTE_CTRL & 0x03) != 0) { //when mute
                  if (((SC_DISPLAY_MUTE_CTRL & 0x03) != 0) || ((SC_HDMI_INT_STATE1[3] & BIT0) != 0)) { //when mute 0x154
             -,0x673
                      ch = SC_SR_CTRL; //set SR on// 0xea0
                      Reg0x1ED = SC_ADC_BAND_GAP;// 0x1ed
                      SC_ADC_BAND_GAP &= ~BIT0;// 0x1ed
                      SC_SR_CTRL = 0x51;// 0xea0
                      SC_HDMI_AUTO_CTRL |= BIT2; //set auto csc// 0x6b5
                      SC_TMDS_AUTO_CSC = 0x0E;  // 0x600
                      SC_HDMI_RESET_CTRL &= ~BIT3;// 0x713
                      Sleep(50); //wait one frame
                      Reg0x649 = SC_ICPCSC_AUTOSTATUS; //read Reg0x600 & Reg0x649
                      Reg0x600 = SC_TMDS_AUTO_CSC;  // 0x600
                      SC_HDMI_AUTO_CTRL &= ~BIT2;//set manual csc// 0x6b5
                      SC_TMDS_AUTO_CSC &= ~BIT1;  // 0x600
                      SC_SR_CTRL = ch; //restore SR// 0xea0
                      SC_ADC_BAND_GAP = Reg0x1ED;// 0x1ed
                      ch = SC_CSC_CTRL1 & 0x87; //fill Reg0x054 // 0x54
                      SC_CSC_CTRL1 = ch | ((Reg0x649 & 0xF0) >> 1) | BIT7; // 0x54
                      ch = SC_SR_AUTO_CSC_CTRL & 0x0F; //fill Reg0x601 // 0x601
                      SC_SR_AUTO_CSC_CTRL = ch | (Reg0x600 & 0xF0) | BIT0; // 0x601
                      if ((Reg0x600 & BIT0) == 0) { //set Reg0x053[0]
                          SC_DEI_CSC_CTRL = 0x19; // 0x53
                      }
                      else {
                          SC_DEI_CSC_CTRL = 0x18; // 0x53
                      }
                      if ((Reg0x649 & BIT0) == 0) { //set Reg0x055[0]
                          SC_CSC_CTRL2 = 0x19; // 0x55
                      }
                      else {
                          SC_CSC_CTRL2 = 0x18; // 0x55
                      }
              ///////////////////////////////////////////////////////////////////////////////
              #if 1//TPV Limited RGB
                      if (!IsHDMIVideo()) { //HDMI RGB color
                          if ((SC_HDMI_AVI[2] & 0x0C) == 0x04) { // Limited RGB// 0x746
                              if(GetSCID() == SCID_770_E){
                                  SC_CSC_CTRL1 = 0xF0;//limited RGB to Ycbcr601 // 0x54
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 18  

                              }
                              else {
                                  SC_CSC_CTRL1 = 0x88;//RGB to Ycbcr601 // 0x54
                              }
                          }
                          else {
                              if(GetSCID() == SCID_770_E){
                                  SC_CSC_CTRL1 = 0x88;//Full RGB to Ycbcr601 // 0x54
                              }
                              else {
                                  SC_CSC_CTRL1 = 0xF8;//Full RGB to limited Ycbcr601 // 0x54
                              }
                          }      
               
                          if(GetSCID() == SCID_770_E){
                              SC_SR_AUTO_CSC_CTRL = 0x03; //Ycbcr601 to RGB            // 0x601
                          }
                          else {
                              SC_SR_AUTO_CSC_CTRL = 0x23; //limited Ycbcr601 to RGB         // 0x601   
                          }
                      }
              #endif
              ///////////////////////////////////////////////////////////////////////////////
                  }
              }
              #endif
              
              /**************************************************************************//**
               * Set VGA DVI SR CSC.
               ******************************************************************************/
              void SetVGADVISRCSC(void)
              {
                  if ((SC_DISPLAY_MUTE_CTRL & 0x03) != 0) { //when mute
                      SC_HDMI_AUTO_CTRL &= ~BIT2;//set manual csc// 0x6b5
                      SC_TMDS_AUTO_CSC &= ~BIT1;  // 0x600
                      SC_DEI_CSC_CTRL = 0x19; // 0x53
                      SC_CSC_CTRL1 = 0x88; // 0x54
                      SC_CSC_CTRL2 = 0x99; // 0x55
                      SC_SR_AUTO_CSC_CTRL = 0x03; // 0x601
                  }
              }
              #if ((INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_IN
             -TERFACE&INPUT_DP3)) && ENABLE_SR == ON
              /**************************************************************************//**
               * Set DP SR CSC.
               ******************************************************************************/
               
              void SetDPSRCSC(void)
              {
                  UCHAR Reg0x1ED, ch, Reg0x109D, Reg0x109E;
                  if ((SC_DISPLAY_MUTE_CTRL & 0x03) != 0) { //when mute   // 0x154
                      ch = SC_SR_CTRL; //set SR on   // 0xea0
                      Reg0x1ED = SC_ADC_BAND_GAP;  // 0x1ed
                      SC_ADC_BAND_GAP &= ~BIT0;// 0x1ed
                      SC_SR_CTRL = 0x51;// 0xea0
                      SC_DP_CSC_AUTO_CONF |= BIT0; //DP CSC auto // 0x1040
                      SC_HDMI_RESET_CTRL &= ~BIT3;  // 0x713
                      Sleep(50); //wait one frame
                      Reg0x109D = SC_DP_109D; //read Reg0x109D & Reg0x109E
                      Reg0x109E = SC_DP_109E;
                      SC_DP_CSC_AUTO_CONF &= ~BIT0; //DP CSC manual // 0x1040
                      SC_SR_CTRL = ch; //restore SR// 0xea0
C51 COMPILER V9.54   SCALER_CSC                                                            01/06/2017 14:56:51 PAGE 19  

                      SC_ADC_BAND_GAP = Reg0x1ED;// 0x1ed
              
                      ch = SC_CSC_CTRL1 & 0x87; //fill Reg0x054 // 0x54
                      SC_CSC_CTRL1 = ch | ((Reg0x109D & 0x0F) << 3) | BIT7; // 0x54
                      ch = SC_SR_AUTO_CSC_CTRL & 0x0F; //fill Reg0x601 // 0x601
                      SC_SR_AUTO_CSC_CTRL = ch | ((Reg0x109E & 0x0F) << 4) | BIT0; // 0x601
                      if ((Reg0x109E & BIT6) == 0) { //set Reg0x053[0]
                          SC_DEI_CSC_CTRL = 0x1A; // 0x53
                      }
                      else {
                          SC_DEI_CSC_CTRL = 0x1B; // 0x53
                      }
                      if ((Reg0x109E & BIT4) == 0) { //set Reg0x055[0]
                          SC_CSC_CTRL2 = 0x1A; // 0x55
                      }
                      else {
                          SC_CSC_CTRL2 = 0x1B; // 0x55
                      }
                      if ((Reg0x109E & BIT7) != 0) {//4:2:2
                          SC_CSC_CTRL2 |= BIT5; // 0x55
                      }
                  }
              }
              #endif
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1424    ----
   CONSTANT SIZE    =     55    ----
   XDATA SIZE       =      3      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
