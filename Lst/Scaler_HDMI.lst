C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCALER_HDMI
OBJECT MODULE PLACED IN .\Bin\Scaler_HDMI.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Lib\NT68810 Series\Scaler_HDMI.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.
                    -\App;.\App\OSD;.\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Compone
                    -nt;.\Phy\SI\NVT\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT68870_
                    -MODULE,LVIEW_2560X1440,FLASH_BANK=8) PRINT(.\Lst\Scaler_HDMI.lst) TABS(2) OBJECT(.\Bin\Scaler_HDMI.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          #include "ScalerProfile.h"
  14          
  15          #if ENABLE_HDMI == ON
  16          
  17          //******************************************************************************
  18          // M A C R O   D E F I N I T I O N S
  19          //******************************************************************************
  20          #if AUDIO_OUT == IIS_OUT
                  #define AUDIO_PINOUT_SEL       0x04
                  #define AUDIO_OUT_CTRL         0x00
                  #define AUDIO_OUT_IIS_CTRL1    0x40
                  #define AUDIO_OUT_IIS_CTRL2    0xF8
                  #define AUDIO_OUT_IIS_CTRL3    0x05
                  #define AUDIO_EXT_CAP          0x00
              #else
  28              #define AUDIO_PINOUT_SEL       0x00
  29              #define AUDIO_OUT_CTRL         0x01
  30              #define AUDIO_EXT_CAP          0x00
  31              #define AUDIO_OUT_IIS_CTRL3    0x60
  32          #endif
  33          
  34          //******************************************************************************
  35          // G L O B A L   V A R I A B L E S
  36          //******************************************************************************
  37          #if ENABLE_HDMI_AUDIO_CK_RCVY == ON 
              /*!
               * Data type for HDMI audio clock recovery (ARC).
               */
              typedef struct _ACRITM_ {
                  ULONG ulNSVAL;
                  ULONG ulCTSSVAL;
              } ACRItm;
              
              /*!
               * Data type for HDMI audio clock recovery (ARC).
               */
              typedef enum _HDMICLKTYPE_ {
                  HDMI_25MHz,
                  HDMI_25MHz_101,
                  HDMI_27MHz,
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 2   

                  HDMI_27MHz_101,
                  HDMI_54MHz,
                  HDMI_54MHz_101,
                  HDMI_74MHz,
                  HDMI_74MHz_101,
                  HDMI_148MHz,
                  HDMI_148MHz_101,
                  HDMI_297MHz,
                  HDMI_297MHz_101,
                  NUM_HDMICLKTYPE
              } HDMICLKTYPE;
              
              /*!
               * Data type for HDMI audio clock recovery (ARC).
               */
              typedef enum _AUDIOFSTYPE_ {
                  AUDIOFS_44KHz,
                  AUDIOFS_NOTINDICATED,
                  AUDIOFS_48KHz,
                  NUM_AUDIOFSTYPE
              } AUDIOFSTYPE;
              #endif
  75          
  76          //******************************************************************************
  77          // S T A T I C   V A R I A B L E S
  78          //******************************************************************************
  79          static BOOL bHDMIMute = FALSE; /*!< Status of HDMI mute. */
  80          static UCHAR ucDelayAudioInitStatus;
  81          static USHRT usTimerAudioInit;
  82          static USHRT usTimerAudioPacket;
  83          static bit bReceivedAudioPacket;
  84          #if ENABLE_INTERNAL_AUDIO_BUZZER == ON
              static UCHAR ucReg0x8605; /*!< Temperal storage for scaler register. */
              static UCHAR ucReg0x8700; /*!< Temperal storage for scaler register. */
              static UCHAR ucReg0x871A; /*!< Temperal storage for scaler register. */
              static UCHAR ucReg0x871D; /*!< Temperal storage for scaler register. */
              #endif
  90          
  91          //******************************************************************************
  92          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  93          //******************************************************************************
  94          
  95          //******************************************************************************
  96          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  97          //******************************************************************************
  98          static void ConfigHDMIAnalogAudioGain(UCHAR value);
  99          static void ConfigHDMIDigitalAudioGain(USHRT value);
 100          static void AudioOffset(void);
 101          #if ENABLE_HDMI_AUDIO_CK_RCVY == ON 
              static void HDMIAudioACRCorrection(void);
              #endif
 104          //******************************************************************************
 105          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
 106          //******************************************************************************
 107          
 108          //******************************************************************************
 109          // F U N C T I O N   B O D Y S
 110          //******************************************************************************
 111          
 112          /**************************************************************************//**
 113           * Get deep color mode by HDMI deep color PLL divider M select
 114           ******************************************************************************/
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 3   

 115          /*
 116          UCHAR GetSCDeepColor(void)
 117          {
 118           UCHAR ret=DEEP_COLOR_24BIT;
 119              switch (SC_DVI_PLL_M) {
 120                  default:
 121                  case 0x10:
 122                  case 0x20:   
 123                      ret = DEEP_COLOR_24BIT;
 124                      break;
 125                  case 0x28:
 126                      ret = DEEP_COLOR_30BIT;
 127                      break;
 128                  case 0x30:
 129                      ret = DEEP_COLOR_36BIT;
 130                      break;
 131                  case 0x40:
 132                      ret = DEEP_COLOR_48BIT;
 133                      break;
 134              }
 135          
 136              return ret;
 137          }
 138          */
 139          
 140          /**************************************************************************//**
 141           * CSC Dithering Manual Mode Enable
 142           * For The MNT screen have garbage/mute issue when AVI InfoFrame change.
 143           ******************************************************************************/
 144          /*
 145          void CSCDitherManualModeEn(void)
 146          {
 147           if((SC_CSC_CTRL2 & BIT0) == 0x01){
 148              SC_HDMI_RESET_CTRL &= ~BIT3;  
 149            if((GetSCDeepColor() >= DEEP_COLOR_30BIT)||((SC_HDMI_AVI[0] & 0x60) == BIT5)){// 10/12/16 bit deep color
             - or YCbCr 422
 150              SC_CSC_CTRL2 |= BIT4;
 151            }
 152            else{
 153              SC_CSC_CTRL2 &= ~BIT4;
 154            }
 155           }
 156          }
 157          */
 158          
 159          /**************************************************************************//**
 160           * Initialize HDMI-related registers.
 161           ******************************************************************************/
 162          void HDMIInit(void)
 163          {
 164   1          SC_HDMI_SOFTWARE_RESET = 0xFF;
 165   1          SC_HDMI_SOFTWARE_RESET = 0x10;
 166   1      
 167   1          SC_TMDS_LINK_CLK_SEL = SCREG_1E7 | BIT0 | BIT7;// 0x1e7
 168   1          ScalerAudioPreMute();
 169   1      #if defined(ENABLE_FPGA_MODE)
                  SC_FPGA_AUDIO_PLL = 0x83;
              #endif
 172   1      //    ScalerAudioPowerOn();
 173   1      #if AUDIO_OUT == IIS_OUT
                  SC_AUDIO_OUT_IIS_CTRL1 = AUDIO_OUT_IIS_CTRL1;
                  SC_AUDIO_OUT_IIS_CTRL2 = AUDIO_OUT_IIS_CTRL2;
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 4   

              #endif
 177   1          SC_AUDIO_OUT_IIS_CTRL3 = AUDIO_OUT_IIS_CTRL3;
 178   1      
 179   1          // Enable external cap for improving audio performance
 180   1      //    SC_AUDIO_DAC_DRIV_CTRL = 0xcc; //test by Rex 0x00
 181   1          SC_AUDIO_EXT_CAP_CTRL |= BIT4;
 182   1          SC_AUDIO_OUT_CTRL = 0x02;
 183   1      //    SC_AUDIO_ANALOG_OUT_CTRL = 0xF4;
 184   1          
 185   1          usTimerAudioInit = GetTimerTick();
 186   1          ucDelayAudioInitStatus = 0x00;
 187   1          
 188   1          SC_PD_PMCLK |= (BIT6|BIT7);
 189   1          SC_AUDIO_AUTO_CTRL8 |= BIT1;//Sigma Delta audio clock gated // 0x8ae
 190   1      
 191   1      #if ENABLE_HDMI_AUDIO_AUTO_MUTE == ON
                  SC_AUDIO_AUTO_CTRL1 = 0x00;  // 0x8a7
                  if(GetSCID() == SCID_770_E){
                      SC_AUDIO_AUTO_CTRL2 = 0x02; // 0x8a8
                  }
                  else{
                      SC_AUDIO_AUTO_CTRL2 = 0x20; // 0x8a8
                  }
                  SC_AUDIO_AUTO_CTRL3 = 0x32; // 0x8a9
                  SC_AUDIO_AUTO_CTRL4 = 0xC6; // 0x8aa
              #endif
 202   1      
 203   1          SC_HDMI_CLK_INT |= BIT0; // Normal HDMI interrupt// 0x608
 204   1          SC_CP_PACKET_TYPE = 0x83;//0x02;
 205   1          SC_HDMI_PREAMBLE_CYCLE = 0x06;
 206   1          ScalerAudioPowerOn();
 207   1      }
 208          
 209          void HDMIDelayAudioInit(void)
 210          {
 211   1          switch (ucDelayAudioInitStatus) {
 212   2              case 0x00:
 213   2                  if ((GetTimerTick()-usTimerAudioInit) > 500) {//delay 500ms
 214   3                      ucDelayAudioInitStatus = 0x01;
 215   3                      //SC_AUDIO_ANALOG_OUT_CTRL = 0xF4;
 216   3                      SC_AUDIO_DAC_DRIV_CTRL = 0x00;
 217   3                      SC_AUDIO_SELECT = 0x00;
 218   3                      SC_AUDIO_AUTO_CTRL_8B5 = 0x81;
 219   3                      SC_AUDIO_TEST1 = 0x07;//test by Rex 0x07;
 220   3                      SC_AUDIO_OUT_CTRL = 0x03;
 221   3                      SC_AUDIO_ANALOG_OUT_CTRL = 0x74;
 222   3                      usTimerAudioInit = GetTimerTick();
 223   3                  }
 224   2                  break;
 225   2              case 0x01:
 226   2                  if ((GetTimerTick()-usTimerAudioInit) > 40) {//delay 40ms
 227   3                      ucDelayAudioInitStatus = 0x02;
 228   3                      SC_AUDIO_ANALOG_OUT_CTRL = 0x7C;//[N3]vcm run
 229   3                      SC_AUDIO_EXT_CAP_CTRL &= ~BIT4;//BYP off
 230   3                      usTimerAudioInit = GetTimerTick();
 231   3                  }
 232   2                  break;
 233   2              default:
 234   2                  break;
 235   2          }
 236   1                  
 237   1      }
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 5   

 238          /**************************************************************************//**
 239           * System perform this function periodically to handle the HDMI events.
 240           * For example, Color space changed, AV mute etc...
 241           ******************************************************************************/
 242          void HdmiHandler(void)
 243          {
 244   1          UCHAR ch;
 245   1      
 246   1          ch = GetCurrInputInterface();
 247   1          if ((ch != DIGITAL_INPUT0) && (ch != DIGITAL_INPUT1) && (ch != DIGITAL_INPUT2) && (ch != DIGITAL_INPUT
             -3)) {
 248   2              return;
 249   2          }
 250   1          
 251   1      #if ENABLE_SCALER_AUDIO == ON
 252   1          if (SC_DISPLAY_MUTE_CTRL == 0x00) {
 253   2              ch = SC_HDMI_INT_STATE1[1];
 254   2              if ((ch & (BIT6)) != 0x00) {
 255   3                  SC_HDMI_MUTE |= BIT1; // 0x737
 256   3                  usAudioMuteDelay = HDMI_AUDIODELAY;
 257   3                  SC_HDMI_INT_STATE1[1] = ch;
 258   3              }
 259   2              else {
 260   3                  if (usAudioMuteDelay != 0) {
 261   4                      usAudioMuteDelay--;
 262   4                  }
 263   3                  else {
 264   4                      SC_HDMI_MUTE &= ~BIT1;// 0x737
 265   4                  }
 266   3              }
 267   2          }
 268   1      #endif
 269   1      
 270   1          bHDMIMute = FALSE;
 271   1      
 272   1          ch = SC_HDMI_INT_STATE1[2];
 273   1          if (ch != 0) {
 274   2              //printf("SC_HDMI_INT_STATE1[2] = %02BX\r\n", ch);
 275   2              if ((ch & BIT7) != 0) {
 276   3                  //printf("HDMI/DVI change\r\n");
 277   3                  bHDMIMute = TRUE;
 278   3              }
 279   2              //if ((ch & BIT4) != 0) {
 280   2              //    printf("Clock detect change detected\r\n");
 281   2              //}
 282   2              //if ((ch & BIT3) != 0) {
 283   2              //    printf("Sync detect change detected\r\n");
 284   2              //}
 285   2              if ((ch & BIT1) != 0) {
 286   3                  bReceivedAudioPacket = TRUE;
 287   3                  usTimerAudioPacket = GetTimerTick();
 288   3      //            printf("Received audio packet\r\n");
 289   3              }
 290   2              else {
 291   3                  if ((GetTimerTick() - usTimerAudioPacket) > 50) {
 292   4                      bReceivedAudioPacket = FALSE;
 293   4                      usTimerAudioPacket = GetTimerTick();
 294   4                  }
 295   3              }
 296   2              //if ((ch & BIT0) != 0) {
 297   2              //    printf("Video clock frequency changed\r\n");
 298   2              //}
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 6   

 299   2              SC_HDMI_INT_STATE1[2] = ch;
 300   2          }
 301   1          ch = SC_HDMI_INT_STATE1[3];
 302   1          if (ch != 0) {
 303   2              //printf("SC_HDMI_INT_STATE1[3] = %02BX\r\n", ch);
 304   2              //if ((ch & BIT7) != 0) {
 305   2              //    printf("New General Control Packet detected\r\n");
 306   2              //}
 307   2              if ((ch & BIT6) != 0) {
 308   3                  bHDMIMute = TRUE;
 309   3                  //printf("General Control Packet set to mute\r\n");
 310   3              }
 311   2              if ((ch & BIT4) != 0) {
 312   3                  //printf("New/changed unrecognized packet detected\r\n");
 313   3              }
 314   2              if ((ch & BIT3) != 0) {
 315   3                  //printf("New/changed MPEG InfoFrame detected\r\n");
 316   3              }
 317   2              if ((ch & BIT2) != 0) {
 318   3                  //printf("New/changed audio InfoFrame detected\r\n");
 319   3              }
 320   2              if ((ch & BIT1) != 0) {
 321   3                  //printf("New/changed SPD InfoFrame detected\r\n");
 322   3              }
 323   2              if ((ch & BIT0) != 0) {
 324   3                  //printf("New/changed AVI InfoFrame detected\r\n");
 325   3                  if (GetModeHandleState() == WAIT_MODE_CHANGE){
 326   4                      if ((SC_HDMI_AVI[0] & 0x60) != GetScalerColorSpace()){
 327   5                          SetModeChangeFlag();
 328   5                      }
 329   4                  }
 330   3                  else{
 331   4                      SetColorSpace();
 332   4                  }
 333   3              }
 334   2              SC_HDMI_INT_STATE1[3] = ch;
 335   2          }
 336   1          ch = SC_HDMI_INT_STATE1[4];
 337   1          if (ch != 0) {
 338   2              //printf("SC_HDMI_INT_STATE1[4] = %02BX\r\n", ch);
 339   2              if ((ch & BIT4) != 0) {
 340   3                  //printf("No AVI\r\n");
 341   3              }
 342   2      //        if ((SC_CTRL_PACKET[0] != 0) && (SC_CTRL_PACKET[1] != 0)) {
 343   2              if (bReceivedAudioPacket == TRUE) {
 344   3      #if ENABLE_HDMI_AUDIO_CK_RCVY == ON 
                          HDMIAudioACRCorrection(); // 20100727 Leon for unknown media player
              #endif
 347   3      #if ENABLE_HDMI_FS_MUTE == ON 
                          HDMIAPI_MuteUnmatchedFs();
              #endif
 350   3                  if ((ch & BIT0) != 0) {
 351   4                      //printf("FIFO under run\r\n");
 352   4                      SC_HDMI_SOFTWARE_RESET |= BIT1;
 353   4                      SC_HDMI_SOFTWARE_RESET &= ~BIT1;
 354   4                      Sleep(5);
 355   4                  }
 356   3                  if ((ch & BIT1) != 0) {
 357   4                      //printf("FIFO over run\r\n");
 358   4                      SC_HDMI_SOFTWARE_RESET |= BIT1;
 359   4                      SC_HDMI_SOFTWARE_RESET &= ~BIT1;
 360   4                      Sleep(5);
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 7   

 361   4                  }
 362   3              }
 363   2              SC_HDMI_INT_STATE1[4] = ch;
 364   2          }
 365   1          
 366   1      }
 367          
 368          /**************************************************************************//**
 369           * Check HDMI audio/video are muted or not.
 370           * @return TRUE if HDMI audio/video are muted else FALSE.
 371           ******************************************************************************/
 372          BOOL IsHDMIDataMute(void)
 373          {
 374   1          return bHDMIMute;
 375   1      }
 376          
 377          /**************************************************************************//**
 378           * Clear HDMI-related interrupt status.
 379           * E.x. AV mute.
 380           ******************************************************************************/
 381          void ClearHDMIStatus(void)
 382          {
 383   1          SC_HDMI_INT_STATE1[2] = (BIT7 | BIT4 | BIT3);
 384   1          SC_HDMI_INT_STATE1[3] = BIT6;
 385   1      }
 386          
 387          #if 0
              /**************************************************************************//**
               * Enable AVMute interrupt.
               * @param enable TRUE to enable HDMI AVMute interrupt.
               ******************************************************************************/
              void HDMIEnableAVMuteInt(UCHAR enable)
              {
                  if (enable) {
                      SC_HDMI_INT_UNMASK1[2] |= BIT6;
                      McuScalerHDMIIntEnable();
                  }
                  else {
                      SC_HDMI_INT_UNMASK1[2] &= ~BIT6;
                      McuScalerHDMIIntDisable();
                  }
              }
              #endif
 404          
 405          /**************************************************************************//**
 406           * Detect the status of deep color from info-frame and set proper divider.
 407           ******************************************************************************/
 408          USHRT TMDSDeepColorDetection(void)
 409          {
 410   1          USHRT clock;
 411   1          UCHAR phyindex = _DPPP_PHY0;
 412   1      #if IS_NT68870_SERIES
 413   1          UCHAR curr_interface;
 414   1          curr_interface = GetCurrInputInterface();
 415   1          if ((curr_interface == DIGITAL_INPUT2) || (curr_interface == DIGITAL_INPUT3)) {
 416   2              phyindex = _DPPP_PHY1;
 417   2          }
 418   1      #endif
 419   1      
 420   1          clock = TMDS_GetClock();
 421   1      
 422   1      #if ENABLE_DVI_DUAL_LINK == ON
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 8   

 423   1          if (TMDS_IsDualLink()) {
 424   2            return clock;
 425   2          }   
 426   1      #endif  
 427   1      
 428   1          if ((SC_HDCP_PACKING & 0x07)==0x04) {
 429   2              SC_TMDS_LINK_CLK_SEL |= (BIT7|BIT0);// 0x1e7
 430   2          }
 431   1          else {
 432   2              SC_TMDS_LINK_CLK_SEL &= ~(BIT7|BIT0);// 0x1e7
 433   2          }
 434   1      
 435   1          switch (SC_HDCP_PACKING & 0x07) {
 436   2              case 4://8 bit
 437   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_DIV, 0x00);//Addr = 0x9C24; *Addr = 0x00;
 438   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_HI, 0x00);//Addr = 0x9C25; *Addr = 0x00;
 439   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_MI, 0x00);//Addr = 0x9C26; *Addr = 0x00;
 440   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_LO, 0x00);//Addr = 0x9C27; *Addr = 0x00;
 441   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0x00);//Addr = 0x9C20; *Addr = 0x00;
 442   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x00);//Addr = 0x9C21; *Addr = 0x00;
 443   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 444   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 445   2                  SC_DVI_PLL_M = 0x20;  // 0xb18
 446   2                  break;
 447   2              case 5://10 bit
 448   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_DIV, 0x00);//Addr = 0x9C24; *Addr = 0x00;
 449   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_HI, 0x00);//Addr = 0x9C25; *Addr = 0x00;
 450   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_MI, 0x00);//Addr = 0x9C26; *Addr = 0x00;
 451   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_LO, 0x00);//Addr = 0x9C27; *Addr = 0x00;
 452   2                  if (IsTMDSLBR(phyindex) == TRUE) {
 453   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC2);//Addr = 0x9C20; *Addr = 0xC2;
 454   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x19);//Addr = 0x9C21; *Addr = 0x19;
 455   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 456   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 457   3                  }
 458   2                  else {
 459   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC0);//Addr = 0x9C20; *Addr = 0xC0;
 460   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x19);//Addr = 0x9C21; *Addr = 0x19;
 461   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 462   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 463   3                  }
 464   2                  SC_DVI_PLL_M = 0x28;// 0xb18
 465   2                  clock = (clock * 8 + 5) / 10;
 466   2                  break;
 467   2              case 6://12 bit
 468   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_DIV, 0x00);//Addr = 0x9C24; *Addr = 0x00;
 469   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_HI, 0x00);//Addr = 0x9C25; *Addr = 0x00;
 470   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_MI, 0x00);//Addr = 0x9C26; *Addr = 0x00;
 471   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_LO, 0x00);//Addr = 0x9C27; *Addr = 0x00;
 472   2                  if (IsTMDSLBR(phyindex) == TRUE) {
 473   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC2);//Addr = 0x9C20; *Addr = 0xC2;
 474   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x1E);//Addr = 0x9C21; *Addr = 0x1E;
 475   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 476   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 477   3                  }
 478   2                  else {
 479   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC0);//Addr = 0x9C20; *Addr = 0xC0;
 480   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x1E);//Addr = 0x9C21; *Addr = 0x1E;
 481   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 482   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 483   3                  }
 484   2                  SC_DVI_PLL_M = 0x30;// 0xb18
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 9   

 485   2                  clock = (clock * 8 + 6) / 12;
 486   2                  break;
 487   2              case 7://16 bit
 488   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_DIV, 0x00);//Addr = 0x9C24; *Addr = 0x00;
 489   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_HI, 0x00);//Addr = 0x9C25; *Addr = 0x00;
 490   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_MI, 0x00);//Addr = 0x9C26; *Addr = 0x00;
 491   2                  SC_SetByteDPppPHY(phyindex, _DPPHY_FA2_FREQ_LO, 0x00);//Addr = 0x9C27; *Addr = 0x00;
 492   2                  if (IsTMDSLBR(phyindex) == TRUE) {
 493   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC6);//Addr = 0x9C20; *Addr = 0xC6;
 494   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x14);//Addr = 0x9C21; *Addr = 0x14;
 495   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 496   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 497   3                  }
 498   2                  else {
 499   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_DIV, 0xC4);//Addr = 0x9C20; *Addr = 0xC4;
 500   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_HI, 0x14);//Addr = 0x9C21; *Addr = 0x14;
 501   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 502   3                      SC_SetByteDPppPHY(phyindex, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 503   3                  }
 504   2                  SC_DVI_PLL_M = 0x40;// 0xb18
 505   2                  clock = (clock * 8 + 8) / 16;
 506   2                  break;
 507   2          }
 508   1          return clock;
 509   1      }
 510          
 511          /**************************************************************************//**
 512           * Function to enable/disable detecting HDMI preamble.
 513           * @param enable TRUE/FALSE to enable/disable preamble detection.
 514           ******************************************************************************/
 515          void HDMIEnablePreambleDetection(UCHAR enable)
 516          {
 517   1          if (enable) {
 518   2              SC_HDMI_PREAMBLE_CYCLE = 0x06;
 519   2          }
 520   1          else {
 521   2              SC_HDMI_PREAMBLE_CYCLE = 0x09;
 522   2          }
 523   1      }
 524          
 525          /**************************************************************************//**
 526           * Function to enable/disable auto HDMI video configuration by scaler.
 527           * @param enable TRUE/FALSE to enable/disable AVC.
 528           ******************************************************************************/
 529          void HDMIEnableAVC(UCHAR enable)
 530          {
 531   1          if (enable) {
 532   2              SC_HDMI_AUTO_CTRL |= BIT2;// 0x6b5
 533   2          }
 534   1          else {
 535   2              SC_HDMI_AUTO_CTRL &= ~BIT2;// 0x6b5
 536   2          }
 537   1      }
 538          
 539          /**************************************************************************//**
 540           * Soft reset HDMI-related circuits.
 541           ******************************************************************************/
 542          void HDMISoftReset(void)
 543          {
 544   1          // After this soft reset, please make sure there is delay timing befure turn on system interrupt
 545   1          SC_HDMI_SOFTWARE_RESET |= BIT0;
 546   1          SC_HDMI_SOFTWARE_RESET &= ~BIT0;
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 10  

 547   1      }
 548          
 549          /**************************************************************************//**
 550           * Set HDMI analog audio gain.
 551           * @param value The range is from 0x00 to 0xC6.
 552           ******************************************************************************/
 553          static void ConfigHDMIAnalogAudioGain(UCHAR value)
 554          {
 555   1          SC_AUDIO_VOLUME_R = value;
 556   1          SC_AUDIO_VOLUME_L = value;
 557   1      }
 558          
 559          /**************************************************************************//**
 560           * Set HDMI digital audio gain
 561           * @param value The range is from 0x0000 to 0xFFFF.
 562           ******************************************************************************/
 563          static void ConfigHDMIDigitalAudioGain(USHRT value)
 564          {
 565   1          WriteShortScaler(&SC_DIG_AUDIO_GAIN_L_LO, value);
 566   1          WriteShortScaler(&SC_DIG_AUDIO_GAIN_R_LO, value);
 567   1      }
 568          
 569          /**************************************************************************//**
 570           * Control the volume of scaler audio output.
 571           * @param value The range is from 0 to HDMI_AUDIO_VOL_INF_RANGE.
 572           ******************************************************************************/
 573          void ConfigScalerAudio(USHRT value)
 574          {
 575   1      #ifndef HDMI_AUDIO_VOLUME_RANGE
              #define HDMI_AUDIO_VOLUME_RANGE    1023
              #endif
 578   1      
 579   1      #define VOL_STEP 8
 580   1      
 581   1          SC_AUDIO_SMOOTH = 0xFF;
 582   1      
 583   1          if (value > HDMI_AUDIO_VOLUME_RANGE) {
 584   2              ConfigHDMIAnalogAudioGain(DEF_HDMI_ANA_VOL);
 585   2              ConfigHDMIDigitalAudioGain(DEF_HDMI_DIG_VOL);
 586   2              return;
 587   2          }
 588   1      
 589   1          if ((SC_AUDIO_SELECT & 0x20) != 0) { //PCM
 590   2              USHRT startvol, endvol, vol;
 591   2              startvol = ReadShortScaler(&SC_DIG_AUDIO_GAIN_L_LO);
 592   2      //        endvol = (ULONG)value * 0xFFFE / HDMI_AUDIO_VOLUME_RANGE + 1;
 593   2              endvol = (ULONG)value * 0x7FFF / HDMI_AUDIO_VOLUME_RANGE + 1;//range 1 ~ 0x8000
 594   2              ConfigHDMIAnalogAudioGain(DEF_HDMI_ANA_VOL);
 595   2              if (endvol > 0x6000) {
 596   3                  SC_AUDIO_DELTA_SIGMA_CTRL &= ~BIT4;
 597   3              }
 598   2              else {
 599   3                  SC_AUDIO_DELTA_SIGMA_CTRL |= BIT4;
 600   3              }
 601   2              if (startvol > endvol) {
 602   3                  for (vol=startvol; vol>endvol; vol-=VOL_STEP) {
 603   4                      ResetWDTimer();
 604   4                      ConfigHDMIDigitalAudioGain(vol);
 605   4                      if ((vol - endvol) < VOL_STEP) {
 606   5                          break;
 607   5                      }
 608   4                  }
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 11  

 609   3              }
 610   2              else {
 611   3                  for (vol=startvol; vol<endvol; vol+=VOL_STEP) {
 612   4                      ResetWDTimer();
 613   4                      ConfigHDMIDigitalAudioGain(vol);
 614   4                      if ((endvol - vol) < VOL_STEP) {
 615   5                          break;
 616   5                      }
 617   4                  }
 618   3              }
 619   2              ConfigHDMIDigitalAudioGain(endvol);
 620   2          }
 621   1          else {
 622   2              value = HDMI_AUDIO_VOLUME_RANGE - value;
 623   2              value = (ULONG)value * 0xC6 / HDMI_AUDIO_VOLUME_RANGE;
 624   2              ConfigHDMIAnalogAudioGain(value);
 625   2          }
 626   1      
 627   1      #undef VOL_STEP
 628   1      }
 629          /**************************************************************************//**
 630           * Turn off scaler analog audio power.
 631           ******************************************************************************/
 632          void ScalerAudioPowerOff(void)
 633          {
 634   1      //    SC_AUDIO_OUT_CTRL &= ~BIT0;
 635   1      //    SC_AUDIO_ANALOG_OUT_CTRL = 0x00;
 636   1      }
 637          
 638          /**************************************************************************//**
 639           * Turn on scaler analog audio power.
 640           ******************************************************************************/
 641          void ScalerAudioPowerOn(void)
 642          {
 643   1      //    SC_AUDIO_OUT_CTRL = AUDIO_OUT_CTRL | BIT1;
 644   1      //    SC_AUDIO_ANALOG_OUT_CTRL = 0xFC;
 645   1      }
 646          
 647          void ScalerAudioPreMute(void)
 648          {
 649   1      #if ENABLE_SCALER_AUDIO == ON
 650   1          SC_AUDIO_SMOOTH = 0x81;
 651   1          SC_AUDIO_VOLUME_R = 0xC6;
 652   1          SC_AUDIO_VOLUME_L = 0xC6;
 653   1          usTimerANAMute = GetTimerTick();
 654   1      #endif
 655   1      }
 656          /**************************************************************************//**
 657           * Select audio in/output channel.
 658           * @param ch Input/output audio channel.
 659           ******************************************************************************/
 660          void ScalerAudioSelect(AudioInOutChannel ch)
 661          {
 662   1          // Select audio input channel
 663   1          switch(ch & AUDIO_IN_CH_MASK) {
 664   2              case AUDIO_IN_LINE1:
 665   2              #if ENABLE_HDMI_AUDIO_AUTO_MUTE == ON
                          SC_AUDIO_AUTO_CTRL1 = 0x00; // 0x8a7
                      #endif
 668   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xCF);
 669   2                  SC_AUDIO_AUTO_CTRL_8B0 = 0x00;
 670   2                  SC_AUDIO_AUTO_CTRL_8B3 = 0x01;
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 12  

 671   2                  SC_AUDIO_DELTA_SIGMA_CTRL &= ~(BIT6 | BIT5);
 672   2                  break;
 673   2              case AUDIO_IN_LINE2:
 674   2              #if ENABLE_HDMI_AUDIO_AUTO_MUTE == ON
                          SC_AUDIO_AUTO_CTRL1 = 0x00;
                      #endif
 677   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xCF) | BIT4;
 678   2                  SC_AUDIO_AUTO_CTRL_8B0 = 0x00;
 679   2                  SC_AUDIO_AUTO_CTRL_8B3 = 0x01;
 680   2                  SC_AUDIO_DELTA_SIGMA_CTRL &= ~(BIT6 | BIT5);
 681   2                  break;
 682   2              case AUDIO_IN_DSD:
 683   2              #if ENABLE_HDMI_AUDIO_AUTO_MUTE == ON
                          SC_AUDIO_AUTO_CTRL1 = 0x03;
                      #endif
 686   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xCF) | BIT5 | BIT4;
 687   2                  SC_AUDIO_AUTO_CTRL_8B0 = 0x00;
 688   2                  SC_AUDIO_AUTO_CTRL_8B3 = 0x01;
 689   2                  SC_AUDIO_DELTA_SIGMA_CTRL &= ~(BIT6 | BIT5);
 690   2                  break;
 691   2              default : // AUDIO_IN_HDMI
 692   2              #if ENABLE_HDMI_AUDIO_AUTO_MUTE == ON
                          SC_AUDIO_AUTO_CTRL1 = 0x03;
                      #endif
 695   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xCF) | BIT5;  // 0x71a
 696   2                  SC_AUDIO_AUTO_CTRL_8B0 = 0x30;  // 0x8b0
 697   2                  SC_AUDIO_AUTO_CTRL_8B3 = 0x01;//0xFF;
 698   2                  SC_AUDIO_DELTA_SIGMA_CTRL |= (BIT6 | BIT5); // 0x71d
 699   2              SC_DP_AUDIO_FIFO_CTRL |= BIT6;// 0x1050   
 700   2              SC_HDMI_MUTE |= BIT1;  // 0x737
 701   2              usAudioMuteDelay = HDMI_AUDIODELAY;
 702   2                  break;
 703   2          }
 704   1      
 705   1          // Select audio output channel
 706   1          switch(ch & AUDIO_OUT_CH_MASK) {
 707   2              case AUDIO_OUT_DISABLE:
 708   2                  SC_AUDIO_SELECT = SC_AUDIO_SELECT | BIT3 | BIT2;
 709   2                  break;
 710   2              case AUDIO_OUT_IIS:
 711   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xF3) | BIT2;
 712   2                  break;
 713   2              case AUDIO_OUT_DSD:
 714   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xF3) | BIT3;
 715   2                  break;
 716   2              default : // AUDIO_OUT_LINEOUT
 717   2                  SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xF3);  // 0x71a
 718   2                  break;
 719   2          }
 720   1          // Enable external cap for improving audio performance
 721   1          SC_AUDIO_DAC_DRIV_CTRL = 0xCC; //test by Rex 0x00        0x719
 722   1          SC_AUDIO_ANALOG_OUT_CTRL = 0xFC;//[P3]vcm run   // 0x724
 723   1      }
 724          /**************************************************************************//**
 725           * Turn on internal audio pattern with specific frequency.
 726           * @param freq Audio frequency.
 727           ******************************************************************************/
 728          #if ENABLE_INTERNAL_AUDIO_BUZZER == ON
              void EnableVCSAudioBuzzer(USHRT freq)
              {
                  ULONG ratio;
                  ULONG cts_value, n_value;
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 13  

              
                  if ((SC_AUDIO_DELTA_SIGMA_CTRL & BIT0) != 0) {
                      // Internal audio pattern has been turned on.
                      return;
                  }
              
                  if (((GetCurrInputInterface() == DIGITAL_INPUT0)
                          || (GetCurrInputInterface() == DIGITAL_INPUT1)) && IsHDMI()) {
                      n_value = (float) freq * 4096 / 1000;
                      Write3ByteScaler(&SC_ACR_N_VALUE_LO, n_value); //Write 0x703~0x705
                      cts_value = ReadShortScaler(&SC_VIDEO_HTOTAL_LO) & 0x1FFF;
                      cts_value = cts_value * usHSyncFreq / 10; // cts_value = Input clock /1000
                      Write3ByteScaler(&SC_ACR_CTS_VALUE_LO, cts_value); //Write 0x709~0x70B
                      ucReg0x8700 = SC_ACR_CTRL;
                      SC_ACR_CTRL = 0x18; // User software N, CTS value
                  }
                  else {
                      ratio = (float) freq * 16384 * 131072 / REF_CLK;
                      Write3ByteScaler(&SC_VCLK_RATIO_LO, ratio);
                      SC_HPLL_FREQ_CTRL &= ~BIT4;// 0xd1
                  }
                  ucReg0x8605 = SC_HDMI_SOFTWARE_RESET;
                  ucReg0x871A = SC_AUDIO_SELECT;
                  ucReg0x871D = SC_AUDIO_DELTA_SIGMA_CTRL;
                  SC_HDMI_SOFTWARE_RESET = 0x00;
                  SC_AUDIO_SELECT = 0x20;
                  SC_AUDIO_DELTA_SIGMA_CTRL = 0x15;
              }
              
              /**************************************************************************//**
               * Turn off internal audio pattern.
               ******************************************************************************/
              void DisableVCSAudioBuzzer(void)
              {
                  if (((GetCurrInputInterface() == DIGITAL_INPUT0)
                          || (GetCurrInputInterface() == DIGITAL_INPUT1)) && IsHDMI()) {
                      SC_ACR_CTRL = ucReg0x8700; // Recover to hardware N, CTS value
                  }
                  else {
                      SC_HPLL_FREQ_CTRL |= BIT4;// 0xd1
                  }
                  SC_HDMI_SOFTWARE_RESET = ucReg0x8605;
                  SC_AUDIO_SELECT = ucReg0x871A;
                  SC_AUDIO_DELTA_SIGMA_CTRL = ucReg0x871D;
              }
              #endif
 779          
 780          /**************************************************************************//**
 781           * Check the current input is HDMI or not.
 782           * @return TRUE if input is HDMI else FALSE.
 783           ******************************************************************************/
 784          BOOL IsHDMI(void)
 785          {
 786   1          if ((SC_HDMI_DET & BIT1) != 0) {// 0x734
 787   2              return TRUE;
 788   2          }
 789   1          else {
 790   2              return FALSE;
 791   2          }
 792   1      }
 793          
 794          /**************************************************************************//**
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 14  

 795           * Check the current input is HDMI video timing or not.
 796           * @return TRUE if input is HDMI video timing else FALSE.
 797           ******************************************************************************/
 798          BOOL IsHDMIVideo(void)
 799          {
 800   1          if (((SC_HDMI_DET & BIT1) != 0) && (SC_HDMI_AVI_TYPE == 0x82) && ((SC_HDMI_AVI[0] & 0x60) != 0)) {//HD
             -MI & YUV color// 0x734
 801   2              return TRUE;
 802   2          }
 803   1          else {
 804   2              return FALSE;
 805   2          }
 806   1      }
 807          
 808          #if ENABLE_HDMI_AUDIO_CK_RCVY == ON 
              /**************************************************************************//**
               * Function of recovering HDMI audio clock.
               ******************************************************************************/
              static void HDMIAudioACRCorrection(void)
              {   
                  static code ACRItm ulNCTSSVALTable[NUM_AUDIOFSTYPE][NUM_HDMICLKTYPE] = 
                  {
                    {// Audio FS = 44.1KHz
                          {6272,        28000}, // HDMI_25MHz
                          {7007,        31250}, // HDMI_25MHz_101
                          {6272,        30030}, // HDMI_27MHz
                          {6272,        30000}, // HDMI_27MHz_101
                          {6272,        60060}, // HDMI_54MHz
                          {6272,        60000}, // HDMI_54MHz_101
                          {0x001880, 0x014244}, // HDMI_74MHz
                          {0x0045AC, 0x039387}, // HDMI_74MHz_101
                          {6272,       165000}, // HDMI_148MHz
                          {8918,       234375}, // HDMI_148MHz_101
                          {4704,       247500}, // HDMI_297MHz
                          {4459,       234375}, // HDMI_297MHz_101
                      },
                      {// Audio FS = Not indicated
                          {6272,        28000}, // HDMI_25MHz
                          {7007,        31250}, // HDMI_25MHz_101
                          {6272,        30030}, // HDMI_27MHz
                          {6272,        30000}, // HDMI_27MHz_101
                          {6272,        60060}, // HDMI_54MHz
                          {6272,        60000}, // HDMI_54MHz_101
                          {0x001880, 0x014244}, // HDMI_74MHz
                          {0x0045AC, 0x039387}, // HDMI_74MHz_101
                          {6272,       165000}, // HDMI_148MHz
                          {8918,       234375}, // HDMI_148MHz_101
                          {4704,       247500}, // HDMI_297MHz
                          {4459,       234375}, // HDMI_297MHz_101
                      },
                      {// Audio FS = 48KHz
                          {6144,        25200}, // HDMI_25MHz
                          {6864,        28125}, // HDMI_25MHz_101
                          {6144,        27027}, // HDMI_27MHz
                          {6144,        27000}, // HDMI_27MHz_101
                          {6144,        54054}, // HDMI_54MHz
                          {6144,        54000}, // HDMI_54MHz_101
                          {6144,        74250}, // HDMI_74MHz
                          {11648,      140625}, // HDMI_74MHz_101
                          {6144,       148500}, // HDMI_148MHz
                          {5824,       140625}, // HDMI_148MHz_101
                          {5120,       247500}, // HDMI_297MHz
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 15  

                          {5824,       281250}, // HDMI_297MHz_101
                      },
                  };
                  UCHAR fs, ch, type = 0xFF;
                  USHRT pixelclock;
                  ULONG n_hval, cts_hval;
              
                  SC_VPLL_CTRL |= BIT2; // Audio FIFO Auto Balance// 0xb19
                  
                  ch = SC_HDMI_INT_STATE1[4];
                  fs = SC_AUDIO_IN_SPDIF_STATE4 & 0x0F;
                  pixelclock = TMDS_GetClock();//DVI pixel clock
                  n_hval = Read3ByteScaler(&SC_ACR_N_HVAL[0]) & 0x0FFFFF;
                  cts_hval = Read3ByteScaler(&SC_ACR_CTS_HVAL[0]) & 0x0FFFFF;
                  if (pixelclock <= 0x0019) {//25MHz
                      type = 0;
                  }
                  else if (pixelclock < 0x0028) {//40MHz
                      type = 1;
                  }
                  else if (pixelclock < 0x0040) {//64MHz
                      type = 2;
                  }
                  else if (pixelclock < 0x006F) {//111MHz
                      type = 3;
                  }
                  else if (pixelclock < 0x00DE) {//222MHz
                      type = 4;
                  }
                  else if (pixelclock < 0x0130) {//304MHz
                      type = 5;
                  }
              //pixelclock > 304MHz, audio != 44k, 48k. software reset and return
                  if ((type == 0xFF) || (fs >= NUM_AUDIOFSTYPE) || (fs == AUDIOFS_NOTINDICATED)) {
                      if (SC_ACR_CTRL != 0x00) {
                          SC_ACR_CTRL = 0x00;
                          Sleep(60);
                          SC_HDMI_SOFTWARE_RESET |= BIT1;
                          SC_HDMI_SOFTWARE_RESET &= ~BIT1;
                          Sleep(5);
                          SC_HDMI_INT_STATE1[4] = ch;
                      }
                      return;
                  }
              //pixelclock < 304MHz, audio == 44k, 48k
                  type *= 2;
                  if (((labs(n_hval - ulNCTSSVALTable[fs][type].ulNSVAL) > 100) && (labs(n_hval - ulNCTSSVALTable[fs][ty
             -pe+1].ulNSVAL) > 100)) 
                  || ((labs(cts_hval - ulNCTSSVALTable[fs][type].ulCTSSVAL) > 1000) && (labs(cts_hval - ulNCTSSVALTable[
             -fs][type+1].ulCTSSVAL) > 1000))) {
                      if ((SC_ACR_CTRL & 0x18) == 0x00) { //hardware-determined: auto
                          // N-CTS Value Type 1
                          Write3ByteScaler(&SC_ACR_N_VALUE_LO, ulNCTSSVALTable[fs][type].ulNSVAL);
                          Write3ByteScaler(&SC_ACR_CTS_VALUE_LO, ulNCTSSVALTable[fs][type].ulCTSSVAL);
                          SC_ACR_CTRL = 0x19; //software-determined: manual
                          Sleep(60);
                          SC_HDMI_SOFTWARE_RESET |= BIT1;
                          SC_HDMI_SOFTWARE_RESET &= ~BIT1;
                          Sleep(5);
              
                          SC_HDMI_INT_STATE1[4] = ch;
                          
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 16  

                          ch = SC_HDMI_INT_STATE1[4];
                          if ((ch & BIT1) != 0) { // N-CTS Format Type 2. FIFO over run
                              Write3ByteScaler(&SC_ACR_N_VALUE_LO, ulNCTSSVALTable[fs][type+1].ulNSVAL);
                              Write3ByteScaler(&SC_ACR_CTS_VALUE_LO, ulNCTSSVALTable[fs][type+1].ulCTSSVAL);
                              SC_ACR_CTRL = 0x19; //software-determined: manual
                              Sleep(60);
                              SC_HDMI_SOFTWARE_RESET |= BIT1;
                              SC_HDMI_SOFTWARE_RESET &= ~BIT1;
                              Sleep(5);
              
                              SC_HDMI_INT_STATE1[4] = ch;
                          }
                      }
                  }
                  else {
                      if (SC_ACR_CTRL != 0x00) { //no error change to hardware-determined
                          SC_ACR_CTRL = 0x00;
                          Sleep(60);
                          SC_HDMI_SOFTWARE_RESET |= BIT1;
                          SC_HDMI_SOFTWARE_RESET &= ~BIT1;
                          Sleep(5);
              
                          SC_HDMI_INT_STATE1[4] = ch;
                      }
                  }
              }
              #endif
 943          
 944          /**************************************************************************//**
 945           * Function to validate the audio clock.
 946           * If the CTS/N of current HDMI input does not match with audio sampling rate in
 947           * the info-frame, the system audio will be muted.
 948           ******************************************************************************/
 949          #if ENABLE_HDMI_FS_MUTE == ON 
              void HDMIAPI_MuteUnmatchedFs(void)
              {
                  code USHRT FsTable[][2] = {
                      {0x0000,   441},
                      {0x0008,   882},
                      {0x000C,  1764},
                      {0x0002,   480},
                      {0x000A,   960},
                      {0x000E,  1920},
                      {0x0003,   320}
                  };
              
                  UCHAR i;
                  ULONG tmp_cts, tmp_n;
                  USHRT clk, fs;
              
                  for (i = 0; i < sizeof(FsTable)/sizeof(USHRT)/2 ; i++) {
                      if (FsTable[i][0] == (SC_AUDIO_HW_EXT_FS & 0x0F)) {
                          break;
                      }
                  }
              
                  if (i >= sizeof(FsTable)/sizeof(USHRT)/2) {
                      return;
                  }
              
                  tmp_n = Read3ByteScaler(&SC_ACR_N_HVAL[0]) & 0x0FFFFF;
                  tmp_cts = Read3ByteScaler(&SC_ACR_CTS_HVAL[0]) & 0x0FFFFF;
C51 COMPILER V9.54   SCALER_HDMI                                                           01/06/2017 14:56:47 PAGE 17  

                  if ((tmp_n == 0) || (tmp_cts == 0)) {
                      return;
                  }
                  clk = TMDS_GetClock();
                  fs = (USHRT)((float)clk * 10000 * tmp_n / tmp_cts / 128);
              
                  // We define the tolerance of fs and CTS/N less then 10KHz
                  // If the tolerance is larger than 10K, we mute the audio.
                  // Jude 2011/08/27
                  if (abs(fs - FsTable[i][1]) > 100) {
                  #if ENABLE_INTERNAL_AUDIO_BUZZER == ON
                      SC_AUDIO_SELECT |= 0x0C;
                  #else
                      SC_AUDIO_DELTA_SIGMA_CTRL = 0x01;
                  #endif
                      SetGlobalTimer(GLOBAL_TMR_HDMI_FS_MUTE, 500);
                  }
                  else if (GetGlobalTimer(GLOBAL_TMR_HDMI_FS_MUTE) == 0) {
                  #if ENABLE_INTERNAL_AUDIO_BUZZER == ON
                      SC_AUDIO_SELECT = (SC_AUDIO_SELECT & 0xF3) | AUDIO_PINOUT_SEL;;
                  #else
                      SC_AUDIO_DELTA_SIGMA_CTRL = 0x00;
                  #endif
                  }
              }
              #endif
1004          
1005          #endif //ENABLE_HDMI == ON


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1728    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
