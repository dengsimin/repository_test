C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCALER_TMDS
OBJECT MODULE PLACED IN .\Bin\Scaler_TMDS.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Lib\NT68810 Series\Scaler_TMDS.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.
                    -\App;.\App\OSD;.\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Compone
                    -nt;.\Phy\SI\NVT\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT68870_
                    -MODULE,LVIEW_2560X1440,FLASH_BANK=8) PRINT(.\Lst\Scaler_TMDS.lst) TABS(2) OBJECT(.\Bin\Scaler_TMDS.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          #include "ScalerProfile.h"
  14          #include "Scaler_TMDS_6502.h"
  15          
  16          //******************************************************************************
  17          // M A C R O   D E F I N I T I O N S
  18          //******************************************************************************
  19          //#define TMDS4K2K_TEST
  20          //#define FORCE_SCRAMBLE_ON
  21          //#define ENABLE_HF_TMDS_AUTOEQ
  22          #define TMDSEQ_CHECK_ERROR_CNT_DELAY  50
  23          typedef struct _TMDS_EQ_Setting{
  24              ULONG ulBestErrCnt;
  25              UCHAR ucCurrentSearchLevel : 2;
  26              UCHAR ucBestLevel : 2;
  27              UCHAR bIsFinish : 1;
  28          }TMDS_EQ_Setting;
  29          
  30          //******************************************************************************
  31          // G L O B A L   V A R I A B L E S
  32          //******************************************************************************
  33          #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == OFF
  34          static bit bTMDSClockTraining;
  35          static USHRT usTMDSTrainingTimer;
  36          #endif
  37          //******************************************************************************
  38          // S T A T I C   V A R I A B L E S
  39          //******************************************************************************
  40          static BOOL bIsDualLink = 0; /*!< Flag of dual-link present. */
  41          static UCHAR ucTMDSInputMode;
  42          
  43          static TMDS_EQ_Setting stEQSet;
  44          static USHRT usTMDSCheckErrorCntTimer;
  45          //******************************************************************************
  46          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  47          //******************************************************************************
  48          extern xdata ULONG ulHFreqCounter;
  49          
  50          //******************************************************************************
  51          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  52          //******************************************************************************
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 2   

  53          //static void TMDSInitPhy(UCHAR phyindex);
  54          //static void TMDSInitIIC(void);
  55          static UCHAR GetTMDSPHYDATA(UCHAR phylink, USHRT address);
  56          static void TMDS_EQSet_FlowReset(void);
  57          static void TMDS_EQSet_EQSetting(UCHAR linkidx, UCHAR level);
  58          static void TMDS_EQSet_ErrCntInit(UCHAR phyindex);
  59          
  60          //******************************************************************************
  61          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  62          //******************************************************************************
  63          
  64          //******************************************************************************
  65          // F U N C T I O N   B O D Y S
  66          //******************************************************************************
  67          
  68          /**************************************************************************//**
  69           * Initialize TMDS-related registers.
  70           ******************************************************************************/
  71          void TMDSInit(UCHAR phyindex)
  72          {
  73   1          TMDSInitPhy(phyindex);
  74   1          //TMDSInitIIC();
  75   1          DVI_PowerOn();
  76   1          SC_HDCP_CTRL = SCREG_643;
  77   1          SC_DVI_PLL_M = 0x20;// 0xb18
  78   1          
  79   1      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == OFF
  80   1          ClearTMDSTraining();
  81   1      #endif
  82   1      }
  83          
  84          void TMDS_EnableCKDT(UCHAR phyindex)
  85          {
  86   1      #ifdef TMDS4K2K_TEST
                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x36);//Addr = 0x9C00; *Addr = 0x16;//0x1C00= 0x16
              #else
  89   1          SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x06);//Addr = 0x9C00; *Addr = 0x06;//0x1C00= 0x06
  90   1      #endif
  91   1        SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_IMP_ENABLE, 0xFE);//Addr = 0x9C02; *Addr = 0xFE;//0x1C02= 0xFE
  92   1      }
  93          
  94          /**************************************************************************//**
  95           * Detect current input signal quality and set proper impedance.
  96           ******************************************************************************/
  97          void TMDSInitPhy(UCHAR phyindex)
  98          {
  99   1          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, 0x2F);
 100   1          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_POLARITY, 0x00);//WriteScaler(0x1AD5, 0x00);  // PN swap
 101   1      #ifdef TMDS4K2K_TEST
                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x36);//Addr = 0x9C00; *Addr = 0x16;//0x1C00= 0x16
              #else
 104   1          SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x06);//Addr = 0x9C00; *Addr = 0x06;//0x1C00= 0x06
 105   1      #endif
 106   1          SC_SetByteDPppPHY(phyindex, _DPPHY_ICTRL, 0x00);//Addr = 0x9C01; *Addr = 0x00;//0x1C01= 0x00
 107   1      #if IS_NT68810_SERIES
                  SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_IMP_ENABLE, 0xFE);//Addr = 0x9C02; *Addr = 0xFE;//0x1C02= 0xFE
              #else
 110   1        SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_IMP_ENABLE, 0xFE);//Addr = 0x9C02; *Addr = 0xFE;//0x1C02= 0xFE
 111   1        SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_MODE_SELECT, 0x04);      
 112   1      #endif
 113   1          SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_RES_CTRL3, 0xF0);  
 114   1          SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L0_L2_L3, 0x18);//Addr = 0x9C03; *Addr = 0x18;//0x1C03= 0
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 3   

             -x18
 115   1          SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L1, 0x18);//Addr = 0x9C04; *Addr = 0x18;//0x1C04= 0x18
 116   1          SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_POWER, 0xA0);//Addr = 0x9C1C; *Addr = 0xA0;//0x1C1C= 0xA0
 117   1          SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_LDO, 0x02);//Addr = 0x9C1D; *Addr = 0x02;//0x1C1D= 0x02
 118   1      #if IS_NT68810_SERIES  
                  SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_R12K, 0x0F);//Addr = 0x9C1E; *Addr = 0x03;//0x06;//0x1C1E= 0x0
             -6
              #else //NT68870
 121   1      #if ENABLE_HDCP_TRIM_MODE == ON
 122   1          if (ucLEDTRIM_LO == 0) {
 123   2              SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_R12K, 0x10);//Addr = 0x9C1E; *Addr = 0x03;//0x06;//0x1C1E=
             - 0x06
 124   2          }
 125   1          else {
 126   2              SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_R12K, ucLEDTRIM_LO);//Addr = 0x9C1E; *Addr = 0x03;//0x06;/
             -/0x1C1E= 0x06
 127   2          }
 128   1      #else
                  SC_SetByteDPppPHY(phyindex, _DPPHY_BIAS_R12K, 0x10);//Addr = 0x9C1E; *Addr = 0x03;//0x06;//0x1C1E= 0x0
             -6
              #endif
 131   1      #endif
 132   1          SC_SetByteDPppPHY(phyindex, _DPPHY_IBIAS_SEL, 0x0F);//Addr = 0x9C1F; *Addr = 0x0F;//0x1C1F= 0x0F
 133   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x11);//Addr = 0x9B42; *Addr = 0x11;//dp_rxanaif_aeq_
             -cfg2
 134   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x0F);//Addr = 0x9B49; *Addr = 0x0F;//dp_rxanaif_aeq_
             -cfg3
 135   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0xFF);
 136   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0x03);
 137   1      //    SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0F);//1AD2
 138   1      //    SC_SetByteDPppPHY(phyindex, _DPRP_STATUS, 0x00);//CDR on, 6502
 139   1      
 140   1          SC_SetByteDPppPHY(phyindex, _DPPHY_LDO_CTRL, 0x62);
 141   1      
 142   1      #if 1//!((INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPU
             -T_INTERFACE&INPUT_DP3))
 143   1          SC_SetBitDPppPHY(phyindex, _DPRP_REG_1FD, (BIT6|BIT5), FALSE);
 144   1      #endif
 145   1      
 146   1      #if ENABLE_TMDS_EQ_SEARCH_FLOW == ON
 147   1          stEQSet.bIsFinish = TRUE;
 148   1      #endif
 149   1      }
 150          
 151          /*
 152          static void TMDSInitIIC(void)
 153          {
 154              UCHAR volatile xdata *Addr;
 155              UCHAR reg_value;
 156          
 157              Addr = 0x9BFD; reg_value = *Addr;
 158              Addr = 0x9BFD; *Addr = reg_value & ~(BIT6|BIT5);
 159          }
 160          */
 161          #if !lrd_dis
              void MHLDPppPHYInit(UCHAR phyindex)
              {
                  UCHAR ucTmp;
                
                  SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_82C5, 0x33);   //SC_DPpp_CFG_TMDS_8100[0x1C5] = 0x41;
                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x13);   // SC_DPpp_CFG_TMDS_8100[0x142] = 0x13;
                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x07);     // SC_DPpp_CFG_TMDS_8100[0x149] = 0x07;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 4   

                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0xFF);   // SC_DPpp_CFG_TMDS_8100[0x14A] = 0xFF;
                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0xFF);   // SC_DPpp_CFG_TMDS_8100[0x14B] = 0xFF;
                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x8E);          // SC_DPpp_CFG_TMDS_8100[0x200] = 0x8C;
                  SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_IMP_ENABLE, 0x22); // SC_DPpp_CFG_TMDS_8100[0x202] = 0x22;
                  SC_SetByteDPppPHY(phyindex, _DPPHY_EQR_RES_CTRL3, 0x20);
              
                  ucTmp = GetTMDSPHYDATA(phyindex, _DPHY_CBUS_LDO_CTRL);
                  ucTmp &= 0x0F;
                  ucTmp |= BIT5;
                  SC_SetByteDPppPHY(phyindex,_DPHY_CBUS_LDO_CTRL, ucTmp);
              }
              #endif
 181          
 182          /**************************************************************************//**
 183           * Detect the TMDS clock is stable or not.
 184           * @return TRUE if clock is stable else FALSE.
 185           ******************************************************************************/
 186          BOOL TMDSClockStable(void)
 187          {
 188   1          USHRT pre_clock, stable_timer, unstable_timer;
 189   1      
 190   1          pre_clock = TMDS_GetClock();
 191   1          stable_timer = GetTimerTick();
 192   1          unstable_timer = stable_timer;
 193   1      
 194   1          //Wait the TMDS clock to be stable for 150 ms or unstable for 300 ms
 195   1          while ((GetTimerTick()-unstable_timer) < 300) {
 196   2              if ((SC_HDMI_CKDT & 0x03) != 0x03) {  // 0x606
 197   3                  return FALSE;
 198   3              }
 199   2              if (abs(pre_clock - TMDS_GetClock()) > 2) {
 200   3                  pre_clock = TMDS_GetClock();
 201   3                  stable_timer = GetTimerTick();
 202   3              }
 203   2              if ((GetTimerTick() - stable_timer) > 150) {
 204   3                  return TRUE;
 205   3              }
 206   2              ResetWDTimer();
 207   2          }
 208   1      
 209   1          return FALSE;
 210   1      }
 211          
 212          /**************************************************************************//**
 213           * According to the TMDS clock, we set some specific registers to get more signal qualities.
 214           * We reset TMDS phase detection only when clock is stable.
 215           * @param reset TRUE to reset TMDS phase detection else FALSE.
 216           ******************************************************************************/
 217          void TMDSBandwidthDetection(UCHAR reset)
 218          {
 219   1          reset = 0;
 220   1      }
 221          
 222          /**************************************************************************//**
 223           * Get digital input HDE pixel count.
 224           * Before system invoke this function, the input VSync frequency must be determined.
 225           * This value is determined by the capture block not TMDS block.
 226           * @return Digital input HDE.
 227           ******************************************************************************/
 228          USHRT GetDigInputHActive(void)
 229          {
 230   1      #if 0
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 5   

                  return ReadShortScaler(&SC_DVI_CAP_HWID_LO);
              #else
 233   1          UCHAR i;
 234   1          USHRT hactive, htemp;
 235   1      
 236   1          htemp = 0;
 237   1          for (i=0; i<5; i++) { //Reg0x03C/Reg0x03D can not be read immediately after 0x6B5[2] was changed
 238   2      #if (INPUT_INTERFACE & INPUT_DP)
 239   2              if ( GetCurrInputInterface() == DISPLAY_PORT_INPUT ) {
 240   3                  hactive = GetDPInputHDEImmediate();
 241   3              }        
 242   2              else
 243   2      #endif
 244   2              {
 245   3                  hactive = ReadShortScaler(&SC_DVI_CAP_HWID_LO);  // 0x3c
 246   3              }
 247   2              if (htemp != hactive) {
 248   3                  htemp = hactive;
 249   3                  DelayVTime(1);
 250   3              }
 251   2              else {
 252   3                  break;
 253   3              }
 254   2          }
 255   1      
 256   1          return hactive;
 257   1      #endif
 258   1      }
 259          
 260          /**************************************************************************//**
 261           * Get digital input VDE line count.
 262           * Before system invoke this function, the input VSync frequency must be determined.
 263           * This value is determined by the capture block not TMDS block.
 264           * @return Digital input VDE.
 265           ******************************************************************************/
 266          USHRT GetDigInputVActive(void)
 267          {
 268   1      #if 0
                  if (IsInterlaced()) {
                      return ReadShortScaler(&SC_DVI_CAP_VLEN_LO) * 2;
                  }
                  else {
                      return ReadShortScaler(&SC_DVI_CAP_VLEN_LO);
                  }
              #else
 276   1          UCHAR i;
 277   1          USHRT vactive, vtemp;
 278   1      
 279   1          vtemp = 0;
 280   1          for (i=0; i<5; i++) {
 281   2              vactive = ReadShortScaler(&SC_DVI_CAP_VLEN_LO); // 0x3e
 282   2              if (vtemp != vactive) {
 283   3                  vtemp = vactive;
 284   3                  DelayVTime(4);
 285   3              }
 286   2              else {
 287   3                  break;
 288   3              }
 289   2          }
 290   1      
 291   1              return vactive;
 292   1      #endif
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 6   

 293   1      }
 294          
 295          /**************************************************************************//**
 296           * Get digital input HDE without any delay.
 297           * This value is determined by the capture block not TMDS block.
 298           * @return Digital input HDE.
 299           ******************************************************************************/
 300          USHRT GetDigInputHActiveImmediate(void)
 301          {
 302   1      #if ENABLE_HDMI == ON
 303   1        #if ENABLE_DVI_DUAL_LINK == ON
 304   1        if (TMDS_IsDualLink())
 305   1        {
 306   2          return ReadShortScalerHighLowFilter(&SC_DVI_CAP_HWID_LO);// 0x3c
 307   2        }   
 308   1        #endif  
 309   1      
 310   1      // Because of inconsistent update issue of high/low bytes, we should read hde/vde with filter.
 311   1          return ReadShortScalerHighLowFilter(&SC_VIDEO_DE_WIDTH_LO);  // 0x64e
 312   1      #else
                  return ReadShortScalerHighLowFilter(&SC_DVI_CAP_HWID_LO);// 0x3c
              #endif
 315   1      }
 316          
 317          /**************************************************************************//**
 318           * Get digital input VDE without any delay.
 319           * This value is determined by the capture block not TMDS block.
 320           * @return Digital input VDE.
 321           ******************************************************************************/
 322          USHRT GetDigInputVActiveImmediate(void)
 323          {
 324   1      #if ENABLE_HDMI == ON
 325   1        #if ENABLE_DVI_DUAL_LINK == ON
 326   1        if (TMDS_IsDualLink())
 327   1        {
 328   2          return ReadShortScalerHighLowFilter(&SC_DVI_CAP_VLEN_LO);// 0x3e
 329   2        }   
 330   1        #endif    
 331   1      
 332   1          // Because of inconsistent update issue of high/low bytes, we should read hde/vde with filter.
 333   1          return ReadShortScalerHighLowFilter(&SC_VIDEO_DE_LINE_LO);  // 0x650
 334   1      #else
                  return ReadShortScalerHighLowFilter(&SC_DVI_CAP_VLEN_LO); // 0x3e
              #endif
 337   1      }
 338          
 339          #if ENABLE_HDMI == ON
 340          /**************************************************************************//**
 341           * Get digital input HTotal without any delay.
 342           * This value is determined by the TMDS block not capture block.
 343           * @return Digital input HTotal.
 344           ******************************************************************************/
 345          USHRT GetDigInputHTotalImmediate(void)
 346          {
 347   1          // Because of inconsistent update issue of high/low bytes, we should read h/vtotal with filter.
 348   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
 349   1          if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT1
             -)
 350   1           || (GetCurrInputInterface() == DISPLAY_PORT_INPUT2) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT
             -3)) {
 351   2              return ReadShortScalerHighLowFilter(&SC_DP_HTOTAL_LO);  // 0x1090
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 7   

 352   2          }
 353   1      #endif
 354   1          return ReadShortScalerHighLowFilter(&SC_VIDEO_HTOTAL_LO);  // 0x63a
 355   1      }
 356          
 357          /**************************************************************************//**
 358           * Get digital input VTotal without any delay.
 359           * This value is determined by the TMDS block not capture block.
 360           * @return Digital input VTotal.
 361           ******************************************************************************/
 362          USHRT GetDigInputVTotalImmediate(void)
 363          {
 364   1          // Because of inconsistent update issue of high/low bytes, we should read h/vtotal with filter.
 365   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
 366   1          if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT1
             -)
 367   1           || (GetCurrInputInterface() == DISPLAY_PORT_INPUT2) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT
             -3)) {
 368   2              return ReadShortScalerHighLowFilter(&SC_DP_VTOTAL_LO);  // 0x1092
 369   2          }
 370   1      #endif
 371   1          return ReadShortScalerHighLowFilter(&SC_VIDEO_VTOTAL_LO);  // 0x63c
 372   1      }
 373          #endif
 374          
 375          /**************************************************************************//**
 376           * Get the count of HSync frequency (from sync processor) of digital timing.
 377           ******************************************************************************/
 378          void SetDVIPLL(void)
 379          {
 380   1          USHRT pixel_rate;
 381   1      
 382   1          SC_HPLL_FREQ_CTRL &= ~BIT6;  // 0xd1
 383   1      
 384   1      #if ENABLE_HDMI == ON
 385   1          TMDSDeepColorDetection();
 386   1      #endif
 387   1      
 388   1          SC_HPLL_LINE_CNT = 0x0B;//0x0C; //4096 line  0xdb
 389   1      
 390   1          pixel_rate = ReadShortScaler(&SC_GI_HCNT_LO) & 0x1FFF;//  0x19b
 391   1          if ((pixel_rate==0x1FFF) || (pixel_rate==0)) {
 392   2              ulHFreqCounter = 0xFFFFFFFF;
 393   2          }
 394   1          else {
 395   2              ulHFreqCounter = (ULONG)pixel_rate * 8192;
 396   2          }
 397   1      }
 398          
 399          /**************************************************************************//**
 400           * Turn off TMDS power.
 401           ******************************************************************************/
 402          void DVI_PowerOff(void)
 403          {
 404   1      #if (INPUT_INTERFACE&INPUT_MHL_MASK)
                  if (IsMHL0Connect() || IsMHL1Connect()) {
                      return;
                  }
              #endif
 409   1      
 410   1          SC_POWER_CTRL2 &= ~BIT1; // 0x102
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 8   

 411   1      }
 412          
 413          /**************************************************************************//**
 414           * Turn on TMDS power.
 415           ******************************************************************************/
 416          void DVI_PowerOn(void)
 417          {
 418   1          SC_POWER_CTRL2 |= (BIT5 | BIT1);// 0x102
 419   1      }
 420          
 421          void AphyPowerOff(bit pd)
 422          {
 423   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPRM_LANE_HI_CFG, 0x0F);//1AD2
 424   1          if (pd == TRUE) {
 425   2      //        SC_SetByteDPppPHY(_DPPP_PHY0, _DPRM_LANE_HI_CFG, 0x0F);
 426   2              SC_SetByteDPppPHY(_DPPP_PHY0, _DP_ANA_CDR_CFG0, 0x10);
 427   2              SC_SetByteDPppPHY(_DPPP_PHY0, _DP_ANA_CDR_CFG6, 0x00);
 428   2              SC_SetByteDPppPHY(_DPPP_PHY0, _DPRP_REG_1FD, 0x00);
 429   2          }
 430   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FCTRL, 0x04);//WriteScaler(0x1C00, 0x04);
 431   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_EQR_IMP_ENABLE, 0x00);//WriteScaler(0x1C02, 0x00);
 432   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_EQR_RES_CTRL3, 0x00);
 433   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_EQR_POS_IOFFSET_L0, 0x00);//WriteScaler(0x1C05, 0x00);
 434   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_BIAS_POWER, 0x00);//WriteScaler(0x1C1C, 0x00);
 435   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_DIV, 0x00);//Addr = 0x9C20; *Addr = 0x00;
 436   1          SC_SetByteDPppPHY(_DPPP_PHY0, _DPRP_STATUS, 0x10);//CDR off
 437   1        SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_LDO_CTRL, 0x00);//NT68810 power
 438   1      #if IS_NT68870_SERIES
 439   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPRM_LANE_HI_CFG, 0x0F);//1AD2
 440   1          if (pd == TRUE) {
 441   2      //        SC_SetByteDPppPHY(_DPPP_PHY1, _DPRM_LANE_HI_CFG, 0x0F);//1AD2
 442   2              SC_SetByteDPppPHY(_DPPP_PHY1, _DP_ANA_CDR_CFG0, 0x10);//1B06
 443   2              SC_SetByteDPppPHY(_DPPP_PHY1, _DP_ANA_CDR_CFG6, 0x00);//1B0D
 444   2              SC_SetByteDPppPHY(_DPPP_PHY1, _DPRP_REG_1FD, 0x00);
 445   2          }
 446   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_FCTRL, 0x04);//WriteScaler(0x1C00, 0x04);
 447   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_EQR_IMP_ENABLE, 0x00);//WriteScaler(0x1C02, 0x00);
 448   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_EQR_POS_IOFFSET_L0, 0x00);//WriteScaler(0x1C05, 0x00);
 449   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_BIAS_POWER, 0x00);//WriteScaler(0x1C1C, 0x00);
 450   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_FA1_DIV, 0x00);//Addr = 0x9C20; *Addr = 0x00;
 451   1          SC_SetByteDPppPHY(_DPPP_PHY1, _DPRP_STATUS, 0x10);//CDR off (with 6502)
 452   1        SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_LDO_CTRL, 0x00);//NT68810 power
 453   1      #endif
 454   1      }
 455          /**************************************************************************//**
 456           * Turn on the termination power of TMDS clock pair for TMDS clock detection.
 457           ******************************************************************************/
 458          void TMDS_EnableSCDT(void)
 459          {
 460   1      
 461   1      }
 462          
 463          #if ENABLE_DVI_DUAL_LINK == ON
 464          /*
 465          USHRT GetDualLinkInputHActive(void)
 466          {
 467              USHRT hactive;
 468              hactive = GetTMDSPHYDATA(_DPPP_PHY0, _TMDS_DPHY_HACTIVE_HI);
 469              hactive <<= 8;
 470              hactive |= GetTMDSPHYDATA(_DPPP_PHY0, _TMDS_DPHY_HACTIVE_LO); 
 471              //printf("hactive=%d\r\n", hactive);
 472              return hactive;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 9   

 473          }
 474          USHRT GetDualLinkInputVActive(void)
 475          {
 476              USHRT vactive;
 477              vactive = GetTMDSPHYDATA(_DPPP_PHY0, _TMDS_DPHY_VACTIVE_HI);
 478              vactive <<= 8;
 479              vactive |= GetTMDSPHYDATA(_DPPP_PHY0, _TMDS_DPHY_VACTIVE_LO); 
 480              //printf("vactive=%d\r\n", vactive);
 481              return vactive;
 482          }
 483          */
 484          /**************************************************************************//**
 485           * Dual link TMDS detection.
 486           * If the current input is dual link TMDS signal, the bIsDualLink will be TRUE,
 487           * else FALSE.
 488           ******************************************************************************/
 489          void TMDS_DualLinkDetection(void)
 490          {
 491   1          USHRT hactive, vactive;
 492   1        UCHAR ucTMDSLinkClkSel, ucTmpOfDviPllM; 
 493   1        BOOL bDualDetection, bSpecialTiming;
 494   1      
 495   1          bIsDualLink = FALSE;
 496   1        bDualDetection = FALSE;
 497   1      //    if (GetTMDSPhyLinkSelect() == DIGITAL_INPUT1 && GetTMDSPHYDATA(_DPPP_PHY0, _HDMI_MHL_INFO)==HDMI_NRM
             - && (SC_HDMI_MHL_MODE_DETECT&BIT7)==0) { //DVI Input
 498   1          if ((GetTMDSPhyLinkSelect() == DIGITAL_INPUT1) && (GetTMDSPHYDATA(_DPPP_PHY0, _HDMI_MHL_INFO) == HDMI_
             -NRM)) { //not MHL Input
 499   2      //        printf("Dual DVI detect 1\r\n");
 500   2          SC_SetBitDPppPHY(_DPPP_PHY1, _DPPHY_LDO_CTRL, BIT7, FALSE);
 501   2          SC_TMDS_PHY_LINK_CTRL_1DE0 &= ~BIT3;  // 0x1de0
 502   2          //Sleep(20);
 503   2          
 504   2          ucTMDSLinkClkSel = SC_TMDS_LINK_CLK_SEL;  // 0x1e7
 505   2          ucTmpOfDviPllM = SC_DVI_PLL_M;    // 0xb18
 506   2          
 507   2              hactive = GetDigInputHActive();//GetDualLinkInputHActive();//
 508   2              vactive = GetDigInputVActive();//GetDualLinkInputVActive();//
 509   2      
 510   2          bSpecialTiming = FALSE;
 511   2          if (hactive==1280 && vactive==1080){
 512   3            bSpecialTiming = TRUE;
 513   3          } 
 514   2              if (((SC_HDMI_MHL_MODE_DETECT & (BIT7|BIT4)) == 0x00)  // 0x630
 515   2                && (SC_HDMI_DET&BIT0)==0x00 && (SC_HDMI_CKDT&BIT0) // 0x734,0x606
 516   2                && ((vactive > hactive) || bSpecialTiming)) { //Dual Link DVI Input //special: 2560x1080p60
 517   3                  //printf("Dual DVI detect 2\r\n");
 518   3      //            TMDSInitPhy(_DPPP_PHY0);
 519   3      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == OFF
 520   3                  TMDSInitPhy(_DPPP_PHY1);    
 521   3            SC_SetBitDPppPHY(_DPPP_PHY1, _DPPHY_LDO_CTRL, BIT7, TRUE);
 522   3      #endif      
 523   3            SC_TMDS_LINK_CLK_SEL = SCREG_1E7 | BIT0 | BIT7;// 0x1e7
 524   3            SC_DVI_PLL_M = 0x20;// 0xb18
 525   3                  SC_TMDS_PHY_LINK_CTRL_1DE1 |= BIT1; // 0x1de1
 526   3            //Sleep(20);
 527   3                        
 528   3                  TMDSDataAlign(_DPPP_PHY0);
 529   3      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == ON
                          SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_EQR_POS_IOFFSET_L2, BIT0);
              #else
 532   3                  ClearTMDSTraining();
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 10  

 533   3                  TMDSClockTraining(_DPPP_PHY0, TRUE);
 534   3      #endif
 535   3                  TMDSDataAlign(_DPPP_PHY1);
 536   3      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == ON
                          SetTMDS6502Active(_DPPP_PHY1);
              //            Sleep(10);
                          SC_SetBitDPppPHY(_DPPP_PHY1, _DPPHY_LDO_CTRL, BIT7, TRUE); //Roger add
                          SC_SetByteDPppPHY(_DPPP_PHY1, _DPPHY_EQR_POS_IOFFSET_L2, BIT0);
                          vactive = 100;
                          while ((GetTMDSPHYDATA(_DPPP_PHY1, _DPPHY_EQR_POS_IOFFSET_L2) != 0x00) && (vactive != 0)) {
                              Sleep(1);
                              vactive--;
                          }
              #else
 547   3                  ClearTMDSTraining();
 548   3                  TMDSClockTraining(_DPPP_PHY1, TRUE);
 549   3      #endif
 550   3                  if (IsTMDSLBR(_DPPP_PHY0) == TRUE) {
 551   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_DIV, 0xC2);//Addr = 0x9C20; *Addr = 0xC2;
 552   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_HI, 0x0A);//Addr = 0x9C21; *Addr = 0x19;
 553   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 554   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 555   4                  }
 556   3                  else {
 557   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_DIV, 0xC0);//Addr = 0x9C20; *Addr = 0xC0;
 558   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_HI, 0x0A);//Addr = 0x9C21; *Addr = 0x19;
 559   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 560   4                      SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
 561   4                  }     
 562   3      
 563   3                  SC_TMDS_PHY_LINK_CTRL_1DE0 |= BIT3; // 0x1de0
 564   3                  bIsDualLink = TRUE;
 565   3            bDualDetection = TRUE;
 566   3      
 567   3                  for (vactive=0; vactive<100; vactive++) {   //2011-07-15 wasy: To wait Hactive become 2*hactiv
             -e after set SC_DVI_PLL_M=0x10 (from Mingyu)
 568   4                      Sleep(20);
 569   4                      if (hactive < GetDigInputHActive()) {
 570   5                          break;
 571   5                      }
 572   4                  }
 573   3      
 574   3            hactive = GetDigInputHActive()/2;//GetDualLinkInputHActive();//
 575   3            vactive = GetDigInputVActive();//GetDualLinkInputVActive();//
 576   3            if ((vactive < hactive) && (!bSpecialTiming)){
 577   4              bIsDualLink = FALSE;        
 578   4            } 
 579   3              }
 580   2              else{
 581   3                  bIsDualLink = FALSE;
 582   3              }            
 583   2      
 584   2              if (bIsDualLink == FALSE && bDualDetection==TRUE) {
 585   3                  SC_TMDS_LINK_CLK_SEL = ucTMDSLinkClkSel;// 0x1e7
 586   3            SC_DVI_PLL_M = ucTmpOfDviPllM;// 0xb18
 587   3                  SC_TMDS_PHY_LINK_CTRL_1DE0 &= ~BIT3; // 0x1de0
 588   3            SC_SetBitDPppPHY(_DPPP_PHY1, _DPPHY_LDO_CTRL, BIT7, FALSE); // _DPPHY_DUAL_LINK
 589   3      
 590   3            SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_DIV, 0x00);//Addr = 0x9C20; *Addr = 0xC2;
 591   3            SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_HI, 0x00);//Addr = 0x9C21; *Addr = 0x19;
 592   3            SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_MI, 0x00);//Addr = 0x9C22; *Addr = 0x00;
 593   3            SC_SetByteDPppPHY(_DPPP_PHY0, _DPPHY_FA1_FREQ_LO, 0x00);//Addr = 0x9C23; *Addr = 0x00;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 11  

 594   3              }   
 595   2              // XXX Why HDMI reset here?
 596   2              SC_HDMI_SOFTWARE_RESET &= ~BIT4;  // 0x605
 597   2              Sleep(20);
 598   2              SC_HDMI_SOFTWARE_RESET |= BIT4;
 599   2          }
 600   1      }
 601          
 602          /**************************************************************************//**
 603           * Get the present status of dual link TMDS.
 604           * @return TRUE if input is dual link TMDS signal else FALSE.
 605           ******************************************************************************/
 606          BOOL TMDS_IsDualLink(void)
 607          {
 608   1          if (GetTMDSPhyLinkSelect() == DIGITAL_INPUT1) { //DVI Input
 609   2              //return bIsDualLink;
 610   2              if (SC_TMDS_PHY_LINK_CTRL_1DE0&BIT3) { // 0x1de0
 611   3            return TRUE;
 612   3              }
 613   2          else {
 614   3            return FALSE;
 615   3          } 
 616   2          }
 617   1      
 618   1          return FALSE;
 619   1      }
 620          #endif
 621          
 622          /**************************************************************************//**
 623           * Get current TMDS clock.
 624           * @return TMDS clock frequency.
 625           ******************************************************************************/
 626          USHRT TMDS_GetClock(void)
 627          {
 628   1      USHRT clk_tmp;
 629   1      #if REF_CLK==12000000
 630   1          if ((SC_DVI_STATUS & BIT0) != 0) {
 631   2          #if (INPUT_INTERFACE&INPUT_MHL_MASK)
                      if (MHL_IsPackedPixelMode(MHL_CBUS_CH1) || MHL_IsPackedPixelMode(MHL_CBUS_CH2)) { //get correct PH
             -Y clock 0x016 after set 0x159.6=0
                          //printf("A:TMDS_GetClock_PP %d\r\n",(USHRT)SC_TMDS_CLOCK_DET);
                          return SC_TMDS_CLOCK_DET;  // 0x16
                      }
                  #endif
 637   2              clk_tmp = ReadShortScaler(&SC_DVI_PIXELCLK_LO) & 0x0FFF; // 0x304
 638   2              return clk_tmp;
 639   2          }
 640   1      #else
              #define OSC_FREQ_RATIO ((float)REF_CLK/12000000)
                  if ((SC_DVI_STATUS & BIT0) != 0) {  // 0x1ad
                  #if (INPUT_INTERFACE&INPUT_MHL_MASK)
                      if (MHL_IsPackedPixelMode(MHL_CBUS_CH1) || MHL_IsPackedPixelMode(MHL_CBUS_CH2)) { //get correct PH
             -Y clock 0x016 after set 0x159.6=0
                          clk_tmp = (USHRT)SC_TMDS_CLOCK_DET * OSC_FREQ_RATIO;// 0x16
                          return clk_tmp;
                      }
                  #endif
                      clk_tmp = (USHRT)((ReadShortScaler(&SC_DVI_PIXELCLK_LO) & 0x0FFF) * OSC_FREQ_RATIO);// 0x304
                      return clk_tmp;
                  }
              #undef OSC_FREQ_RATIO
              #endif
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 12  

 654   1          return 0;
 655   1      }
 656          
 657          UCHAR GetTMDSPHYDATA(UCHAR phyindex, USHRT address)
 658          {
 659   1          UCHAR value;
 660   1          
 661   1      #if IS_NT68810_SERIES
                  phyindex = _DPPP_PHY0;
                if (address <= 0x17F) {
                      if (phyindex == _DPPP_PHY0) {
                          address += 0x1A00;
                      }
                      else {
                          address += 0x1700;
                      }
                  SC_DPPPAPHY_ADDR_HI = (UCHAR)(address>>8);  // 0x1df0
                  SC_DPPPAPHY_ADDR_LO = (UCHAR)address;// 0x1df1
                  value = SC_DPPPAPHY_DATA;// 0x1df2
                  value = SC_DPPPAPHY_DATA;// 0x1df2
                }
                else {
                      if (phyindex == _DPPP_PHY0) {
                          value = SC_DPpp_CFG_TMDS_1A00[address];
                          value = SC_DPpp_CFG_TMDS_1A00[address];
                      }
                      else {
                          value = SC_DPpp_CFG_TMDS_1700[address];
                          value = SC_DPpp_CFG_TMDS_1700[address];
                      }
                } 
              #else
 686   1          if (phyindex == _DPPP_PHY0) {
 687   2              address += 0x1A00;
 688   2          }
 689   1          else {
 690   2              address += 0x1700;
 691   2          }
 692   1          SC_DPPPAPHY_ADDR_HI = (UCHAR)(address>>8);// 0x1df0
 693   1          SC_DPPPAPHY_ADDR_LO = (UCHAR)address;// 0x1df1
 694   1          value = SC_DPPPAPHY_DATA;// 0x1df2
 695   1          value = SC_DPPPAPHY_DATA;// 0x1df2
 696   1      #endif
 697   1          return value;
 698   1      }
 699          
 700          void SC_SetByteDPppPHY(UCHAR phyindex, USHRT reg, UCHAR value)
 701          {
 702   1      #if IS_NT68810_SERIES
                  phyindex = _DPPP_PHY0;
              #endif
 705   1          if (phyindex == _DPPP_PHY0) {
 706   2              SC_DPpp_CFG_TMDS_1A00[reg] = value;
 707   2          }
 708   1          else {
 709   2              SC_DPpp_CFG_TMDS_1700[reg] = value;
 710   2          }
 711   1      }
 712          
 713          void SC_SetBitDPppPHY(UCHAR phyindex, USHRT reg, UCHAR mask, UCHAR value)
 714          {
 715   1        UCHAR ucTmp;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 13  

 716   1      
 717   1      #if IS_NT68810_SERIES
                  phyindex = _DPPP_PHY0;
              #endif
 720   1        ucTmp = GetTMDSPHYDATA(phyindex, reg);
 721   1        if (value == TRUE) { 
 722   2          ucTmp |= mask;      
 723   2        }
 724   1        else {
 725   2          ucTmp &= ~mask; 
 726   2        }
 727   1          if (phyindex == _DPPP_PHY0) {
 728   2              SC_DPpp_CFG_TMDS_1A00[reg] = ucTmp;
 729   2          }
 730   1          else {
 731   2              SC_DPpp_CFG_TMDS_1700[reg] = ucTmp;
 732   2          }
 733   1      }
 734          
 735          
 736          #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == OFF
 737          void TMDSClockTraining(UCHAR phyindex, BOOL bForce)
 738          {
 739   1      #define BA_VALUE_TOO_LARGE 0x01
 740   1      #define BA_VALUE_TOO_SMALL 0x02
 741   1      //    UCHAR volatile xdata *Addr;
 742   1          UCHAR i, reg_value, vco_spd, cdr_enc, cdr_band, k, m, vcolockflag, n;
 743   1          USHRT ext_counter, int_counter;
 744   1          bit lbr_flag, error;
 745   1      
 746   1      //  static UCHAR ucCount=0;
 747   1        // Check Mode
 748   1        // HDMI_NRM, <= 340MHz (HDMI1.4/HDMI2.0)
 749   1        // HDMI_HSP, >340MHz   (HDMI2.0)
 750   1        // MHL2_NRM, mhl2.0 24-bit mode 
 751   1        // MHL2_PPM, mhl2.0 pp mode
 752   1        // MHL3_1P5G, mhl3.0 1.5G
 753   1        // MHL3_3P0G, mhl3.0 3.0G
 754   1        // MHL3_6P0G, mhl3.0 6.0G
 755   1      
 756   1        if (!bForce) {
 757   2          //    if ((SC_DVI_STATUS & BIT1) == 0) {
 758   2            if ((SC_HDMI_CKDT & BIT1) == 0) { // 0x606
 759   3                  ClearTMDSTraining();
 760   3                return;
 761   3            }
 762   2      
 763   2            if (bTMDSClockTraining == FALSE) {
 764   3                if ((GetTimerTick()-usTMDSTrainingTimer) < 500) {
 765   4                    return;
 766   4                }
 767   3                  if ((SC_HDMI_CKDT & 0x03) == 0x03) { // 0x606
 768   4                      return;
 769   4                  }
 770   3            }
 771   2        } 
 772   1          vcolockflag = 0;
 773   1          SC_SetBitDPppPHY(phyindex, _TMDS_DPHY_CLOCK_ENABLE, BIT7, FALSE);//Addr = 0x9B90; *Addr &= ~BIT7;   //
             -disable TMDS channel phase lock
 774   1      
 775   1          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG2, 0x06);//Addr = 0x9B08; *Addr = 0x06;    //dp_ana_cdr_cfg2
 776   1          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG4, 0x20);//Addr = 0x9B0A; *Addr = 0x20;    //dp_ana_cdr_cfg4
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 14  

 777   1          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0F);//Addr = 0x9AD2; *Addr = 0x0F;     //dprm_lane_hi_
             -cfg
 778   1          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG1, 0x0C);//Addr = 0x9B07; *Addr = 0x0C;     //dp_ana_cdr_cfg1
 779   1          SC_SetByteDPppPHY(phyindex, _DP_ANA_S2P_CFG, 0x30);//Addr = 0x9B0C; *Addr = 0x32;   //dp_ana_s2p_cfg
 780   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x00);//Addr = 0x9B20; *Addr = 0x00;     //dp_rxanaif_
             -vbs_cfg
 781   1          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG, 0x00);//Addr = 0x9B40; *Addr = 0x00;     //dp_rxanaif_
             -aeq_cfg
 782   1          SC_SetByteDPppPHY(phyindex, _DP_RXANAIF_CFG0, 0x12);//auto EQ, and Reg0x8242=0x31
 783   1      #if 0
                  SC_SetByteDPppPHY(phyidex, _DPRM_LANE_HI_CFG, 0x0F);
                  SC_SetByteDPppPHY(phyidex, _DP_ANA_CDR_CFG7, 0x02);//Addr = 0x9B0E; *Addr = vco_spd;
              #else
 787   1      //    SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0F);
 788   1      //    SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, 0x01);//Addr = 0x9B0E; *Addr = vco_spd;
 789   1      //    SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, 0x80);
 790   1      #endif
 791   1          
 792   1          Sleep(1);
 793   1      //    printf("TMDSClockTraining\r\n");
 794   1          for(k=0; k<3; k++) {
 795   2              i = ucTMDSInputMode;
 796   2              ucTMDSInputMode = GetTMDSPHYDATA(phyindex, _HDMI_MHL_INFO);//hdmi_mhl_info
 797   2      #ifdef FORCE_SCRAMBLE_ON
                      ucTMDSInputMode = HDMI_HSP;
              #endif
 800   2              if (ucTMDSInputMode == HDMI_HSP) {//HDMI_HSP
 801   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);
 802   3      ///////////////////////////////////////////////////////////////////////////////
 803   3      #ifdef ENABLE_HF_TMDS_AUTOEQ //auto EQ
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x03);//0x0F);//Addr = 0x9B49; *Addr = 0x0F;/
             -/dp_rxanaif_aeq_cfg3    
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0x00);//Addr = 0x9B4A; *Addr = 0x03;//0x01;//
             -dp_rxanaif_aeq_cfg4
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0x00);
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x31);//Addr = 0x9B42; *Addr = 0x13;//dp_rxan
             -aif_aeq_cfg2        
              #else //Manual EQ
 809   3      #if 1 // For ALLION
 810   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x03); // Pass IST & ALLION
 811   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0x3F); // Pass ALLION
 812   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0x00); // Pass IST  & ALLION 
 813   3                  SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L0_L2_L3, 0x1F); // Pass ALLION
 814   3                  SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L1, 0x1F); // Pass ALLION
 815   3      #else // For IST
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x03); // Pass IST & ALLION 
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0x0F); // Pass IST 
                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0x00); // Pass IST & ALLION 
                          SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L0_L2_L3, 0x1A); // Pass IST
                          SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L1, 0x1A); // Pass IST
              #endif
 822   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x33);//Addr = 0x9B42; *Addr = 0x13;//dp_rxan
             -aif_aeq_cfg2  
 823   3      #endif
 824   3              }
 825   2              else {
 826   3                  if ( 0
 827   3                       #if (INPUT_INTERFACE&INPUT_MHL0)            
                               || (phyindex==_DPPP_PHY0 && IsMHL0Connect() && GetCurrInputInterface()==DIGITAL_INPUT0) 
                               #endif
 830   3                       #if (INPUT_INTERFACE&INPUT_MHL1)
                               || (phyindex==_DPPP_PHY0 && IsMHL1Connect() && GetCurrInputInterface()==DIGITAL_INPUT1)
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 15  

                               #endif
 833   3                       #if (INPUT_INTERFACE&INPUT_MHL2)            
                               || (phyindex==_DPPP_PHY1 && IsMHL0Connect() && GetCurrInputInterface()==DIGITAL_INPUT2) 
                               #endif
 836   3                       #if (INPUT_INTERFACE&INPUT_MHL3)
                               || (phyindex==_DPPP_PHY1 && IsMHL1Connect() && GetCurrInputInterface()==DIGITAL_INPUT3)
                               #endif        
 839   3                     )
 840   3                  {
 841   4                           SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);
 842   4                           SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x0F);// 0x0F, PASS min/max & skew, 
             -// 0x07, PASS jitter no cable //Addr = 0x9B49; *Addr = 0x0F;//dp_rxanaif_aeq_cfg3    
 843   4                           SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0xFF);// 0x0FF, PASS min/max & skew,
             - // 0x1F, PASS jitter no cable
 844   4                           SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0x01); // 0x01, PASS min/max & skew 
             -// 0x00, PASS jitter no cable
 845   4                           SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG2, 0x06);      
 846   4                       #if 1
 847   4                           SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L0_L2_L3, 0x18);
 848   4                           SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L1,    0x18);      
 849   4                       #endif     
 850   4                           SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x33);//Addr = 0x9B42; *Addr = 0x11;
             -//dp_rxanaif_aeq_cfg2
 851   4                  }
 852   3                  else
 853   3                  { 
 854   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);
 855   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG3, 0x07);//Addr = 0x9B49; *Addr = 0x0F;//dp_
             -rxanaif_aeq_cfg3    
 856   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, 0xFF);
 857   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, 0xFF);
 858   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG2, 0x06);
 859   4                  #ifndef ENABLE_HF_TMDS_AUTOEQ
 860   4                      SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L0_L2_L3, 0x18);
 861   4                      SC_SetByteDPppPHY(phyindex, _DPPHY_IMPEDANCE_L1, 0x18);     
 862   4                  #endif
 863   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x31);//Addr = 0x9B42; *Addr = 0x11;//dp_
             -rxanaif_aeq_cfg2
 864   4                  }  
 865   3              }
 866   2      ///////////////////////////////////////////////////////////////////////////////
 867   2              if (ucTMDSInputMode == HDMI_NRM) {//HDMI_NRM
 868   3                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x06);//Addr = 0x9C00; *Addr = 0x06;//0x1C00= 0x06
 869   3      //            SC_HDMI_DATA_ALIGN &= ~BIT0;
 870   3              }
 871   2              else if (ucTMDSInputMode == HDMI_HSP) {//HDMI_HSP
 872   3                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x36);//Addr = 0x9C00; *Addr = 0x16;//0x1C00= 0x16
 873   3      //            SC_HDMI_DATA_ALIGN |= BIT0;
 874   3                  
 875   3              }
 876   2              else {//MHL
 877   3                  SC_SetByteDPppPHY(phyindex, _DPPHY_FCTRL, 0x8E);//Addr = 0x9C00; *Addr = 0x8E;//0x1C00= 0x8E
 878   3      //            if (ucTMDSInputMode == MHL2_PPM) {//PP mode
 879   3      //               SC_HDMI_DATA_ALIGN |= BIT0;
 880   3      //            }
 881   3      //            else {
 882   3      //                SC_HDMI_DATA_ALIGN &= ~BIT0;
 883   3      //            }
 884   3              }
 885   2              Sleep(1);
 886   2              
 887   2          //printf("ucTMDSInputMode=0x%bx \r\n",ucTMDSInputMode);
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 16  

 888   2      /*
 889   2      if (i != ucTMDSInputMode) {//???
 890   2            // Disable CDR at first
 891   2            // Lane0 Disable
 892   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x01);//Addr = 0x9AD2; *Addr = 0x01;// ADDR_DPRM_LA
             -NE_HI_CFG
 893   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
 894   2            reg_value &= 0xFE;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h0};   // CDR_EN_CDR
 895   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
 896   2          
 897   2            // Lane1 Disable
 898   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;// ADDR_DPRM_LA
             -NE_HI_CFG
 899   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
 900   2            reg_value &= 0xFE;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h0};   // CDR_EN_CDR
 901   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
 902   2          
 903   2              // Lane2 Disable
 904   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;// ADDR_DPRM_LA
             -NE_HI_CFG
 905   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
 906   2            reg_value &= 0xFE;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h0};   // CDR_EN_CDR
 907   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
 908   2          
 909   2            // Lane3 Disable
 910   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;// ADDR_DPRM_LA
             -NE_HI_CFG
 911   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
 912   2            reg_value &= 0xFE;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h0};   // CDR_EN_CDR
 913   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
 914   2      }
 915   2      */
 916   2      
 917   2      #if 0 
                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0F);
                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, 0x08);//Addr = 0x9B0E; *Addr = vco_spd;
                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, 0x80);
                      reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
                      reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
              //        reg_value |= cdr_enc;
                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
              #else
 926   2          vco_spd = 0x08;
 927   2          if ((vco_spd == 0x1) || (vco_spd == 0x2)) {
 928   3            cdr_enc = 0x0E;//3'b111;
 929   3          }
 930   2          if ((vco_spd == 0x3) || (vco_spd == 0x4)) {
 931   3            cdr_enc = 0x06;//3'b011;
 932   3          }
 933   2          if ((vco_spd == 0x5) || (vco_spd == 0x6)) {
 934   3            cdr_enc = 0x02;//3'b001;
 935   3          }
 936   2          if (vco_spd > 0x6) {
 937   3            cdr_enc = 0x00;//3'b000;
 938   3          }
 939   2      
 940   2          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0F);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_DPRM_LANE_H
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 17  

             -I_CFG
 941   2          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
 942   2          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, 0x80);
 943   2          reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
 944   2          reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
 945   2          reg_value |= cdr_enc;
 946   2          SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADDR_DP_A
             -NA_CDR_CFG0    
 947   2      #endif  
 948   2      
 949   2          // DIV SEL (Settings)
 950   2            if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
 951   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;// ADDR_DPR
             -M_LANE_HI_CFG
 952   3              }
 953   2              else {
 954   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;// ADDR_DPR
             -M_LANE_HI_CFG
 955   3              }
 956   2          
 957   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG6, 0x08);//Addr = 0x9B0D; *Addr = 0x08;// ADDR_DP_ANA_C
             -DR_CFG6
 958   2              if (ucTMDSInputMode == HDMI_NRM) { // HDMI_NRM
 959   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x01);//Addr = 0x9B0F; *Addr = 0x01;    // ADDR_DP
             -_ANA_CDR_CFG8
 960   3              }
 961   2              
 962   2              if (ucTMDSInputMode == HDMI_HSP) { // HDMI_HSP
 963   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x08);//Addr = 0x9B0F; *Addr = 0x08;    // ADDR_DP
             -_ANA_CDR_CFG8
 964   3              }
 965   2              
 966   2              if (ucTMDSInputMode == MHL2_NRM) { // MHL2_NRM
 967   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x04);//Addr = 0x9B0F; *Addr = 0x04;    // ADDR_DP
             -_ANA_CDR_CFG8
 968   3              }
 969   2              
 970   2              if (ucTMDSInputMode == MHL2_PPM) { // MHL2_PPM
 971   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x08);//Addr = 0x9B0F; *Addr = 0x08;    // ADDR_DP
             -_ANA_CDR_CFG8
 972   3              }
 973   2              
 974   2              if (ucTMDSInputMode == MHL3_1P5G) { // MHL3_1P5G
 975   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x02);//Addr = 0x9B0F; *Addr = 0x02;    // ADDR_DP
             -_ANA_CDR_CFG8
 976   3              }
 977   2              
 978   2              if (ucTMDSInputMode == MHL3_3P0G) { // MHL3_3P0G
 979   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x08);//Addr = 0x9B0F; *Addr = 0x08;    // ADDR_DP
             -_ANA_CDR_CFG8
 980   3              }
 981   2              
 982   2              if (ucTMDSInputMode == MHL3_6P0G) { // MHL3_6P0G
 983   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG8, 0x10);//Addr = 0x9B0F; *Addr = 0x10;    // ADDR_DP
             -_ANA_CDR_CFG8
 984   3              }
 985   2              
 986   2            // REF_CK SEL (Settings)
 987   2              if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
 988   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // ADDR_D
             -PRM_LANE_HI_CFG
 989   3              }
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 18  

 990   2              else {
 991   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
 992   3              }
 993   2              
 994   2              if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
 995   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FCNT_CFG, 0x11);//Addr = 0x9B33; *Addr = 0x11;   // 
             -ADDR_DP_RXANAIF_VBS_FCNT_CFG
 996   3              }
 997   2              else if ((ucTMDSInputMode == MHL2_NRM) || (ucTMDSInputMode == MHL2_PPM)) { // MHL2_NRM / MHL2_PPM
 998   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FCNT_CFG, 0x11);//Addr = 0x9B33; *Addr = 0x11;   // 
             -ADDR_DP_RXANAIF_VBS_FCNT_CFG
 999   3              }
1000   2              else if ((ucTMDSInputMode == MHL3_1P5G) || (ucTMDSInputMode == MHL3_3P0G) || (ucTMDSInputMode == M
             -HL3_6P0G)) { // MHL3_1P5G / MHL3_3P0G / MHL3_6P0G
1001   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FCNT_CFG, 0x21);//Addr = 0x9B33; *Addr = 0x21;   // 
             -ADDR_DP_RXANAIF_VBS_FCNT_CFG
1002   3              }
1003   2              
1004   2            // LBR Flag (Settings)
1005   2            lbr_flag = FALSE;
1006   2            if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1007   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // ADDR_D
             -PRM_LANE_HI_CFG
1008   3            }
1009   2            else {
1010   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1011   3            }
1012   2          
1013   2              if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == MHL2_NRM) || (ucTMDSInputMode == MHL2_PPM
             -)) {
1014   3                  // Use Counter to Check REF_CK
1015   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0xB0);//Addr = 0x9B20; *Addr = 0xB0;//system.i
             -_pbusm.write(0x20, 0xb0);   // ADDR_DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_done_md
1016   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0xC0);//Addr = 0x9B24; *Addr = 0xC0;   // 
             -ADDR_DP_RXANAIF_VBS_PERIOD_L, 2us
1017   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x00);//Addr = 0x9B25; *Addr = 0x00;//sys
             -tem.i_pbusm.write(0x25, 0x00);    // ADDR_DP_RXANAIF_VBS_PERIOD_H
1018   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG1, 0x00);//Addr = 0x9B2E; *Addr = 0x00;   // ADDR
             -_DP_RXANAIF_VBS_CFG1, dp_rxanaif_vbs_fcnt1_en
1019   3                  if (ucTMDSInputMode == HDMI_NRM) {
1020   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_L, 0xF0);//Addr = 0x9B22; *Addr = 0xF0;//s
             -ystem.i_pbusm.write(0x22, 0xf0);    // ADDR_DP_RXANAIF_VBS_FNUM_L, Target 240 @ 2us
1021   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_H, 0x00);//Addr = 0x9B23; *Addr = 0x00;//s
             -ystem.i_pbusm.write(0x23, 0x00);    // ADDR_DP_RXANAIF_VBS_FNUM_H
1022   4                  }
1023   3                  if (ucTMDSInputMode == MHL2_NRM) {
1024   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_L, 0x50);//Addr = 0x9B22; *Addr = 0x50;//s
             -ystem.i_pbusm.write(0x22, 0x50);    // ADDR_DP_RXANAIF_VBS_FNUM_L, Target 80 @ 2us
1025   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_H, 0x00);//Addr = 0x9B23; *Addr = 0x00;//s
             -ystem.i_pbusm.write(0x23, 0x00);    // ADDR_DP_RXANAIF_VBS_FNUM_H
1026   4                  }
1027   3                  if (ucTMDSInputMode == MHL2_PPM) {
1028   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_L, 0x3C);//Addr = 0x9B22; *Addr = 0x3C;//s
             -ystem.i_pbusm.write(0x22, 0x3c);    // ADDR_DP_RXANAIF_VBS_FNUM_L, Target 60 @ 2us
1029   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FNUM_H, 0x00);// Addr = 0x9B23; *Addr = 0x00;//
             -system.i_pbusm.write(0x23, 0x00);   // ADDR_DP_RXANAIF_VBS_FNUM_H
1030   4                  }
1031   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;//system.i_
             -pbusm.write(0xd2, 0x02);    // ADDR_DPRM_LANE_HI_CFG
1032   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0xB1);//Addr = 0x9B20; *Addr = 0xB1;//system.i
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 19  

             -_pbusm.write(0x20, 0xb1);   // ADDR_DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_trig_pls
1033   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);// ADDR_DP_ANA_CDR_CFG0
1034   3                  i = 255;
1035   3                  while (((reg_value & BIT0) != 0) && (i != 0)) {
1036   4      //                Sleep(1);
1037   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);// ADDR_DP_ANA_CDR_CFG0
1038   4                      i--;
1039   4                  }
1040   3          
1041   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1042   3                  if(reg_value & BIT0 != 0x00) {
1043   4                      lbr_flag = TRUE;
1044   4                  }
1045   3              }
1046   2          //printf("test 1\r\n");
1047   2          //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1048   2          //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1049   2          //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1050   2          //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1051   2          //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1052   2          //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1053   2                // LBR Flag for Lane1 ~ Lane3 or Lane1 Only
1054   2            if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1055   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // ADDR_D
             -PRM_LANE_HI_CFG
1056   3            }
1057   2            else {
1058   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1059   3            }
1060   2          
1061   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG6);// ADDR_DP_ANA_CDR_CFG6
1062   2            if (lbr_flag == TRUE) { //reg_value = {reg_value[7:2], lbr_flag, reg_value[0]}; // CDR_LBR_FLAG
1063   3                  reg_value |= BIT1;
1064   3              }
1065   2              else {
1066   3                  reg_value &= ~BIT1;
1067   3              }
1068   2            SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG6, reg_value);//Addr = 0x9B0D; *Addr = reg_value;//system.
             -i_pbusm.write(0x0d, reg_value);   // ADDR_DP_ANA_CDR_CFG6
1069   2          
1070   2            // Lane Enable (Settings)
1071   2            // Lane1 Enable
1072   2            SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_DPRM_LAN
             -E_HI_CFG
1073   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1074   2            reg_value |= 0x01;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};   // CDR_EN_CDR
1075   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
1076   2          //reset VCO////
1077   2      //??        Sleep(1);
1078   2              reg_value |= BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1079   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0
1080   2      //        Sleep(1);
1081   2              reg_value &= ~BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1082   2              SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;// ADD
             -R_DP_ANA_CDR_CFG0  
1083   2          //////////////
1084   2            if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1085   3              // Lane2 Enable
1086   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // ADDR_D
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 20  

             -PRM_LANE_HI_CFG
1087   3                  reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1088   3                  reg_value |= 0x01;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};   // CDR_EN_CDR
1089   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1090   3              //reset VCO////
1091   3                  //??Sleep(1);
1092   3                  reg_value |= BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1093   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1094   3      //            Sleep(1);
1095   3                  reg_value &= ~BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1096   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0  
1097   3              //////////////
1098   3          
1099   3              // Lane3 Enable
1100   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // ADDR_D
             -PRM_LANE_HI_CFG
1101   3                  reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1102   3                  reg_value |= 0x01;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};   // CDR_EN_CDR
1103   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1104   3              //reset VCO////
1105   3                  //??Sleep(1);
1106   3                  reg_value |= BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1107   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1108   3      //            Sleep(1);
1109   3                  reg_value &= ~BIT4;// CDR_EN_CDR //reg_value = {reg_value[7:1], 1'h1};          // CDR_EN_CDR
1110   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0  
1111   3              //////////////
1112   3            }
1113   2              
1114   2            // VCO_SPD (Settings, 1st Step, Search)
1115   2            //search_vco_speed
1116   2            if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1117   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // ADDR_D
             -PRM_LANE_HI_CFG
1118   3              }
1119   2              else {
1120   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1121   3              }
1122   2              
1123   2              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0xB0);//Addr = 0x9B20; *Addr = 0xB0;    // ADDR_DP_R
             -XANAIF_VBS_CFG, dp_rxanaif_vbs_done_md
1124   2              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0xC0);//Addr = 0x9B24; *Addr = 0xC0;   // ADDR
             -_DP_RXANAIF_VBS_PERIOD_L, 2us
1125   2              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x00);//Addr = 0x9B25; *Addr = 0x00;   // ADDR
             -_DP_RXANAIF_VBS_PERIOD_H
1126   2              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, 0x80);//Addr = 0x9B28; *Addr = 0x80;    // ADDR_DP
             -_RXANAIF_VBS_BASEL
1127   2              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG1, 0x40);//Addr = 0x9B2E; *Addr = 0x40;   // ADDR_DP_
             -RXANAIF_VBS_CFG1, dp_rxanaif_vbs_fcnt1_en
1128   2          
1129   2              for (vco_spd=0x1; vco_spd<0x10; vco_spd++) {
1130   3                  if ((vco_spd == 0x1) || (vco_spd == 0x2)) {
1131   4                      cdr_enc = 0x0E;//3'b111;
1132   4                  }
1133   3                  if ((vco_spd == 0x3) || (vco_spd == 0x4)) {
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 21  

1134   4                      cdr_enc = 0x06;//3'b011;
1135   4                  }
1136   3                  if ((vco_spd == 0x5) || (vco_spd == 0x6)) {
1137   4                      cdr_enc = 0x02;//3'b001;
1138   4                  }
1139   3                  if (vco_spd > 0x6) {
1140   4                      cdr_enc = 0x00;//3'b000;
1141   4                  }
1142   3          
1143   3                // Lane1 ENC & VCO_SPD & Band
1144   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1145   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1146   3                  reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1147   3                  reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1148   3                  reg_value |= cdr_enc;
1149   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1150   3          
1151   3                if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1152   4                      // Lane2 ENC & VCO_SPD
1153   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // AD
             -DR_DPRM_LANE_HI_CFG
1154   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1155   4                      reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1156   4                      reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1157   4                      reg_value |= cdr_enc;
1158   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_valu
             -e;// ADDR_DP_ANA_CDR_CFG0
1159   4          
1160   4                      // Lane3 ENC & VCO_SPD
1161   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // AD
             -DR_DPRM_LANE_HI_CFG
1162   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1163   4                      reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1164   4                      reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1165   4                      reg_value |= cdr_enc;
1166   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_valu
             -e;// ADDR_DP_ANA_CDR_CFG0
1167   4                }
1168   3          
1169   3                for (i=0; i<50; i++) {//Sleep(1); // Delay for VCO_SPD Update 50us
1170   4                      ResetWDTimer();
1171   4                  }
1172   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1173   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0xB1);//Addr = 0x9B20; *Addr = 0xB1;    // ADDR_
             -DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_trig_pls
1174   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);// Polling
1175   3                  i = 255;
1176   3                  while (((reg_value & BIT0) != 0) && (i != 0)) {
1177   4                      //Sleep(1);
1178   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);// ADDR_DP_ANA_CDR_CFG0
1179   4                      i--;
1180   4                  }
1181   3          
1182   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1183   3                  if(reg_value & BIT0 != 0x00) {
1184   4                      break;
1185   4                  }
1186   3              }
1187   2          //printf("test 2\r\n");
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 22  

1188   2          //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1189   2          //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1190   2          //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1191   2          //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1192   2          //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1193   2          //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1194   2          
1195   2            // VCO_SPD (Settings, 2nd Step, Set Value)
1196   2            SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_DPRM_LAN
             -E_HI_CFG
1197   2              reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7);// ADDR_DP_ANA_CDR_CFG0
1198   2            vco_spd = reg_value;
1199   2      
1200   2            if (vco_spd != 0x1) {
1201   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1202   3                  if ((reg_value & BIT6) == 0x00) {
1203   4                      vco_spd = vco_spd - 0x1;
1204   4                  }
1205   3              }
1206   2              n = 3;
1207   2              do {
1208   3                  if ((vcolockflag == BA_VALUE_TOO_LARGE) && (vco_spd < 15)){
1209   4                      vco_spd += 1;
1210   4                  }
1211   3                  if ((vcolockflag == BA_VALUE_TOO_SMALL) && (vco_spd > 1)){
1212   4                      vco_spd -= 1;
1213   4                  }
1214   3                  if ((vco_spd == 0x1) || (vco_spd == 0x2)) {
1215   4                      cdr_enc = 0x0E;//3'b111;
1216   4                  }
1217   3                  if ((vco_spd == 0x3) || (vco_spd == 0x4)) {
1218   4                      cdr_enc = 0x06;//3'b011;
1219   4                  }
1220   3                  if ((vco_spd == 0x5) || (vco_spd == 0x6)) {
1221   4                      cdr_enc = 0x02;//3'b001;
1222   4                  }
1223   3                  if (vco_spd > 0x6) {
1224   4                      cdr_enc = 0x00;//3'b000;
1225   4                  }
1226   3              // Lane1 ENC & VCO_SPD & Band
1227   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1228   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1229   3                  reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1230   3                  reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1231   3                  reg_value |= cdr_enc;
1232   3                  SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_value;//
             - ADDR_DP_ANA_CDR_CFG0
1233   3      
1234   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1235   4                    // Lane2 ENC & VCO_SPD
1236   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // AD
             -DR_DPRM_LANE_HI_CFG
1237   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1238   4                      reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1239   4                      reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1240   4                      reg_value |= cdr_enc;
1241   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_valu
             -e;// ADDR_DP_ANA_CDR_CFG0
1242   4          
1243   4                    // Lane3 ENC & VCO_SPD
1244   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // AD
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 23  

             -DR_DPRM_LANE_HI_CFG
1245   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG7, vco_spd);//Addr = 0x9B0E; *Addr = vco_spd;
1246   4                      reg_value = GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG0);// ADDR_DP_ANA_CDR_CFG0
1247   4                      reg_value &= 0xF1;//reg_value = {reg_value[7:4], cdr_enc, reg_value[0]};  // CDR_ENC[2:0]
1248   4                      reg_value |= cdr_enc;
1249   4                      SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG0, reg_value);//Addr = 0x9B06; *Addr = reg_valu
             -e;// ADDR_DP_ANA_CDR_CFG0
1250   4                  }
1251   3      
1252   3                  // CDR_BA (Settings, 1st Step, Coarse Tune)
1253   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1254   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // AD
             -DR_DPRM_LANE_HI_CFG
1255   4                  }
1256   3                  else {
1257   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // AD
             -DR_DPRM_LANE_HI_CFG
1258   4                  }
1259   3              
1260   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, 0x00);//Addr = 0x9B28; *Addr = 0x00;    // ADD
             -R_DP_RXANAIF_VBS_BASEL
1261   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x00);//Addr = 0x9B20; *Addr = 0x00;    // ADDR_
             -DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_done_md
1262   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_STEP_CFG, 0x08);//Addr = 0x9B21; *Addr = 0x08;   // 
             -ADDR_DP_RXANAIF_VBS_STEP_CFG
1263   3                  if (lbr_flag) {
1264   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0xC0);//Addr = 0x9B24; *Addr = 0xC0; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_L, 10us
1265   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x03);//Addr = 0x9B25; *Addr = 0x03; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_H
1266   4                  }
1267   3                  else {
1268   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0x60);//Addr = 0x9B24; *Addr = 0x60; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_L, 1us
1269   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x00);//Addr = 0x9B25; *Addr = 0x00; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_H
1270   4                  }
1271   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG1, 0x40);//Addr = 0x9B2E; *Addr = 0x40;   // ADDR
             -_DP_RXANAIF_VBS_CFG1, dp_rxanaif_vbs_fcnt1_en
1272   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_CFG);// ADDR_DP_ANA_CDR_CFG0
1273   3                  reg_value = ((reg_value & 0xF0) | 0x04);//reg_value = {reg_value[7:4], 4'h4};
1274   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FCNT_CFG, reg_value);//Addr = 0x9B33; *Addr = reg_v
             -alue;
1275   3              
1276   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x01);//Addr = 0x9B20; *Addr = 0x01;    // ADDR_
             -DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_trig_pls
1277   3              
1278   3                  // Check Lane1
1279   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1280   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1281   3                  i = 255;//170us
1282   3                  while (((reg_value & BIT0) != 0) && (i != 0)) {// Polling
1283   4                      //Sleep(1);
1284   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1285   4                      i--;
1286   4                  }
1287   3              
1288   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);// ADDR_DP_RXANAIF_VBS_BASEL
1289   3                  if (reg_value < 9) {
1290   4                      reg_value = 0;
1291   4                  }
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 24  

1292   3                  else {
1293   4                      reg_value = reg_value - 0x09;
1294   4                  }
1295   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, reg_value);//Addr = 0x9B28; *Addr = reg_valu
             -e;    // ADDR_DP_RXANAIF_VBS_BASEL
1296   3              //printf("test 3\r\n");
1297   3              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1298   3              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1299   3              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1300   3              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1301   3              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1302   3              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1303   3              
1304   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1305   4              
1306   4                    // Check Lane2
1307   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // AD
             -DR_DPRM_LANE_HI_CFG
1308   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1309   4                      i = 255;//170us
1310   4                      while (((reg_value & BIT0) != 0) && (i != 0)) {// Polling
1311   5                          //Sleep(1);
1312   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1313   5                          i--;
1314   5                      }
1315   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);// ADDR_DP_RXANAIF_VBS_BASEL
1316   4                      if (reg_value < 9) {
1317   5                          reg_value = 0;
1318   5                      }
1319   4                      else {
1320   5                          reg_value = reg_value - 0x09;
1321   5                      }
1322   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, reg_value);//Addr = 0x9B28; *Addr = reg_
             -value;    // ADDR_DP_RXANAIF_VBS_BASEL
1323   4              //printf("test 4\r\n");
1324   4              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1325   4              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1326   4              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1327   4              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1328   4              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1329   4              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1330   4              
1331   4                    // Check Lane3
1332   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // AD
             -DR_DPRM_LANE_HI_CFG
1333   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1334   4                      i = 255;//170us
1335   4                      while (((reg_value & BIT0) != 0) && (i != 0)) {// Polling
1336   5                          //Sleep(1);
1337   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1338   5                          i--;
1339   5                      }
1340   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);// ADDR_DP_RXANAIF_VBS_BASEL
1341   4                      if (reg_value < 9) {
1342   5                          reg_value = 0;
1343   5                      }
1344   4                      else {
1345   5                          reg_value = reg_value - 0x09;
1346   5                      }
1347   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, reg_value);//Addr = 0x9B28; *Addr = reg_
             -value;    // ADDR_DP_RXANAIF_VBS_BASEL
1348   4              //printf("test 5\r\n");
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 25  

1349   4              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1350   4              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1351   4              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1352   4              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1353   4              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1354   4              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1355   4                  }
1356   3              
1357   3                  // CDR_BA (Settings, 2nd Step, Fine Tune)
1358   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1359   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;    // 
             -ADDR_DPRM_LANE_HI_CFG
1360   4                  }
1361   3                  else {
1362   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;    // 
             -ADDR_DPRM_LANE_HI_CFG
1363   4                  }
1364   3              
1365   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x00);//Addr = 0x9B20; *Addr = 0x00;    // ADDR_
             -DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_done_md
1366   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_STEP_CFG, 0x01);//Addr = 0x9B21; *Addr = 0x01;   // 
             -ADDR_DP_RXANAIF_VBS_STEP_CFG
1367   3                  if(lbr_flag) {
1368   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0xC0);//Addr = 0x9B24; *Addr = 0xC0; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_L, 50us
1369   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x12);//Addr = 0x9B25; *Addr = 0x12; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_H
1370   4                  }
1371   3                  else {
1372   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0xE0);//Addr = 0x9B24; *Addr = 0xE0; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_L, 5us
1373   4                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x01);//Addr = 0x9B25; *Addr = 0x01; 
             -  // ADDR_DP_RXANAIF_VBS_PERIOD_H
1374   4                  }
1375   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG1, 0x40);//Addr = 0x9B2E; *Addr = 0x40;   // ADDR
             -_DP_RXANAIF_VBS_CFG1, dp_rxanaif_vbs_fcnt1_en
1376   3              
1377   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_CFG);
1378   3                  reg_value = ((reg_value & 0xF0) | 0x04);//reg_value = {reg_value[7:4], 4'h4};
1379   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_FCNT_CFG, reg_value);//Addr = 0x9B33; *Addr = reg_v
             -alue;
1380   3              
1381   3                  SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x01);//Addr = 0x9B20; *Addr = 0x01;    // ADDR_
             -DP_RXANAIF_VBS_CFG, dp_rxanaif_vbs_trig_pls
1382   3              
1383   3                  // Check Lane1
1384   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1385   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1386   3                  i = 255;//450us
1387   3                  while (((reg_value & BIT0) != 0x00) && (i != 0)) {
1388   4                      //Sleep(1);
1389   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1390   4                      i--;
1391   4                  }
1392   3              //printf("test 6\r\n");
1393   3              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1394   3              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1395   3              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1396   3              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1397   3              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1398   3              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 26  

1399   3              
1400   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1401   4              
1402   4                    // Check Lane2
1403   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // AD
             -DR_DPRM_LANE_HI_CFG
1404   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1405   4                      i = 255;//450us
1406   4                      while (((reg_value & BIT0) != 0x00) && (i != 0)) {
1407   5                          //Sleep(1);
1408   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1409   5                          i--;
1410   5                      }
1411   4              //printf("test 7\r\n");
1412   4              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1413   4              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1414   4              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1415   4              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1416   4              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1417   4              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1418   4              
1419   4                    // Check Lane3
1420   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // AD
             -DR_DPRM_LANE_HI_CFG
1421   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1422   4                      i = 255;//450us
1423   4                      while (((reg_value & BIT0) != 0x00) && (i != 0)) {
1424   5                          //Sleep(1);
1425   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_CFG);
1426   5                          i--;
1427   5                      }
1428   4              //printf("test 8\r\n");
1429   4              //printf("Reg0x1B29=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L));
1430   4              //printf("Reg0x1B2A=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H));
1431   4              //printf("Reg0x1B34=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L));
1432   4              //printf("Reg0x1B35=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H));
1433   4              //printf("Reg0x1B0E=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG7));
1434   4              //printf("Reg0x1B28=%x\r\n", (USHRT)GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL));
1435   4                  }
1436   3              
1437   3                  // CDR_BA (Settings, 3rd Step, Set Value)
1438   3                  // Lane1 Band
1439   3                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_D
             -PRM_LANE_HI_CFG
1440   3                  reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);
1441   3                  cdr_band = reg_value;
1442   3                  if (cdr_band != 0x00) {
1443   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1444   4                      if ((reg_value & BIT6) == 0x00) {
1445   5                          cdr_band = cdr_band - 0x1;
1446   5                          SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, cdr_band);//Addr = 0x9B28; *Addr = c
             -dr_band;
1447   5                      }
1448   4                  }
1449   3              
1450   3                  if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1451   4                    // Lane2 Band
1452   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;   // AD
             -DR_DPRM_LANE_HI_CFG
1453   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);// ADDR_DP_ANA_CDR_CFG7
1454   4                      cdr_band = reg_value;
1455   4                      if (cdr_band != 0x00) {
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 27  

1456   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1457   5                          if ((reg_value & BIT6) == 0x00) {
1458   6                              cdr_band = cdr_band - 0x1;
1459   6                              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, cdr_band);//Addr = 0x9B28; *Addr
             - = cdr_band;
1460   6                          }
1461   5                      }
1462   4              
1463   4                    // Lane3 Band
1464   4                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;   // AD
             -DR_DPRM_LANE_HI_CFG
1465   4                      reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);// ADDR_DP_ANA_CDR_CFG7
1466   4                      cdr_band = reg_value;
1467   4                      if (cdr_band != 0x00) {
1468   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_STS);// ADDR_DP_RXANAIF_VBS_STS
1469   5                          if ((reg_value & BIT6) == 0x00) {
1470   6                              cdr_band = cdr_band - 0x1;
1471   6                              SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_BASEL, cdr_band);//Addr = 0x9B28; *Addr
             - = cdr_band;
1472   6                          }
1473   5                      }
1474   4                  }
1475   3              
1476   3                  error = 0;
1477   3                  for (m=0; m<3; m++) {
1478   4                      if (m == 0) {
1479   5                          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;
1480   5                      }
1481   4                      else if (m == 1) {
1482   5                          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//Addr = 0x9AD2; *Addr = 0x04;
1483   5                      }
1484   4                      else {
1485   5                          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//Addr = 0x9AD2; *Addr = 0x08;
1486   5                      }
1487   4                      ext_counter = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_H);
1488   4                      ext_counter <<= 8;
1489   4                      ext_counter |= GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT1_L);
1490   4                      int_counter = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_H);
1491   4                      int_counter <<= 8;
1492   4                      int_counter |= GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_FCNT_L);
1493   4          //            if (abs(int_counter-ext_counter) > (ULONG)ext_counter * 3 / 1000 + 1) {
1494   4                      if (abs(int_counter-ext_counter) > (ULONG)ext_counter * 2 / 100 + 1) {
1495   5                          error = 1;
1496   5                      }
1497   4                      vcolockflag = 0;
1498   4                      if (error == 0) {
1499   5                          reg_value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);
1500   5                          if (reg_value > 0xF0) {
1501   6                              vcolockflag = BA_VALUE_TOO_LARGE;
1502   6                              error = 1;
1503   6                          }
1504   5                          if (reg_value < 0x10) {
1505   6                              vcolockflag = BA_VALUE_TOO_SMALL;
1506   6                              error = 1;
1507   6                          }
1508   5                      }
1509   4                      if (ucTMDSInputMode > HDMI_HSP) { // MHL
1510   5                          break;
1511   5                      }
1512   4                      if (error == 1) {
1513   5                          break;
1514   5                      }
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 28  

1515   4                  }
1516   3                  n--;
1517   3              } while ((n != 0) && (vcolockflag != 0));
1518   2              if (error == 0) {
1519   3                  break;
1520   3              }
1521   2          }
1522   1      //printf("k = %x\r\n", (USHRT)k);
1523   1      
1524   1        // Band Selection Done (Settings)
1525   1        if ((ucTMDSInputMode == HDMI_NRM) || (ucTMDSInputMode == HDMI_HSP)) { // HDMI_NRM / HDMI_HSP
1526   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);//Addr = 0x9AD2; *Addr = 0x0E;   // ADDR_DPRM_
             -LANE_HI_CFG
1527   2        }
1528   1        else {
1529   2              SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//Addr = 0x9AD2; *Addr = 0x02;   // ADDR_DPRM_
             -LANE_HI_CFG
1530   2        }
1531   1        // ABJ
1532   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x40);//Addr = 0x9B20; *Addr = 0x40;    // ADDR_DP_RXANAIF_
             -VBS_CFG, dp_rxanaif_vbs_done_md
1533   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_STEP_CFG, 0x01);//Addr = 0x9B21; *Addr = 0x01;   // ADDR_DP_RXA
             -NAIF_VBS_STEP_CFG
1534   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_L, 0x60);//Addr = 0x9B24; *Addr = 0x60;   // ADDR_DP_RXA
             -NAIF_VBS_PERIOD_L, 1us
1535   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_PERIOD_H, 0x00);//Addr = 0x9B25; *Addr = 0x00;   // ADDR_DP_RXA
             -NAIF_VBS_PERIOD_H
1536   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG1, 0x02);//Addr = 0x9B2E; *Addr = 0x02;   // ADDR_DP_RXANAIF
             -_VBS_CFG1, dp_rxanaif_vbs_step_mode
1537   1        SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG1, 0x05);//Addr = 0x9B07; *Addr = 0x04;//0x07;   // ADDR_DP_ANA
             -_CDR_CFG1
1538   1          Sleep(1);
1539   1        SC_SetByteDPppPHY(phyindex, _DP_ANA_S2P_CFG, 0x31);//Addr = 0x9B0C; *Addr = 0x33;   // ADDR_DP_ANA_S2P_CFG
1540   1        SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG4, 0x21);//Addr = 0x9B0A; *Addr = 0x21;    // 
1541   1        SC_SetByteDPppPHY(phyindex, _DP_ANA_CDR_CFG5, 0x14);//Addr = 0x9B0B; *Addr = 0x14;    // 
1542   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_VBS_CFG, 0x41);//Addr = 0x9B20; *Addr = 0x41;    // ADDR_DP_RXANAIF_
             -VBS_CFG, dp_rxanaif_vbs_done_md
1543   1      
1544   1        // AEQ
1545   1        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG, 0x01);//Addr = 0x9B40; *Addr = 0x01;    // ADDR_DP_RXANAIF_
             -AEQ_CFG
1546   1      //  Sleep(20);
1547   1      ////////////////////////////////////////////////////////
1548   1          if (ucTMDSInputMode == HDMI_NRM) { // HDMI_NRM
1549   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_MHL2p0_MISC, 0x20);//Addr = 0x9B9A; *Addr = 0x20;
1550   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_ENABLE, 0xF8);//Addr = 0x9B90; *Addr = 0xF8;
1551   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_INVERT, 0xE0);//Addr = 0x9B91; *Addr = 0x00;
1552   2          }
1553   1          else if (ucTMDSInputMode == HDMI_HSP) { // HDMI_HSP
1554   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_MHL2p0_MISC, 0x20);//Addr = 0x9B9A; *Addr = 0x20;
1555   2      #ifdef FORCE_SCRAMBLE_ON//force scramble
                      SC_SetByteHDMIRX(linkidx, _TMDS_SCRAMBLE_CTRL, 0x03);// Addr = 0x88E1; *Addr = 0x03;
              #endif
1558   2      #ifdef TMDS4K2K_TEST
                      SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_ENABLE, 0xF8);//Addr = 0x9B90; *Addr = 0xF8;
                      SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_INVERT, 0x00);//Addr = 0x9B91; *Addr = 0x00;
              #else
1562   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_ENABLE, 0xFC);//Addr = 0x9B90; *Addr = 0xFC;
1563   2      #endif
1564   2          }
1565   1          else {//MHL
1566   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_MHL2p0_MISC, 0x20);//Addr = 0x9B9A; *Addr = 0x20;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 29  

1567   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_ENABLE, 0xF8);//Addr = 0x9B90; *Addr = 0xF8;
1568   2              SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CLOCK_INVERT, 0x00);//Addr = 0x9B91; *Addr = 0x00;
1569   2          }
1570   1      
1571   1      #ifdef ENABLE_HF_TMDS_AUTOEQ
                if ( 0 )
                {
                }
                  else if (GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG2) != 0x33) {
                  USHRT usTmpD0, usTmpD1, usTmpD2;
                  // Sleep(100);
                    //printf("linkidx=%x\r\n", (USHRT)linkidx);
                      Sleep(2);;//Sleep(20);
                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);
                  usTmpD0 = (USHRT) GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG5);
                  usTmpD0 = usTmpD0<<8;
                  usTmpD0 |= GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG4);
                  usTmpD0 = (usTmpD0<<1) | BIT0;
              
                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);
                  usTmpD1 = (USHRT) GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG5);
                  usTmpD1 = usTmpD1<<8;
                  usTmpD1 |= GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG4);
                  usTmpD1 = (usTmpD1<<1) | BIT0;
                  
                  SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);
                  usTmpD2 = (USHRT) GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG5);
                  usTmpD2 = usTmpD2<<8;
                  usTmpD2 |= GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG4);
                  usTmpD2 = (usTmpD2<<1) | BIT0;
              
              //        SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);   
              //        SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x33);
                  
                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD0&0x00FF) );
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD0>>8) );
                  
                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD1&0x00FF) );
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD1>>8) );
              
              
                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD2&0x00FF) );
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD2>>8) );
              
                      SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x0E);   
                      SC_SetByteDPppPHY(phyindex, _DPRXANAIF_AEQ_CFG2, 0x33);
                }
              #endif
1618   1          
1619   1          bTMDSClockTraining = FALSE;
1620   1          usTMDSTrainingTimer = GetTimerTick();
1621   1          
1622   1          TMDS_EQSet_FlowReset();
1623   1          
1624   1      #if ENABLE_TMDS_EQ_SEARCH_FLOW == ON    
1625   1          //EQ setting flow, no need to do when use manual mode
1626   1          if (GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG2) != 0x33) {    
1627   2              TMDS_EQSet_EQSetting(phyindex, stEQSet.ucCurrentSearchLevel);
1628   2              TMDS_EQSet_ErrCntInit(phyindex);
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 30  

1629   2          }
1630   1          
1631   1      #else    
                  //EQ setting flow, no need to do when use manual mode
                  if (GetTMDSPHYDATA(phyindex, _DPRXANAIF_AEQ_CFG2) != 0x33) {    
                     TMDS_EQSet_EQSetting(phyindex, _TMDSEQ_S0);
                  }
              #endif
1637   1      }
1638          
1639          void ClearTMDSTraining(void)
1640          {
1641   1          bTMDSClockTraining = TRUE;
1642   1          usTMDSTrainingTimer = GetTimerTick();
1643   1      }
1644          #endif
1645          bit IsTMDSLBR(UCHAR phyindex)
1646          {
1647   1          if (GetTMDSPHYDATA(phyindex, _DP_ANA_CDR_CFG6) & BIT1) {
1648   2              return TRUE;
1649   2          }
1650   1          else {
1651   2              return FALSE;
1652   2          }
1653   1      }
1654          
1655          //******************************************************************************
1656          // Prototype:
1657          //  BOOL CheckTMDSVCOValue(void)
1658          // Parameters:
1659          // Return:
1660          //  BOOL (FALSE : Fail value)
1661          // Purpose:
1662          //  Check TMDS VCO Value is in correct range or not 
1663          // Notes:
1664          //  designer suggest VCO Range ( 0x10 < VCO < 0xF0)
1665          //******************************************************************************
1666          BOOL CheckTMDSVCOValue(void)
1667          {
1668   1      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == ON
                  return TRUE;
              #else
1671   1          UCHAR i, value;
1672   1        UCHAR phyindex = 0;
1673   1      
1674   1      #ifdef ENABLE_FPGA_MODE
                  return TRUE;
              #endif
1677   1      
1678   1      #if IS_NT68870_SERIES
1679   1          phyindex = GetCurrInputInterface();
1680   1        if ((phyindex == DIGITAL_INPUT0) || (phyindex == DIGITAL_INPUT1)) {
1681   2          phyindex = _DPPP_PHY0;
1682   2        }
1683   1        else {
1684   2          phyindex = _DPPP_PHY1;
1685   2        }
1686   1      #endif
1687   1      
1688   1          i = 0;
1689   1          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x02);//check lane1
1690   1          value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 31  

1691   1          //printf("check_lane1=%x\r\n",(int)value);
1692   1          if (value > 0xF0 || value < 0x10) {
1693   2              i++;
1694   2          }
1695   1          
1696   1          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x04);//check lane2
1697   1          value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);
1698   1          //printf("check_lane2=%x\r\n",(int)value);
1699   1      
1700   1          if (value > 0xF0 || value < 0x10) {
1701   2              i++;
1702   2          }
1703   1          
1704   1          SC_SetByteDPppPHY(phyindex, _DPRM_LANE_HI_CFG, 0x08);//check lane3
1705   1          value = GetTMDSPHYDATA(phyindex, _DPRXANAIF_VBS_BASEL);
1706   1          //printf("check_lane3=%x\r\n",(int)value);
1707   1          if (value > 0xF0 || value < 0x10) {
1708   2              i++;
1709   2          }
1710   1      
1711   1          if (i > 0) {
1712   2              return FALSE;
1713   2          }
1714   1          else {
1715   2              return TRUE;
1716   2          }
1717   1      #endif
1718   1      }
1719          
1720          
1721          BOOL CheckTMDSErrorCounter(void)
1722          {
1723   1      #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == ON
                  return TRUE;
              #else
1726   1      #if IS_NT68870_SERIES
1727   1          UCHAR i=0;
1728   1          USHRT value;
1729   1      
1730   1          UCHAR phyindex = 0;
1731   1          BOOL bIsDualDviIn = FALSE;
1732   1      
1733   1          phyindex = GetCurrInputInterface();
1734   1          if ((phyindex == DIGITAL_INPUT0) || (phyindex == DIGITAL_INPUT1)) {
1735   2      #if ENABLE_DVI_DUAL_LINK == ON
1736   2              if (phyindex == DIGITAL_INPUT1 && TMDS_IsDualLink()) {
1737   3                  bIsDualDviIn = TRUE;
1738   3              }
1739   2      #endif
1740   2              phyindex = _DPPP_PHY0;
1741   2          }
1742   1          else {
1743   2              phyindex = _DPPP_PHY1;
1744   2          }
1745   1      
1746   1          i = 0;
1747   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, 0xC0);
1748   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, 0x80);
1749   1          Sleep(20);
1750   1      
1751   1          value = (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH0_HI);
1752   1          value &= 0x7F;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 32  

1753   1          value <<= 8; 
1754   1          value += (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH0_LO);
1755   1          if (value>0x10) {
1756   2              i++;
1757   2          }   
1758   1      
1759   1          value = (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH1_HI);
1760   1          value &= 0x7F;
1761   1          value <<= 8; 
1762   1          value += (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH1_LO);
1763   1          if (value>0x10) {
1764   2              i++;
1765   2          }   
1766   1      
1767   1          value = (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH2_HI);
1768   1          value &= 0x7F;
1769   1          value <<= 8; 
1770   1          value += (USHRT)GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH2_LO);
1771   1          if (value>0x10) {
1772   2              i++;
1773   2          } 
1774   1      
1775   1      #if ENABLE_DVI_DUAL_LINK == ON
1776   1          if (bIsDualDviIn) {
1777   2              SC_SetByteDPppPHY(_DPPP_PHY1, _TMDS_DPHY_ERROR_DET, 0xC0);
1778   2              SC_SetByteDPppPHY(_DPPP_PHY1, _TMDS_DPHY_ERROR_DET, 0x80);
1779   2              Sleep(20);
1780   2      
1781   2              value = (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH0_HI);
1782   2              value &= 0x7F;
1783   2              value <<= 8; 
1784   2              value += (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH0_LO);
1785   2              if (value>0x10) {
1786   3                  i++;
1787   3              }   
1788   2      
1789   2              value = (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH1_HI);
1790   2              value &= 0x7F;
1791   2              value <<= 8; 
1792   2              value += (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH1_LO);
1793   2              if (value>0x10) {
1794   3                  i++;
1795   3              }   
1796   2      
1797   2              value = (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH2_HI);
1798   2              value &= 0x7F;
1799   2              value <<= 8; 
1800   2              value += (USHRT)GetTMDSPHYDATA(_DPPP_PHY1, _TMDS_DPHY_ERRORCNT_CH2_LO);
1801   2              if (value>0x10) {
1802   3                  i++;
1803   3              } 
1804   2          } 
1805   1      #endif
1806   1          if (i > 0) {
1807   2              return FALSE;   
1808   2          }
1809   1          else {
1810   2              return TRUE;
1811   2          } 
1812   1      #else
                  return TRUE;
              #endif
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 33  

1815   1      #endif
1816   1      }
1817          
1818          #if ENABLE_EMBEDED_TMDS_CLOCK_TRAINING == OFF
1819          /**************************************************************************//**
1820           * EQ setting by table
1821           * @Param : 
1822           *        linkidx : TMDS link index
1823           *        level : EQ level 
1824           ******************************************************************************/
1825          static void TMDS_EQSet_EQSetting(UCHAR linkidx, UCHAR level)
1826          {
1827   1          static code UCHAR ucTMDS_EQTable[4][5] = {
1828   1              //142,  149,  14A,  14B,  204
1829   1              {0x33, 0x00, 0x00, 0x00, 0x1F}, // S0 , original S2
1830   1              {0x31, 0x03, 0xFF, 0xFF, 0x18}, // S1 , original S0
1831   1              {0x31, 0x01, 0xFF, 0xFF, 0x18}, // S2 , original S1
1832   1              {0x33, 0x00, 0x01, 0x00, 0x1F}, // S3
1833   1          };
1834   1      //    printf("TMDS_EQSet_EQSetting level = %bx\r\n", level);
1835   1      
1836   1          SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x0E);
1837   1      
1838   1          SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG2, ucTMDS_EQTable[level][0]);
1839   1          SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG3, ucTMDS_EQTable[level][1]);
1840   1          SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG4, ucTMDS_EQTable[level][2]);
1841   1          SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG5, ucTMDS_EQTable[level][3]);
1842   1          SC_SetByteDPppPHY(linkidx, _DPPHY_IMPEDANCE_L1, ucTMDS_EQTable[level][4]);
1843   1      
1844   1      
1845   1      //    if (level == _TMDSEQ_S0) {//original method
1846   1          if (level == _TMDSEQ_S1 || level == _TMDSEQ_S2) {//original method
1847   2              USHRT usTmpD0, usTmpD1, usTmpD2;
1848   2      
1849   2              SC_SetByteDPppPHY(linkidx, _DPPHY_IMPEDANCE_L1, 0x18);
1850   2              
1851   2              if (GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG2) != 0x31) {
1852   3                  SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG2, 0x31);        
1853   3              }
1854   2              Sleep(2);//Sleep(20);
1855   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x02);
1856   2              usTmpD0 = (USHRT) GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG5);
1857   2              usTmpD0 = usTmpD0<<8;
1858   2              usTmpD0 |= GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG4);
1859   2              usTmpD0 = (usTmpD0<<1) | BIT0;
1860   2      
1861   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x04);
1862   2              usTmpD1 = (USHRT) GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG5);
1863   2              usTmpD1 = usTmpD1<<8;
1864   2              usTmpD1 |= GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG4);
1865   2              usTmpD1 = (usTmpD1<<1) | BIT0;
1866   2              
1867   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x08);
1868   2              usTmpD2 = (USHRT) GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG5);
1869   2              usTmpD2 = usTmpD2<<8;
1870   2              usTmpD2 |= GetTMDSPHYDATA(linkidx, _DPRXANAIF_AEQ_CFG4);
1871   2              usTmpD2 = (usTmpD2<<1) | BIT0;
1872   2      
1873   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x0E);        
1874   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG2, 0x33);
1875   2              
1876   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x02);
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 34  

1877   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD0&0x00FF) );
1878   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD0>>8) );
1879   2              
1880   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x04);
1881   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD1&0x00FF) );
1882   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD1>>8) );
1883   2      
1884   2      
1885   2              SC_SetByteDPppPHY(linkidx, _DPRM_LANE_HI_CFG, 0x08);
1886   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG4, (UCHAR) (usTmpD2&0x00FF) );
1887   2              SC_SetByteDPppPHY(linkidx, _DPRXANAIF_AEQ_CFG5, (UCHAR) (usTmpD2>>8) );
1888   2          }
1889   1      
1890   1      }
1891          
1892          /**************************************************************************//**
1893           * Reset/Init the search flow
1894           * @Param : TMDS link index
1895           ******************************************************************************/
1896          void TMDS_EQSet_FlowReset(void)
1897          {
1898   1          stEQSet.ucCurrentSearchLevel = _TMDSEQ_S0;    
1899   1          stEQSet.ucBestLevel = _TMDSEQ_S0;
1900   1          stEQSet.ulBestErrCnt = 0xFFFFFF;   
1901   1          stEQSet.bIsFinish = TRUE;
1902   1      }
1903          
1904          /**************************************************************************//**
1905           * Check the EQ search flow is finish or not
1906           * @Param : TMDS link index
1907           * @Return : TRUE if the searching flow is finished
1908           ******************************************************************************/
1909          #if !lrd_dis
              BOOL TMDS_EQSet_IsFinish(void)
              {
                  return stEQSet.bIsFinish;
              }
              
              /**************************************************************************//**
               * Get the EQ level with lowest error count
               * @Param : TMDS link index
               * @Return : Best level
               ******************************************************************************/
              UCHAR TMDS_EQSet_GetBestLevel(void)
              {
                  return stEQSet.ucBestLevel;
              }
              #endif
1925          /**************************************************************************//**
1926           * Error count init, clear the HW error count 
1927           * @Param : TMDS link index
1928           ******************************************************************************/
1929          static void TMDS_EQSet_ErrCntInit(UCHAR phyindex)
1930          {
1931   1      //    SC_SetByteDPppPHY(phyidx, _TMDS_DPHY_ERROR_DET, 0xC0);
1932   1      //    SC_SetByteDPppPHY(phyidx, _TMDS_DPHY_ERROR_DET, 0x80);
1933   1          UCHAR temp;
1934   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH0_ERROR) | BIT5;
1935   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH0_ERROR, temp);
1936   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH1_ERROR) | BIT5;
1937   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH1_ERROR, temp);
1938   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH2_ERROR) | BIT5;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 35  

1939   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH2_ERROR, temp);
1940   1          
1941   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) | BIT7;
1942   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1943   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) | BIT6;
1944   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1945   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) & ~BIT6;
1946   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1947   1      
1948   1          stEQSet.bIsFinish = FALSE;    
1949   1          usTMDSCheckErrorCntTimer = GetTimerTick();       
1950   1      
1951   1      }
1952          
1953          /**************************************************************************//**
1954           * Get Error count
1955           * @Param : TMDS link index
1956           * @Return : return the error count value by currently EQ settings
1957           ******************************************************************************/
1958          ULONG TMDS_EQSet_GetErrCnt(UCHAR phyindex)
1959          {
1960   1          UCHAR temp;
1961   1          USHRT error;
1962   1          ULONG errorsum;
1963   1      /*
1964   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH0_ERROR) | BIT5;
1965   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH0_ERROR, temp);
1966   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH1_ERROR) | BIT5;
1967   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH1_ERROR, temp);
1968   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH2_ERROR) | BIT5;
1969   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_CH2_ERROR, temp);
1970   1          
1971   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) | BIT7;
1972   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1973   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) | BIT6;
1974   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1975   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) & ~BIT6;
1976   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
1977   1          Sleep(10);
1978   1      */
1979   1      /*
1980   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH0_ERROR);
1981   1          //printf("_TMDS_DPHY_CH0_ERROR=%x\r\n", (USHRT)temp);
1982   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH1_ERROR);
1983   1          //printf("_TMDS_DPHY_CH1_ERROR=%x\r\n", (USHRT)temp);
1984   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_CH2_ERROR);
1985   1          //printf("_TMDS_DPHY_CH2_ERROR=%x\r\n", (USHRT)temp);
1986   1      */
1987   1          errorsum = 0x00;
1988   1          error = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH0_HI) & 0x7F;
1989   1          error <<= 8;
1990   1          error += GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH0_LO);
1991   1          errorsum += error;
1992   1          //printf("_TMDS_DPHY_CH0_ERROR=%x\r\n", (USHRT)error);
1993   1          error = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH1_HI) & 0x7F;
1994   1          error <<= 8;
1995   1          error += GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH1_LO);
1996   1          errorsum += error;
1997   1          //printf("_TMDS_DPHY_CH1_ERROR=%x\r\n", (USHRT)error);
1998   1          error = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH2_HI) & 0x7F;
1999   1          error += GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERRORCNT_CH2_LO);
2000   1          errorsum += error;
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 36  

2001   1          //printf("_TMDS_DPHY_CH2_ERROR=%x\r\n", (USHRT)error);
2002   1          if ((SC_HDMI_CKDT & 0x03) != 0x03) { // 0x606
2003   2              errorsum = 0x00FFFFFF;
2004   2          //printf("_SCDT fail\r\n");
2005   2          }
2006   1          
2007   1          temp = GetTMDSPHYDATA(phyindex, _TMDS_DPHY_ERROR_DET) & ~BIT7;
2008   1          SC_SetByteDPppPHY(phyindex, _TMDS_DPHY_ERROR_DET, temp);
2009   1          return errorsum;
2010   1      }
2011          
2012          /**************************************************************************//**
2013           * TMDS search best EQ settings flow
2014           * Search the best EQ with lowest error count
2015           * @Param : TMDS link index
2016           ******************************************************************************/
2017          void TMDS_EQSet_Flow(void) 
2018          {
2019   1          ULONG errcnt = 0;
2020   1          UCHAR phyindex;
2021   1          
2022   1          if ((SC_HDMI_CKDT & 0x03) != 0x03) { // 0x606
2023   2              return;
2024   2          }
2025   1          if ((stEQSet.bIsFinish == FALSE) && (IsZpMode() == FALSE)) {
2026   2              if (GetTimerTick() - usTMDSCheckErrorCntTimer > TMDSEQ_CHECK_ERROR_CNT_DELAY) {
2027   3                  if ((GetCurrInputInterface() == DIGITAL_INPUT0) || (GetCurrInputInterface() == DIGITAL_INPUT1)
             -) {
2028   4                      phyindex = _DPPP_PHY0;
2029   4                  }
2030   3                  else {
2031   4                      phyindex = _DPPP_PHY1;
2032   4                  }
2033   3                  errcnt = TMDS_EQSet_GetErrCnt(phyindex);
2034   3      //            printf("stEQSet[%bx].ucCurrentSearchLevel go -> %bx , error = %4x\r\n",phyindex, stEQSet.ucC
             -urrentSearchLevel, errcnt);
2035   3      
2036   3                  if (errcnt == 0) {
2037   4      //                printf("finish!\r\n");
2038   4                      stEQSet.ulBestErrCnt = 0;            
2039   4                      stEQSet.ucBestLevel = stEQSet.ucCurrentSearchLevel;
2040   4                      stEQSet.bIsFinish = TRUE;
2041   4                  }
2042   3                  else {
2043   4                      if (errcnt < stEQSet.ulBestErrCnt) {
2044   5      //                    printf("stEQSet.ucBestLevel changed to %bx\r\n", stEQSet.ucCurrentSearchLevel);
2045   5                          stEQSet.ucBestLevel = stEQSet.ucCurrentSearchLevel;
2046   5                          stEQSet.ulBestErrCnt = errcnt;
2047   5                      }
2048   4      
2049   4                      if (stEQSet.ucCurrentSearchLevel == _Num_TMDSEQ-1) {//final level
2050   5                          if (stEQSet.ucBestLevel != _Num_TMDSEQ-1) {
2051   6                              TMDS_EQSet_EQSetting(phyindex, stEQSet.ucBestLevel);
2052   6                          }
2053   5      //                    printf("finish!search over, all not good, ucBestLevel&ulBestErrCnt =[%bx]%x \r\n",st
             -EQSet.ucBestLevel,stEQSet.ulBestErrCnt);
2054   5                          stEQSet.bIsFinish = TRUE;            
2055   5                      }
2056   4                      else {
2057   5                          stEQSet.ucCurrentSearchLevel++;
2058   5                          TMDS_EQSet_EQSetting(phyindex, stEQSet.ucCurrentSearchLevel);
2059   5                          TMDS_EQSet_ErrCntInit(phyindex);
C51 COMPILER V9.54   SCALER_TMDS                                                           01/06/2017 14:56:50 PAGE 37  

2060   5                      }
2061   4                  }
2062   3              }
2063   2          }
2064   1      }
2065          #endif
2066          void TMDSDataAlign(UCHAR phyindex)
2067          {
2068   1          if ((SC_HDMI_CKDT & BIT1) != 0x00) {//CKDT   // 0x606
2069   2              ucTMDSInputMode = GetTMDSPHYDATA(phyindex, _HDMI_MHL_INFO);//hdmi_mhl_info
2070   2              if (ucTMDSInputMode == HDMI_NRM) {//HDMI_NRM
2071   3                  SC_HDMI_DATA_ALIGN &= ~BIT0;  // 0x736
2072   3              }
2073   2              else if (ucTMDSInputMode == HDMI_HSP) {//HDMI_HSP
2074   3                  SC_HDMI_DATA_ALIGN |= BIT0; // 0x736
2075   3              }
2076   2              else {//MHL
2077   3                  if (ucTMDSInputMode == MHL2_PPM) {//PP mode
2078   4                      SC_HDMI_DATA_ALIGN |= BIT0; // 0x736
2079   4                  }
2080   3                  else {
2081   4                      SC_HDMI_DATA_ALIGN &= ~BIT0; // 0x736
2082   4                  }
2083   3              }
2084   2          }
2085   1      }
*** WARNING C294 IN LINE 841 OF Lib\NT68810 Series\Scaler_TMDS.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6198    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =     10      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       7
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
