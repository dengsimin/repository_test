C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCALER_DISPLAY
OBJECT MODULE PLACED IN .\Bin\Scaler_Display.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Lib\NT68810 Series\Scaler_Display.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDI
                    -R(.\App;.\App\OSD;.\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Comp
                    -onent;.\Phy\SI\NVT\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT688
                    -70_MODULE,LVIEW_2560X1440,FLASH_BANK=8) PRINT(.\Lst\Scaler_Display.lst) TABS(2) OBJECT(.\Bin\Scaler_Display.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          #include "ScalerProfile.h"
  14          #if defined(ENABLE_FPGA_MODE)
              #include "FpgaIIC.h"
              #endif
  17          
  18          //******************************************************************************
  19          // M A C R O   D E F I N I T I O N S
  20          //******************************************************************************
  21          
  22          //******************************************************************************
  23          // G L O B A L   V A R I A B L E S
  24          //******************************************************************************
  25          
  26          //******************************************************************************
  27          // S T A T I C   V A R I A B L E S
  28          //******************************************************************************
  29          static xdata ULONG ulDisplayClk; /*!< Variable of display clock. */
  30          static xdata UCHAR ucAspRatioMode = ASP_RATIO_FULL; /*!< Variable of aspect ratio mode. */
  31          static xdata USHRT usDisRatio = 0; /*!< Variable of the ratio of H/V. */
  32          
  33          //******************************************************************************
  34          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  35          //******************************************************************************
  36          extern xdata ULONG ulHFreqCounter;
  37          
  38          //******************************************************************************
  39          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  40          //******************************************************************************
  41          static void SetDPLL(void);
  42          static void CheckInterlacedSignalField(void);
  43          static void SetFixHR2(void);
  44          static void CheckFIFO(void);
  45          #if ENABLE_FREESYNC_DEMO == ON
              static void VCRModeLockPosition(void);
              #endif
  48          
  49          //******************************************************************************
  50          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  51          //******************************************************************************
  52          
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 2   

  53          //******************************************************************************
  54          // F U N C T I O N   B O D Y S
  55          //******************************************************************************
  56          
  57          /**************************************************************************//**
  58           * Initialize display-related registers.
  59           * Through this function, the scaler will be under free-run mode and output black screen.
  60           ******************************************************************************/
  61          void DisplayInit(void)
  62          {
  63   1          SC_FIFO_FLAG = 0x03;
  64   1          SC_FIFO_FLAG_EN = 0x00;
  65   1          EnableDPLL();
  66   1      
  67   1          SC_INTE_CTRL = 0x00;
  68   1          SC_BK_H_SHAP_CTRL |= BIT7;
  69   1          SC_DISP_DRIVE_CTRL = PANEL_PAD_DRIVE;
  70   1          SC_DISPLAY_POL_CTRL = (PANEL_DISP_DE_POL << 7) | (PANEL_DISP_HSYNC_POL << 5) | (PANEL_DISP_VSYNC_POL <
             -< 4);
  71   1      #if PANEL_LVDS_OFFSET == 1
                  SC_DISPLAY_POL_CTRL |= (BIT2 | BIT3);
              #endif
  74   1          SC_DISPLAY_CLK_CTRL = 0x40;
  75   1      
  76   1          SC_DISPLAY_CHANNEL = BIT6;//(BIT5|BIT6);
  77   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
  78   1      #if IS_NT68850_SERIES
                  SC_DP_FAST_MUTE_CTRL = SCREG_B88;
              #else
  81   1          SC_DP_VIDEO_FIFO_INT &= 0x0F;// 0x1044
  82   1      #endif
  83   1      #endif
  84   1      
  85   1          SC_DISP_SWAP = DT16A;
  86   1      
  87   1          SC_GRAPHIC_DISP_WIN_CTRL = 0x07;
  88   1      
  89   1      #if ENABLE_FREESYNC_DEMO == ON
                  SC_VCR_CTRL = 0x11;
                  SC_HR_CTRL = 0x10; 
                  //SC_SOG_DIGITAL_GLITCH_FILTER_THREESHOLD = 0x1F;// bit4:DP fast mute disable, bit3:   ,bit2:     ,bit
             -1:Disable V change fast mute,
                  SC_SOG_DIGITAL_GLITCH_FILTER_THREESHOLD = 0x12;// only need to disable V change fast mute when free-sy
             -nc runing
              #else
  95   1          SC_VCR_CTRL = 0x10;
  96   1          SC_HR_CTRL = 0x00;
  97   1      #endif
  98   1          SC_RESIDUAL_DISP_HOR_SYNC_CTRL = 0x00;
  99   1      
 100   1          SC_FIFO_CTRL1 &= ~BIT6;
 101   1      #if ENABLE_FREESYNC_DEMO == ON
                  SC_FIFO_CTRL1 &= ~BIT5; // 0x190
              #else
 104   1          SC_FIFO_CTRL1 |= BIT5;
 105   1      #endif
 106   1      
 107   1          DisplayMuteImage();
 108   1          LoadDefaultPanelData();
 109   1          SetFreeRunClk();
 110   1          SetDclkSSC(UserPanelData.ucSpreadSpectrumCtrl);
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 3   

 111   1          SC_DITHER_TP_GRAY_LVL_LO = 0x00;
 112   1          SC_DITHER_TP_GRAY_LVL_HI = 0x00;
 113   1      }
 114          
 115          /**************************************************************************//**
 116           * Turn off DPLL (display PLL).
 117           ******************************************************************************/
 118          void DisableDPLL(void)
 119          {
 120   1          UCHAR tmpReg0f0, tmpReg101, tmpReg065;
 121   1          
 122   1          tmpReg0f0 = SC_DPLL_CTRL1;
 123   1          tmpReg101 = SC_POWER_CTRL1;
 124   1          tmpReg065 = SC_GAMMA_CTRL;
 125   1          
 126   1          if ((tmpReg0f0 & BIT0) != 0) {
 127   2              // Do anything necessary here
 128   2              #if ENABLE_GAMMA
 129   2              SC_GAMMA_CTRL = 0x00;
 130   2              #endif    
 131   2              
 132   2              // Disable DPLL sequence
 133   2              SC_POWER_CTRL1 = tmpReg101 | BIT0;
 134   2              SC_DPLL_CTRL1 = tmpReg0f0 & ~BIT0;
 135   2      
 136   2              #if ENABLE_GAMMA
 137   2              SC_GAMMA_CTRL = tmpReg065;
 138   2              #endif    
 139   2          }
 140   1      }
 141          
 142          /**************************************************************************//**
 143           * Turn on DPLL (display PLL).
 144           ******************************************************************************/
 145          void EnableDPLL(void)
 146          {
 147   1          UCHAR tmpReg0f0, tmpReg101, tmpReg065;
 148   1      
 149   1          tmpReg0f0 = SC_DPLL_CTRL1;
 150   1          tmpReg101 = SC_POWER_CTRL1;
 151   1          tmpReg065 = SC_GAMMA_CTRL;
 152   1      
 153   1          if ((tmpReg0f0 & BIT0) == 0) {
 154   2              #if ENABLE_GAMMA
 155   2              SC_GAMMA_CTRL = 0x00;
 156   2              #endif    
 157   2              // Enable DPLL sequence
 158   2              SC_DPLL_CTRL1 = tmpReg0f0 | BIT0;
 159   2              SC_POWER_CTRL1 = tmpReg101 & ~BIT0;
 160   2              Sleep(5);
 161   2      
 162   2              // Do anything necessary here
 163   2              #if ENABLE_GAMMA
 164   2              SC_GAMMA_CTRL = tmpReg065;
 165   2              #endif    
 166   2          }    
 167   1      }
 168          
 169          /**************************************************************************//**
 170           * Turn on DCLK (display clock).
 171           ******************************************************************************/
 172          void EnableDclk(void)
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 4   

 173          {
 174   1          SC_POWER_CTRL1 &= ~BIT0;
 175   1      }
 176          
 177          /**************************************************************************//**
 178           * Initialize display h/v parameters according to the panel spec.
 179           ******************************************************************************/
 180          void LoadDefaultPanelData(void)
 181          {
 182   1      #if ENABLE_FOUR_PORT_LVDS == ON
 183   1      #if PANEL_FOUR_PORT_LVDS == 1
 184   1      code UCHAR panelfourportswaptab[] = {//Port A/B/C/D swap ( pixel swap )
 185   1          2,//000 = ABCD ( 0,1,2,3 ) 
 186   1          3,//001 = ACBD ( 0,2,1,3 ) 
 187   1          0,//010 = DCBA ( 3,2,1,0 ) 
 188   1          1,//011 = DBCA ( 3,1,2,0 ) 
 189   1          6,//100 = CDAB ( 2,3,0,1 ) 
 190   1          7,//101 = BDAC ( 1,3,0,2 ) 
 191   1          4,//110 = BADC ( 1,0,3,2 ) 
 192   1          5,//111 = CADB ( 2,0,3,1 ) 
 193   1      };
 194   1      #endif
 195   1      #endif
 196   1          UCHAR ch;
 197   1          ch = 0x61;
 198   1      
 199   1          if (UserPanelData.bBitShift == TRUE) {
 200   2              ch |= BIT7;
 201   2          }
 202   1          else {
 203   2              ch &= ~BIT7;
 204   2          }
 205   1      #if ENABLE_TEN_BIT_LVDS == ON
 206   1          if (UserPanelData.ucColorDepth == 8) { // 8-bit LVDS output
 207   2              ch &= ~(BIT4|BIT3);
 208   2          }
 209   1          else if (UserPanelData.ucColorDepth == 6) { // 6-bit LVDS output
 210   2              ch &= ~BIT4;
 211   2              ch |= BIT3;
 212   2          }
 213   1          else if (UserPanelData.ucColorDepth == 10) { // 10-bit LVDS output
 214   2              ch &= ~BIT3;
 215   2              ch |= BIT4;
 216   2          }
 217   1          else {
 218   2              ch |= (BIT4|BIT3);
 219   2          }
 220   1      #else
                  if (UserPanelData.ucColorDepth == 8) { // 8-bit LVDS output
                      ch &= ~BIT3;
                  }
                  else {
                      ch |= BIT3;
                  }
              #endif
 228   1          if (UserPanelData.bDualPortLVDS == TRUE) {
 229   2              ch &= ~BIT2;
 230   2          }
 231   1          else {
 232   2              ch |= BIT2;
 233   2          }
 234   1          if (UserPanelData.bDEMode == TRUE) {
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 5   

 235   2              ch |= BIT1;
 236   2          }
 237   1          else {
 238   2              ch &= ~BIT1;
 239   2          }
 240   1      #if ENABLE_FREESYNC_DEMO == ON
                  ch &= ~BIT1;//sync mode
              #endif
 243   1          SC_DISPLAY_CTRL = ch;
 244   1      
 245   1      #if ENABLE_FOUR_PORT_LVDS == ON
 246   1      #if PANEL_FOUR_PORT_LVDS == 1
 247   1          SC_LVDS_CTRL |= BIT1;  // 0x1b8
 248   1          SC_DISP_INTERFACE_CTRL = (PANEL_TEN_BIT_SHIFT << 6) | (panelfourportswaptab[PANEL_FOUR_PORT_SWAP] << 2
             -);// 0x1b9
 249   1      #else
                  SC_DISP_SWAP |= BIT4;  // 0x16a
                  SC_LVDS_CTRL &= ~BIT1;// 0x1b8
              #if LVDS_AB_CD_SWAP == 0
                  SC_DISP_INTERFACE_CTRL = 0x00;//AB port   // 0x1b9
              #else
                  SC_DISP_INTERFACE_CTRL = 0x20;// CD port// 0x1b9
              #endif
              #endif
 258   1      #endif
 259   1      
 260   1          //Display VTotal
 261   1          WriteShortScaler(&SC_DV_TOTAL_LO, UserPanelData.usTypVTotal);
 262   1          //Display VSync Width
 263   1          SC_DV_VS_WID = (UCHAR) UserPanelData.usMinVSyncWidth;
 264   1          //Display Background Window Vertical Begin
 265   1          WriteShortScaler(&SC_DV_BG_BEG_LO, UserPanelData.usMinVSyncWidth + UserPanelData.usMinVSyncBackPorch);
 266   1          //Display Background Window Vertical Length
 267   1          WriteShortScaler(&SC_DV_BG_LEN_LO, UserPanelData.usHeight);
 268   1          //Display Active Window Vertical Begin
 269   1          WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_BEG_LO, UserPanelData.usMinVSyncWidth + UserPanelData.usMinV
             -SyncBackPorch);
 270   1          //Display Active Window Vertical Length
 271   1          WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_LEN_LO, UserPanelData.usHeight);
 272   1          //Display HTotal
 273   1          WriteShortScaler(&SC_DH_HTOTAL_LO, UserPanelData.usTypHTotal);
 274   1          //Display HSync Width
 275   1          SC_DH_HS_WID = (UCHAR) UserPanelData.usMinHSyncWidth;
 276   1          //Display Background Window Horizontal Begin
 277   1          WriteShortScaler(&SC_DH_BG_BEG_LO, UserPanelData.usMinHSyncWidth + UserPanelData.usMinHSyncBackPorch);
 278   1          //Display Background Window Horizontal Width
 279   1          WriteShortScaler(&SC_DH_BG_WID_LO, UserPanelData.usWidth);
 280   1          //Display Active Window Horizontal Begin
 281   1          WriteShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_BEG_LO, UserPanelData.usMinHSyncWidth + UserPanelData.usMinH
             -SyncBackPorch);
 282   1          //Display Active Window Horizontal Width
 283   1          WriteShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_WID_LO, UserPanelData.usWidth);
 284   1          //Free run htotal
 285   1          WriteShortScaler(&SC_FREE_RUN_HTOTAL_LO, PANEL_TYP_HTOTAL);
 286   1      }
 287          
 288          /**************************************************************************//**
 289           * Set free-run clock.
 290           * The clock is panel typical clock defined in panel spec.
 291           * This function set DCLK only and does not turn the scaler to free-run mode.
 292           ******************************************************************************/
 293          void SetFreeRunClk(void)
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 6   

 294          {
 295   1          ulDisplayClk = (UserPanelData.ulFreeRunH_Freq * UserPanelData.usTypHTotal + 5) / 10;
 296   1          SetDPLL();
 297   1      }
 298          
 299          /**************************************************************************//**
 300           * Setup DPLL by ulDisplayClk.
 301           ******************************************************************************/
 302          static void SetDPLL(void)
 303          {
 304   1          ULONG temp;
 305   1      #if 0//((MD_ENABLE_STRESS_TEST_KEY == ON) && (ENABLE_PREFRC == OFF) && (ENABLE_DFR == OFF)
              #if ((MD_ENABLE_STRESS_TEST_KEY == ON) && (PANEL_WIDTH > 1680))
                  if (ulDisplayClk < 200000000) {
                      ulDisplayClk = 200000000;
                  }
              #else
                  if (ulDisplayClk < 160000000) {
                      ulDisplayClk = 160000000;
                  }
              #endif
              #endif
 316   1      //    SC_VPLL_CTRL |= BIT3;
 317   1      #if ENABLE_FREESYNC_DEMO == ON
                  if (bFreeSyncMode == TRUE) {
                      ulDisplayClk = PANEL_MAX_LVDS_CLK;
                  }
              #endif
 322   1          temp = ((float)ulDisplayClk * 131072) / REF_CLK;
 323   1          SC_DDDS_RATIO_LO = (UCHAR) temp;   // 0x0f2
 324   1          SC_DDDS_RATIO_MI = (UCHAR) (temp >> 8);
 325   1          SC_DDDS_RATIO_HI = (UCHAR) (temp >> 16);
 326   1      //    SC_VPLL_CTRL &= ~BIT3;
 327   1      //    SetLvdsP2SByDCLK();
 328   1      #if defined(ENABLE_FPGA_MODE)
                  SetExtDPLL(ulDisplayClk);
              #endif
 331   1      }
 332          
 333          #if ENABLE_LD == ON
              /**************************************************************************//**
               * Setup DPLL to the specified clock.
               * @param clk Display clock. The unit is Hz.
               ******************************************************************************/
              void SetDisplayDCLK(ULONG clk)
              {
                  ulDisplayClk = clk;
                  SetDPLL();
              }
              #endif
 344          
 345          #if ENABLE_LD == ON || ENABLE_PREFRC == ON
              /**************************************************************************//**
               * Get display clock.
               * @return Display clock.
               ******************************************************************************/
              ULONG GetDisplayDCLK(void)
              {
                  return ulDisplayClk;
              }
              #endif
 355          
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 7   

 356          
 357          /**************************************************************************//**
 358           * display clock Compress.
 359           * @param input and display timing
 360           ******************************************************************************/
 361          void DispClkCompress(tTIMING *input,tTIMING *disp)
 362          {
 363   1      #if ENABLE_PREFRC == ON || ENABLE_DFR == ON
                  if (!((GetInputSyncMode() == DIG_SYNC)
              #if ENABLE_PREFRC == ON        
                       && (usVSyncFreq < FRC_NACT_MIN || usVSyncFreq > FRC_NACT_MAX)
              #elif ENABLE_DFR == ON   
                       &&(usVSyncFreq < 310)
              #endif
                     ))
              #endif
 372   1          { 
 373   2             disp->htotal = (UserPanelData.usMinHTotal / 8) * 8 + 8;
 374   2             disp->active_height = (USHRT) (((float)disp->clock / 100 / disp->htotal) * input->active_height / u
             -sHSyncFreq + 0.5);
 375   2             disp->vtotal = ((((ULONG)input->vtotal * disp->active_height) << 4) / input->active_height + 8) >> 
             -4;
 376   2             
 377   2             if (disp->vtotal < UserPanelData.usMinVTotal) {
 378   3                 disp->active_height = (ULONG) UserPanelData.usMinVTotal * input->active_height / input->vtotal;
 379   3             }
 380   2             
 381   2             if (IsInterlaced()) {
 382   3                 disp->active_height >>= 1;
 383   3             }
 384   2            
 385   2             ulDisplayClk = disp->clock;
 386   2          }
 387   1      }
 388          
 389          
 390          
 391          /**************************************************************************//**
 392           * Setup the display timing.
 393           * The function includes:
 394           *  - Display clock calculation.
 395           *  - Panel timing limitation check.
 396           *  - In/out clock check.
 397           *  - Last line (fixed residue) calculation.
 398           * @param htotal50 Current input htotal value.
 399           ******************************************************************************/
 400          BOOL SetupDisplayTiming(USHRT htotal50)
 401          {
 402   1          USHRT i;
 403   1          xdata tTIMING input,disp;
 404   1          
 405   1          UCHAR Reg0x1ED;
 406   1      
 407   1          xdata float temp;
 408   1          BOOL interlace;
 409   1          
 410   1          Reg0x1ED = SC_ADC_BAND_GAP;// 0x1ed
 411   1          SC_ADC_BAND_GAP |= BIT0;
 412   1        htotal50 = 0; // Disable compiler error.
 413   1          SC_DISPLAY_CTRL |= BIT5; //fifo auto lock, auto usHTotal
 414   1          SC_GRAPHIC_DISP_WIN_CTRL = 0x07;
 415   1      
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 8   

 416   1          input.active_width = ReadShortScaler(&SC_GI_CAP_HWID_LO);
 417   1          input.active_height = ReadShortScaler(&SC_GI_CAP_VLEN_LO);
 418   1          if ((input.active_height > 1024) && (input.active_width < 1280)) { //Dual link
 419   2              LoadDefaultPanelData();
 420   2              SetFreeRunClk();
 421   2              return FALSE;
 422   2          }
 423   1      
 424   1          input.vtotal = GetInputVTotal();
 425   1      
 426   1          if (IsInterlaced()) {
 427   2              interlace = TRUE;
 428   2          }
 429   1          else {
 430   2              interlace = FALSE;
 431   2          }
 432   1      
 433   1          disp.active_height = UserPanelData.usHeight; //Set the vertical active height to the Panel Height
 434   1      
 435   1      #if ENABLE_FIT_ALL_PANEL_SPEC == ON
                  disp.vtotal = ((((ULONG)input.vtotal * disp.active_height) << 4) / input.active_height + 8) >> 4;
                  if (disp.vtotal > UserPanelData.usMaxVTotal) {
                      disp.vtotal = UserPanelData.usMaxVTotal;
                      disp.active_height = ((((ULONG)disp.vtotal * input.active_height) << 4) / input.vtotal + 8) >> 4;
                  }
              #endif
 442   1      
 443   1          for (disp.htotal = (UserPanelData.usMinHTotal / 8) * 8 + 8; disp.htotal < UserPanelData.usMaxHTotal; d
             -isp.htotal += 8) {
 444   2              temp = ((float)disp.htotal-0.1) * disp.active_height * 4096 / ulHFreqCounter / input.active_height
             -;
 445   2              ulDisplayClk = (ULONG) (temp * REF_CLK * 16);
 446   2              if (interlace == TRUE) {
 447   3                  ulDisplayClk <<= 1;
 448   3              }
 449   2              if (ulDisplayClk > UserPanelData.ulMinPClk) {
 450   3                  break;
 451   3              }
 452   2          }
 453   1      
 454   1          if (disp.htotal > UserPanelData.usMaxHTotal) { //Htotal too large, dclk too small
 455   2              disp.htotal -= 8;
 456   2          }
 457   1      
 458   1      #if ENABLE_FIT_ALL_PANEL_SPEC == ON
                  if ((ulDisplayClk > UserPanelData.ulMaxPClk) || (ulDisplayClk < UserPanelData.ulMinPClk))  {
                      LoadDefaultPanelData();
                      SetFreeRunClk();
                      return FALSE;
                  }
              #endif
 465   1      
 466   1      #if ENABLE_AUTOFRAMEDOWN == OFF && ENABLE_DFR == OFF && ENABLE_POSTFRC == OFF && ENABLE_CENTER_MODE == OFF
 467   1          if (ulDisplayClk > UserPanelData.ulMaxPClk) {
 468   2              disp.clock = UserPanelData.ulMaxPClk;
 469   2              DispClkCompress(&input,&disp);
 470   2          }
 471   1      #endif
 472   1      
 473   1          WriteShortScaler(&SC_DV_BG_LEN_LO, disp.active_height); //Display Background Vertical Length
 474   1          WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_LEN_LO, disp.active_height); //Display Active Vertical Lengt
             -h
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 9   

 475   1      
 476   1          temp = ((float)disp.htotal-0.1) * disp.active_height * 4096 / ulHFreqCounter / input.active_height;
 477   1          ulDisplayClk = (ULONG) (temp * REF_CLK * 16);
 478   1          
 479   1      #if ENABLE_AUTOFRAMEDOWN == ON
                  FRC_AutoFrameDown(&ulDisplayClk);
              #endif
 482   1      #if ENABLE_POSTFRC == ON
                  FRCConfigPostFRC(PANEL_FRC_OUTPUT_VSYNC, FALSE);
              #endif
 485   1          
 486   1          if (interlace == TRUE) {
 487   2              ulDisplayClk <<= 1;
 488   2          }
 489   1      
 490   1          SetDPLL();
 491   1          Sleep(80);
 492   1      
 493   1          if (CheckModeChangeFlag() == FALSE) {
 494   2              if (interlace == TRUE) { //1080i
 495   3                  i = SC_DISPLAY_CTRL;
 496   3                  SC_DISPLAY_CTRL = (i & ~BIT5); //Manual HTotal
 497   3              }
 498   2              else {
 499   3                  i = ReadShortScalerHighLowFilter(&SC_DSP_HTOTAL_LO) & 0x0FFF;
 500   3                  if (abs(i-disp.htotal) < 5) {
 501   4                      disp.htotal = i;
 502   4                  }
 503   3              }
 504   2              disp.vtotal = (float)ulDisplayClk * 10 / disp.htotal / usVSyncFreq + 0.5;
 505   2              
 506   2              WriteShortScaler(&SC_DV_TOTAL_LO, disp.vtotal); //Display Active Vtotal
 507   2              WriteShortScaler(&SC_DV_BG_BEG_LO, UserPanelData.usMinVSyncWidth + UserPanelData.usMinVSyncBackPor
             -ch); //Display Background VStart
 508   2              i = UserPanelData.usMinVSyncWidth + UserPanelData.usMinVSyncBackPorch + (UserPanelData.usHeight - 
             -disp.active_height) / 2;
 509   2              WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_BEG_LO, i); //Display Active VStart
 510   2              WriteShortScaler(&SC_DH_HTOTAL_LO, disp.htotal); //Display Active Htotal
 511   2      
 512   2              if (disp.active_height != UserPanelData.usHeight) {
 513   3                  i = SC_DISPLAY_CTRL;
 514   3                  SC_DISPLAY_CTRL = (i & ~BIT5); //Manual HTotal
 515   3              }
 516   2          }
 517   1      
 518   1          WriteShortScaler(&SC_DV_BG_LEN_LO, UserPanelData.usHeight); //Display Background Vertical Length
 519   1      
 520   1          // CheckFIFO must be prior to SetFixHR2 because FIFO lock setting!
 521   1          CheckFIFO();
 522   1          
 523   1          CheckInterlacedSignalField();
 524   1      
 525   1          if (CheckModeChangeFlag() == FALSE) {
 526   2      #if ENABLE_FREESYNC_DEMO == OFF && ENABLE_DFR == OFF && ENABLE_POSTFRC == OFF
 527   2              if ((disp.active_height == UserPanelData.usHeight)) {// && (UserPanelData.usHeight < 1440)) {
 528   3                  SetFixHR2();
 529   3              }
 530   2      #endif
 531   2      #if ENABLE_DFR == ON
                      FRCConfigDFR();
              #endif
 534   2          }
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 10  

 535   1          else {
 536   2              LoadDefaultPanelData();
 537   2              SetFreeRunClk();
 538   2          }
 539   1      
 540   1      #if ENABLE_SR == ON
 541   1           SetSRInputTimingParameter();
 542   1      #endif
 543   1      
 544   1          SC_ADC_BAND_GAP = Reg0x1ED;
 545   1          return TRUE;
 546   1      }
 547          
 548          /**************************************************************************//**
 549           * Set the background color of post-pattern.
 550           * @param r Gray level of red color.
 551           * @param g Gray level of green color.
 552           * @param b Gray level of blue color.
 553           ******************************************************************************/
 554          void SetPostBGColor(UCHAR r, UCHAR g, UCHAR b)
 555          {
 556   1          SC_DISP_BACKGROUND_RED = r;
 557   1          SC_DISP_BACKGROUND_GREEN = g;
 558   1          SC_DISP_BACKGROUND_BLUE = b;
 559   1      }
 560          
 561          /**************************************************************************//**
 562           * Set the background color of post pattern, turn the scaler to free-run mode and output post-pattern.
 563           * @param r Gray level of red color.
 564           * @param g Gray level of green color.
 565           * @param b Gray level of blue color.
 566           ******************************************************************************/
 567          void Force2Background(UCHAR r, UCHAR g, UCHAR b)
 568          {
 569   1          if ((SC_DISPLAY_MUTE_CTRL & 0x03) != 0x02) {
 570   2              SetPostBGColor(r, g, b);
 571   2              DisplayMuteImage();
 572   2              LoadDefaultPanelData();
 573   2              SetFreeRunClk();
 574   2          }
 575   1          SC_DISPLAY_CHANNEL = BIT6;//(BIT5|BIT6); //RGB
 576   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
 577   1      #if IS_NT68850_SERIES
                  SC_DP_FAST_MUTE_CTRL = SCREG_B88;
              #else
 580   1          SC_DP_VIDEO_FIFO_INT &= 0x0F;// 0x1044
 581   1      #endif
 582   1      #endif
 583   1      }
 584          
 585          /**************************************************************************//**
 586           * Wait until next display VSync pulse.
 587           * The maximum waiting time is 100ms.
 588           * If the display-related power is off, the default delay time is 40ms.
 589           ******************************************************************************/
 590          void WaitDisVSync(void)
 591          {
 592   1          USHRT temp;
 593   1      
 594   1          // Confirm the scaler has display VSync out or not!
 595   1          if (((SC_POWER_CTRL1 & BIT0) != 0) ||
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 11  

 596   1      #if (!defined(ENABLE_FPGA_MODE))
 597   1              ((SC_DPLL_CTRL1 & BIT0) == 0) ||
 598   1      #endif
 599   1              ((SC_DISPLAY_CTRL & BIT0) == 0)) {
 600   2              Sleep(40);
 601   2              return;
 602   2          }
 603   1      
 604   1          ResetWDTimer();
 605   1          if ((SC_DISPLAY_POL_CTRL & BIT4) == 0x00) {
 606   2              temp = GetTimerTick();
 607   2              while ((GetTimerTick() - temp) < 50) {
 608   3                  if ((SC_DISP_SYNC_STATUS & BIT7) == 0) {
 609   4                      break;
 610   4                  }
 611   3              }
 612   2              while ((GetTimerTick() - temp) < 100) {
 613   3                  if ((SC_DISP_SYNC_STATUS & BIT7) != 0) {
 614   4                      break;
 615   4                  }
 616   3              }
 617   2          }
 618   1          else {
 619   2              temp = GetTimerTick();
 620   2              while ((GetTimerTick() - temp) < 50) {
 621   3                  if ((SC_DISP_SYNC_STATUS & BIT7) != 0) {
 622   4                      break;
 623   4                  }
 624   3              }
 625   2              while ((GetTimerTick() - temp) < 100) {
 626   3                  if ((SC_DISP_SYNC_STATUS & BIT7) == 0) {
 627   4                      break;
 628   4                  }
 629   3              }
 630   2          }
 631   1          ResetWDTimer();
 632   1      }
 633          
 634          /**************************************************************************//**
 635           * Disable display (mute R/G/B data).
 636           ******************************************************************************/
 637          void GraphicDisplayWindowDisable(void)
 638          {
 639   1          SC_DITHER_TOGGLE_CTRL |= BIT7;
 640   1      }
 641          
 642          /**************************************************************************//**
 643           * Enable display (un-mute R/G/B data).
 644           ******************************************************************************/
 645          void GraphicDisplayWindowEnable(void)
 646          {
 647   1          SC_DITHER_TOGGLE_CTRL &= ~BIT7;
 648   1      }
 649          
 650          /**************************************************************************//**
 651           * Check Interlaced Signal Odd/Even Field
 652           ******************************************************************************/
 653          void CheckInterlacedSignalField(void)
 654          {
 655   1      //    xdata UCHAR i,j, *p, matrix[3][6], reg0x1D0;
 656   1          xdata UCHAR ssc_backup, reg0x150, reg0x154,reg0x188;
 657   1          xdata USHRT temp, tmp_ord, tmp_erd;
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 12  

 658   1      
 659   1          if (IsInterlaced()) { //If input is interlaced
 660   2              reg0x154 = SC_DISPLAY_MUTE_CTRL;
 661   2              reg0x150 = SC_DISPLAY_CTRL;
 662   2              reg0x188 = SC_VCR_CTRL;
 663   2      
 664   2              SC_DITHER_TOGGLE_CTRL |= BIT7;
 665   2              //for get data to calculate   
 666   2              SC_DISPLAY_MUTE_CTRL = 0x00;
 667   2       
 668   2              ssc_backup = SC_SSC_CTRL;
 669   2              DisableDclkSSC();
 670   2      //        SC_DISPLAY_MUTE_CTRL = 0x00;
 671   2              if ((SC_INPUT_SELECT & 0x03) < 2) {   //analog
 672   3                  SC_GRAPHIC_DISP_WIN_CTRL = 0x07;
 673   3                  temp = GetInputVStart();
 674   3                  SetEvenFieldOffset(0);
 675   3                  SetVP(5);
 676   3                  DelayVTime(8);//50Hz: over 120ms, 60Hz: over 100ms. 6 times frame
 677   3                  if (abs(ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO) - ReadShortScalerHighLowFilter(&SC_MISC
             -_E_RD_LO)) > 1) {
 678   4                      SetEvenFieldOffset(-1);
 679   4                      SetVP(5);
 680   4                      DelayVTime(8);//50Hz: over 120ms, 60Hz: over 100ms. 6 times frame
 681   4                      if (abs(ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO) - ReadShortScalerHighLowFilter(&SC_
             -MISC_E_RD_LO)) > 1) {
 682   5                          SetEvenFieldOffset(1);
 683   5                          SetVP(5);
 684   5                          DelayVTime(8);//50Hz: over 120ms, 60Hz: over 100ms. 6 times frame
 685   5                      }
 686   4                  }
 687   3                  SetVP(temp);
 688   3                  DelayVTime(8);//50Hz: over 120ms, 60Hz: over 100ms. 6 times frame
 689   3                  if (abs(ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO) - ReadShortScalerHighLowFilter(&SC_MISC
             -_E_RD_LO)) > 1) {
 690   4                      SC_GRAPHIC_DISP_WIN_CTRL = 0x47;
 691   4                  }
 692   3              }
 693   2          #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT
             -_INTERFACE&INPUT_DP3)
 694   2              else if ((SC_INPUT_SELECT & 0x03) == 0x03) {   //displayport
 695   3                  SC_GRAPHIC_DISP_WIN_CTRL = 0x07;
 696   3      #if 1// CEA timing 39: 1920x1080i/50Hz temp solution
 697   3                  if ((GetInputVTotal() > 593) && ((GetVCaptureSize() == 1080) || (GetDigInputVActiveImmediate()
             - == 540))) {            
 698   4                      // CEA timing 39: 1920x1080i/50Hz
 699   4                      SC_GI_SYNC_CTRL3 |= BIT0; // 0x199
 700   4                  }
 701   3                  else {
 702   4                      SC_GI_SYNC_CTRL3 &= ~BIT0; // 0x199
 703   4                  }
 704   3      #endif
 705   3              }
 706   2          #endif
 707   2              else {
 708   3                  SC_GRAPHIC_DISP_WIN_CTRL = 0x07;
 709   3                  if (abs(ReadShortScalerHighLowFilter(&SC_GI_CAP_VBEGO_LO) - ReadShortScalerHighLowFilter(&SC_G
             -I_CAP_VBEGE_LO)) > 0) {
 710   4                      if ((SC_GI_SYNC_CTRL3 & BIT0) == 0x00) { // 0x199
 711   5                          SC_GI_SYNC_CTRL3 |= BIT0; // 0x199
 712   5                          temp = ReadShortScaler(&SC_GI_CAP_VBEGE_LO);
 713   5                          WriteShortScaler(&SC_GI_CAP_VBEGE_LO, ReadShortScaler(&SC_GI_CAP_VBEGO_LO));
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 13  

 714   5                          WriteShortScaler(&SC_GI_CAP_VBEGO_LO, temp);
 715   5                      }
 716   4                  }
 717   3      #if 1// CEA timing 39: 1920x1080i/50Hz temp solution
 718   3                  else if ((GetInputVTotal() > 593) && ((GetVCaptureSize() == 1080) || (GetDigInputVActiveImmedi
             -ate() == 540))) {            
 719   4                      // CEA timing 39: 1920x1080i/50Hz
 720   4                      SC_GI_SYNC_CTRL3 |= BIT0; // 0x199
 721   4                  }
 722   3                  else {
 723   4                      SC_GI_SYNC_CTRL3 &= ~BIT0; // 0x199
 724   4                  }
 725   3      #endif
 726   3      
 727   3                  DelayVTime(8);//50Hz: over 120ms, 60Hz: over 100ms. 6 times frame
 728   3                  tmp_ord = ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO);
 729   3                  tmp_erd = ReadShortScalerHighLowFilter(&SC_MISC_E_RD_LO);
 730   3      
 731   3                  if (abs(ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO) - ReadShortScalerHighLowFilter(&SC_MISC
             -_E_RD_LO)) > 1) {
 732   4                      SC_GRAPHIC_DISP_WIN_CTRL |= BIT6;
 733   4                      DelayVTime(8);
 734   4                      // If the blanking time of odd/even fields are not stable, we switch the settings of odd/e
             -ven position
 735   4                      // Jude 2011/10/18
 736   4                      if ((abs(tmp_ord - ReadShortScalerHighLowFilter(&SC_MISC_O_RD_LO)) > 5) ||
 737   4                          (abs(tmp_erd - ReadShortScalerHighLowFilter(&SC_MISC_E_RD_LO)) > 5)) {
 738   5                          temp = ReadShortScaler(&SC_GI_CAP_VBEGE_LO);
 739   5                          WriteShortScaler(&SC_GI_CAP_VBEGE_LO, ReadShortScaler(&SC_GI_CAP_VBEGO_LO));
 740   5                          WriteShortScaler(&SC_GI_CAP_VBEGO_LO, temp);
 741   5                      }
 742   4                  }
 743   3              }
 744   2              SC_SSC_CTRL = ssc_backup;
 745   2      
 746   2              SC_DISPLAY_MUTE_CTRL = reg0x154;
 747   2              SC_DISPLAY_CTRL = reg0x150;
 748   2              SC_VCR_CTRL = reg0x188;
 749   2              SC_DITHER_TOGGLE_CTRL &= ~BIT7;
 750   2          }
 751   1      }
 752          
 753          /**************************************************************************//**
 754           * Get display vertical DE time.
 755           * @return Number of counts of display clock.
 756           ******************************************************************************/
 757          ULONG GetVCounter(void)
 758          {
 759   1          xdata ULONG vtotalcounter, vtotalcounter2;
 760   1          UCHAR i;
 761   1      
 762   1          vtotalcounter = Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 763   1          DelayVTime(1);
 764   1          vtotalcounter2 = Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 765   1          i=0;
 766   1      
 767   1          while((labs(vtotalcounter - vtotalcounter2) < 0x10) && (i < 3)) {
 768   2              i++;
 769   2              vtotalcounter = Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 770   2              DelayVTime(1);
 771   2              vtotalcounter2 = Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 772   2          }
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 14  

 773   1          
 774   1          vtotalcounter = (vtotalcounter + vtotalcounter2) >> 1;
 775   1      
 776   1          return vtotalcounter;
 777   1      }
 778          
 779          /**************************************************************************//**
 780           * Force the display clock to the one with desired HR2 (count of latest line).
 781           * We use this function to force the display residue to the value we expect.
 782           ******************************************************************************/
 783          void SetFixHR2(void)
 784          {
 785   1      //    xdata UCHAR matrix[3][6], reg0x1D0;
 786   1      //    xdata UCHAR j, *p;
 787   1          xdata UCHAR reg0x150, reg0x154, i,reg0x188;
 788   1          xdata USHRT gdv_act_len, vtotal, cal_hr1, cal_hr2, temp;
 789   1          xdata ULONG vtcnt, vdecnt, tempvtcnt;
 790   1          xdata signed short delta0p9hr1, deltahr2of0p9hr1, hr2of0p9hr1, delta_hr2, dsthtotal, wanted_hr2;
 791   1          xdata signed long delta_clk;
 792   1      
 793   1          reg0x154 = SC_DISPLAY_MUTE_CTRL;
 794   1          reg0x150 = SC_DISPLAY_CTRL;
 795   1          reg0x188 = SC_VCR_CTRL;
 796   1      /*
 797   1          reg0x1D0 = SC_SRGB_CTRL;
 798   1          for (i=0; i<3; i++) {
 799   1              SC_SRGB_CTRL = ((i * 2) + 0x01);
 800   1              p = &SC_SRGB_COEF_R_LO;
 801   1              for (j=0; j<6; j++) {
 802   1                  matrix[i][j] = *p;
 803   1                  *p = 0;
 804   1                  p++;
 805   1              }
 806   1          }
 807   1          SC_SRGB_CTRL = 0x0D;
 808   1      */
 809   1          SC_DITHER_TOGGLE_CTRL |= BIT7;
 810   1          //for get data to calculate   
 811   1          SC_DISPLAY_MUTE_CTRL = 0x00;
 812   1          
 813   1          gdv_act_len = ReadShortScaler(&SC_GRAPHIC_DISP_VER_ACT_LEN_LO);
 814   1          WriteShortScaler(&SC_DV_BG_LEN_LO, gdv_act_len);
 815   1          SC_DISPLAY_CTRL = (reg0x150 | BIT5);
 816   1      
 817   1          // Before HR2 calculation, force HR1 being closed to 0.9 V-active length.
 818   1          temp = ReadShortScalerHighLowFilter(&SC_HR_VALUE_LO);
 819   1          if (temp > (gdv_act_len * 0.9)) {
 820   2              delta0p9hr1 = temp - (gdv_act_len * 0.9);
 821   2          }
 822   1          else {
 823   2              delta0p9hr1 = temp + (gdv_act_len * 0.1);
 824   2          }
 825   1          dsthtotal = ReadShortScalerHighLowFilter(&SC_DSP_HTOTAL_LO) & 0x0FFF;
 826   1          if( (dsthtotal >= UserPanelData.usMinHTotal) && (dsthtotal <= UserPanelData.usMaxHTotal) ){
 827   2            delta_clk = (float) ulDisplayClk * delta0p9hr1 / gdv_act_len / dsthtotal;
 828   2            ulDisplayClk -= delta_clk;
 829   2            SetDPLL();
 830   2          }
 831   1          SC_HR_CTRL = 0x01;
 832   1          SC_VCR_CTRL = 0x06;
 833   1          Sleep(80);
 834   1          if (CheckModeChangeFlag() == FALSE) {
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 15  

 835   2              dsthtotal = 0;
 836   2              vtcnt = 0;
 837   2              vdecnt = 0;
 838   2              for (i=0; i<4; i++) {
 839   3                  SC_VCR_CTRL = 0x06;
 840   3                  DelayVTime(1);
 841   3                  dsthtotal += ReadShortScalerHighLowFilter(&SC_DSP_HTOTAL_LO);
 842   3                  if (IsInterlaced()) { //If input is interlaced
 843   4                      tempvtcnt = GetVCounter();
 844   4                  }
 845   3                  else {
 846   4                      tempvtcnt = Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 847   4      //                printf("tempvtcnt x=%ld\r\n",tempvtcnt);
 848   4                  }
 849   3                  if ((UserPanelData.usWidth == 2560) && (UserPanelData.usHeight == 1440)) {//QHD
 850   4                      if (tempvtcnt < (ULONG)UserPanelData.usWidth * UserPanelData.usHeight) {//0xFFFFF
 851   5                          tempvtcnt += 0x400000;
 852   5                      }
 853   4                  }
 854   3                  vtcnt += tempvtcnt;
 855   3                  SC_VCR_CTRL = 0x02;
 856   3                  vdecnt += Read3ByteScalerHighLowFilter(&SC_VER_COUNTER_LO);
 857   3      //                printf("vdecnt x=%ld\r\n",vdecnt);
 858   3              }    
 859   2              dsthtotal = (dsthtotal + 2) / 4;
 860   2              vtcnt = (vtcnt + 2) / 4;
 861   2      //        printf("vtcnt x=%ld\r\n",vtcnt);
 862   2              vdecnt = (vdecnt + 2) / 4;
 863   2      //        printf("vdecnt x=%ld\r\n",vdecnt);
 864   2              cal_hr1 = vdecnt % gdv_act_len;
 865   2              cal_hr2 = vtcnt % dsthtotal;
 866   2              vtotal = vtcnt / dsthtotal;
 867   2      //        printf("cal_hr1=%d\r\n",cal_hr1);
 868   2      //        printf("cal_hr2=%d\r\n",cal_hr2);
 869   2      //        printf("vtotal=%d\r\n",vtotal);
 870   2      //        printf("dsthtotalx=%d\r\n",dsthtotal);
 871   2      
 872   2              delta0p9hr1 = (gdv_act_len * 0.9) - cal_hr1;
 873   2              deltahr2of0p9hr1 = (float)delta0p9hr1 * vtotal / gdv_act_len;
 874   2              hr2of0p9hr1 = cal_hr2 + deltahr2of0p9hr1;
 875   2      
 876   2      //        printf("delta0p9hr1=%d\r\n",delta0p9hr1);
 877   2      //        printf("deltahr2of0p9hr1=%d\r\n",deltahr2of0p9hr1);
 878   2      //        printf("hr2of0p9hr1=%d\r\n",hr2of0p9hr1);
 879   2      
 880   2              if (hr2of0p9hr1 > (dsthtotal*9/6)) {
 881   3                  wanted_hr2 = dsthtotal*9/6;
 882   3              }
 883   2              else if (hr2of0p9hr1 > (dsthtotal*7/6)) {
 884   3                  wanted_hr2 = dsthtotal*7/6;
 885   3              }
 886   2              else if (hr2of0p9hr1 > (dsthtotal*5/6)) {
 887   3                  wanted_hr2 = dsthtotal*5/6;
 888   3              }
 889   2              else if (hr2of0p9hr1 > (dsthtotal*3/6)) {
 890   3                  wanted_hr2 = dsthtotal*3/6;
 891   3              }
 892   2              else if (hr2of0p9hr1 > (dsthtotal*1/6)) {
 893   3                  wanted_hr2 = dsthtotal*1/6;
 894   3              }
 895   2              else if (hr2of0p9hr1 > -(dsthtotal*1/6)) {
 896   3                  wanted_hr2 = -(dsthtotal*1/6);
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 16  

 897   3              }
 898   2              else if (hr2of0p9hr1 > -(dsthtotal*3/6)) {
 899   3                  wanted_hr2 = -(dsthtotal*3/6);
 900   3              }
 901   2              else {
 902   3                  wanted_hr2 = dsthtotal*1/6;
 903   3              }
 904   2              delta_hr2 = wanted_hr2 - cal_hr2;
 905   2      
 906   2      //        printf("wanted_hr2=%d\r\n",wanted_hr2);
 907   2      //        printf("delta_hr2=%d\r\n",delta_hr2);
 908   2      
 909   2      //        printf("ulDisplayClk w=%ld\r\n",ulDisplayClk);
 910   2              delta_clk = (float)ulDisplayClk * delta_hr2 / vtotal /dsthtotal;
 911   2      //        printf("delta_clk=%ld\r\n",delta_clk);
 912   2              ulDisplayClk +=delta_clk;   //here is for hr2
 913   2      //        printf("ulDisplayClk=%ld\r\n",ulDisplayClk);
 914   2      
 915   2              if (dsthtotal%2) {        //for hr1
 916   3                  ulDisplayClk = (float)ulDisplayClk / dsthtotal * (dsthtotal-1);
 917   3      //            printf("ulDisplayClk x=%ld\r\n",ulDisplayClk);
 918   3                  WriteShortScaler(&SC_DH_HTOTAL_LO, dsthtotal-1); //Display Active Htotal
 919   3              }
 920   2              else {
 921   3                  WriteShortScaler(&SC_DH_HTOTAL_LO, dsthtotal); //Display Active Htotal
 922   3              }
 923   2              SetDPLL();
 924   2      ////////check/////////////////////////////////
 925   2      #if 0
                      SC_DISPLAY_CTRL = (reg0x150 & ~BIT5);
                      SC_HR_CTRL = 0x01;
                      Sleep(80);
                      cal_hr1 = ReadShortScalerHighLowFilter(&SC_HR_VALUE_LO);
                      printf("cal_hr1=%d\r\n", cal_hr1);
                      SC_HR_CTRL = 0x12;
                      Sleep(80);
                      cal_hr2 = ReadShortScalerHighLowFilter(&SC_HR_VALUE_LO);
                      SC_HR_CTRL = 0x00;
                      printf("cal_hr2=%d\r\n", cal_hr2);
                      dsthtotal = ReadShortScalerHighLowFilter(&SC_DSP_HTOTAL_LO);
                      printf("dsthtotaly=%d\r\n",dsthtotal);
              #endif
 939   2      ///////////////////////////////////////////
 940   2          }
 941   1          SC_DISPLAY_MUTE_CTRL = reg0x154;
 942   1          SC_HR_CTRL = 0x00;
 943   1          SC_DISPLAY_CTRL = reg0x150;
 944   1      #if 0
                  if (CheckModeChangeFlag() == FALSE) {
                      Sleep(80);
                      dsthtotal = ReadShortScalerHighLowFilter(&SC_DSP_HTOTAL_LO);
                      WriteShortScaler(&SC_DH_HTOTAL_LO, dsthtotal); //Display Active Htotal
                      printf("dsthtotalz=%d\r\n",dsthtotal);
                  }
              #endif
 952   1          WriteShortScaler(&SC_DV_BG_LEN_LO, UserPanelData.usHeight);
 953   1          SC_VCR_CTRL = reg0x188;
 954   1      /*
 955   1          for (i=0; i<3; i++) {
 956   1              SC_SRGB_CTRL = ((i * 2) + 0x01);
 957   1              p = &SC_SRGB_COEF_R_LO;
 958   1              for (j=0; j<6; j++) {
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 17  

 959   1                  *p = matrix[i][j];
 960   1                  p++;
 961   1              }
 962   1          }
 963   1          SC_SRGB_CTRL |= BIT3;
 964   1          SC_SRGB_CTRL = reg0x1D0;
 965   1      */
 966   1          SC_DITHER_TOGGLE_CTRL &= ~BIT7;
 967   1      }
 968          
 969          /**************************************************************************//**
 970           * Get display h/v ratio.
 971           * E.x. 0 means full screen.
 972           *      1333 means 4:3.
 973           *      1250 means 5:4.
 974           *      1600 means 16:10.
 975           * @return Display h/v ratio.
 976           ******************************************************************************/
 977          /*
 978          USHRT GetCustomDspRatio(void)
 979          {
 980              return usDisRatio;
 981          }
 982          */
 983          
 984          /**************************************************************************//**
 985           * Set display h/v ratio.
 986           * ratio : Range is "less then 1000", or "1000 to 65535".
 987           *         E.x. If aspect ratio is full screen, ratio is "less then 1000". 0 is preferred.
 988           *              If aspect ratio is 16:10, ratio is 1600.
 989           *              If aspect ratio is 5:4, ratio is 1250.
 990           *              If aspect ratio is 4:3, ratio is 1333.
 991           * @param ratio Display h/v ratio.
 992           ******************************************************************************/
 993          void SetCustomAspRatio(USHRT ratio)
 994          {
 995   1          USHRT dh_bg_beg, width, begin;
 996   1      
 997   1          usDisRatio = ratio;
 998   1          dh_bg_beg = ReadShortScaler(&SC_DH_BG_BEG_LO);
 999   1      
1000   1          if (ratio < 1000) {
1001   2              width = UserPanelData.usWidth;
1002   2              begin = dh_bg_beg;
1003   2          }
1004   1          else {
1005   2              width = ((ULONG)UserPanelData.usHeight * ratio + 500) / 1000;
1006   2              width &= 0xFFFE; // Force active width being even
1007   2              if (width > UserPanelData.usWidth) width = UserPanelData.usWidth;
1008   2              begin = dh_bg_beg + (UserPanelData.usWidth - width) / 2;
1009   2          }
1010   1      
1011   1      #if 1
1012   1          if ((begin != ReadShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_BEG_LO)) ||
1013   1              (width != ReadShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_WID_LO))) {
1014   2      #else
                  {
              #endif
1017   2              WaitDisVSync();
1018   2              GraphicDisplayWindowDisable();
1019   2              WriteShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_BEG_LO, begin);
1020   2              WriteShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_WID_LO, width);
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 18  

1021   2              Sleep(80);
1022   2              WaitDisVSync();
1023   2              GraphicDisplayWindowEnable();
1024   2          }
1025   1      }
1026          
1027          /**************************************************************************//**
1028           * Set display ratio by mode.
1029           * If the mode is
1030           *   ASP_RATIO_FULL  : Display full screen.
1031           *   ASP_RATIO_SCALE : Keep org. display ratio.
1032           *   ASP_RATIO_4_3   : Force display ratio to 4:3.
1033           *   ASP_RATIO_SMART_4_3 : Force display ratio to 4:3 if input ratio is small 16:10.
1034           *   ASP_RATIO_REAL  : pixel by pixel.
1035           * @param aspectmode Aspect ratio mode.
1036           ******************************************************************************/
1037          void SetDisplayMode(AspectRatio aspectmode)
1038          {
1039   1          USHRT input_vactive, input_hactive, ratio;
1040   1      
1041   1          ucAspRatioMode = aspectmode;
1042   1          if ((SC_INPUT_SELECT & 0x03) < 2) {   //analog
1043   2              input_vactive = InputTiming.usModeVActive; 
1044   2              input_hactive = InputTiming.usModeHActive; //for double sampling (ucSampling)
1045   2          }
1046   1          else {    
1047   2              input_vactive = ReadShortScaler(&SC_GI_CAP_VLEN_LO);
1048   2              input_hactive = ReadShortScaler(&SC_GI_CAP_HWID_LO);
1049   2          }
1050   1      
1051   1      
1052   1          if (aspectmode == ASP_RATIO_SMART_4_3) {
1053   2              ratio = input_hactive * 10 / input_vactive;
1054   2              if (ratio < 16)
1055   2                  aspectmode = ASP_RATIO_4_3;
1056   2              else
1057   2                  aspectmode = ASP_RATIO_FULL;
1058   2          }
1059   1      
1060   1          if (aspectmode == ASP_RATIO_4_3) {
1061   2              ratio = 1333;
1062   2          }
1063   1          else if (aspectmode == ASP_RATIO_SCALE) {
1064   2              ratio = ((ULONG) input_hactive * 1000 + input_vactive / 2)
1065   2                      / input_vactive;
1066   2          }
1067   1          else if (aspectmode == ASP_RATIO_REAL) {
1068   2              ratio = 0;
1069   2          }
1070   1          else { //Full screen
1071   2              ratio = 0;
1072   2          }
1073   1      
1074   1          SetCustomAspRatio(ratio);
1075   1          
1076   1      #if ENABLE_CENTER_MODE == ON
              //    if ((aspectmode == ASP_RATIO_REAL) && (input_hactive <= 1920) && (input_vactive <= 1080)) {
                  if ((InputTiming.usModeHActive <= 1920) && (InputTiming.usModeVActive <= 1080) && (InputTiming.usVSync
             -Freq > 450)) {
              //    if ((input_hactive < 1920) && (input_vactive < 1080)) {
              //        WaitDisVSync();
                      GraphicDisplayWindowDisable();
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 19  

                      if (aspectmode == ASP_RATIO_REAL) {
                          SetCenterMode();
                      ///////////////////////check MMU BW
                          if ((InputTiming.usModeHActive == 1920) && (InputTiming.usModeVActive == 1080)) {
                              ODAPI_DisableOD();
                          }
                      ///////////////////////////////
                      }
                      else {
                          DisableCenterMode();
                          WriteShortScaler(&SC_DH_BG_WID_LO, UserPanelData.usWidth);
                          WriteShortScaler(&SC_DV_BG_LEN_LO, UserPanelData.usHeight);
                          WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_LEN_LO, UserPanelData.usHeight);
                          if (aspectmode == ASP_RATIO_FULL) {
                              WriteShortScaler(&SC_GRAPHIC_DISP_HOR_ACT_WID_LO, UserPanelData.usWidth);
                          }
                          SetDPLL();
                      }
                      Sleep(80);
                      WaitDisVSync();
                      GraphicDisplayWindowEnable();
                  }
              #endif
1105   1      }
1106          
1107          /**************************************************************************//**
1108           * Setup aspect ratio and enable scaler fast mute function.
1109           ******************************************************************************/
1110          void NormalDisplay(void)
1111          {
1112   1          UCHAR currentinterface = GetCurrInputInterface();
1113   1      //    SC_DITHER_TP_GRAY_LVL_LO = 0x00;
1114   1      //    SC_DITHER_TP_GRAY_LVL_HI = 0x00;
1115   1          SC_DITHER_TOGGLE_CTRL |= BIT7;
1116   1      #if (!defined(ENABLE_FPGA_MODE))
1117   1      //#if ENABLE_FREESYNC_DEMO == OFF   // 20160202 Yung mask
1118   1          SC_DISPLAY_CHANNEL |= BIT7;
1119   1      //#endif
1120   1      #endif
1121   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
1122   1          if ((currentinterface == DISPLAY_PORT_INPUT) || (currentinterface == DISPLAY_PORT_INPUT1)
1123   1           || (currentinterface == DISPLAY_PORT_INPUT2) || (currentinterface == DISPLAY_PORT_INPUT3)) {
1124   2      #if IS_NT68850_SERIES
                      SC_DP_FAST_MUTE_CTRL |= 0x0B;
              #else
1127   2              SC_DP_VIDEO_FIFO_INT |= 0x70;// 0x1044
1128   2      #endif
1129   2          }
1130   1      #endif
1131   1          SC_DISPLAY_MUTE_CTRL = 0x00;
1132   1          //SetDisplayMode(ucAspRatioMode);
1133   1          UserSetAspectRatio();
1134   1          SetPostBGColor(0x00, 0x00, 0x00); // Set black color to avoid unexpected color from user-level burn-in
             - mode.
1135   1          Sleep(40);
1136   1          if ((SC_INPUT_SELECT & 0x03) < 2) { //analog
1137   2              WaitHPLLstable();
1138   2              HwAutoOffset();
1139   2              if ((SC_GI_SYNC_CTRL & 0x03) == 0x01) {
1140   3                  SC_HPLL_FREQ_CTRL |= BIT6; //Disable updating HS_CNT// 0xd1
1141   3              }
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 20  

1142   2          }
1143   1      
1144   1          // Reduce time to detect overflow when input HSync is varied.
1145   1          SetupHSyncOverflowMask(TRUE);
1146   1          
1147   1      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
1148   1          if ((currentinterface == DISPLAY_PORT_INPUT) || (currentinterface == DISPLAY_PORT_INPUT1)
1149   1           || (currentinterface == DISPLAY_PORT_INPUT2) || (currentinterface == DISPLAY_PORT_INPUT3)) {
1150   2              SC_DP_CSC_AUTO_CONF |= 0xC0; // 0x1040
1151   2              SC_DP_VIDEO_FIFO_INT |= 0x03;// 0x1044
1152   2          }
1153   1      #endif
1154   1      }
1155          
1156          /**************************************************************************//**
1157           * Configure post-pattern and turn it on (display free-run).
1158           ******************************************************************************/
1159          void DisplayPostPattern(UCHAR pattern)
1160          {
1161   1          SC_DISPLAY_MUTE_CTRL = pattern | 0x01;
1162   1      }
1163          
1164          /**************************************************************************//**
1165           * Mute display with OSD enabled (display free-run).
1166           ******************************************************************************/
1167          void DisplayMuteImage(void)
1168          {
1169   1          SC_DISPLAY_MUTE_CTRL = 0x02;
1170   1      }
1171          
1172          /**************************************************************************//**
1173           * Turn the scaler to normal display.
1174           ******************************************************************************/
1175          void DisplayNormalImage(void)
1176          {
1177   1          WaitDisVSync();
1178   1          SC_DITHER_TOGGLE_CTRL &= ~BIT7;
1179   1      }
1180          
1181          /**************************************************************************//**
1182           * Enable SSC.
1183           ******************************************************************************/
1184          void EnableDclkSSC(void)
1185          {
1186   1      #if ENABLE_EDP == OFF
1187   1          if (UserPanelData.bEnableSSC) {
1188   2              SC_SSC_CTRL |= BIT0;
1189   2          }
1190   1          else {
1191   2              SC_SSC_CTRL &= ~BIT0;
1192   2          }
1193   1      #endif
1194   1      }
1195          
1196          /**************************************************************************//**
1197           * Disable SSC.
1198           ******************************************************************************/
1199          void DisableDclkSSC(void)
1200          {
1201   1          SC_SSC_CTRL &= ~BIT0;
1202   1      }
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 21  

1203          
1204          /**************************************************************************//**
1205           * Set SSC ratio.
1206           * @param ratio SSC ratio.
1207           ******************************************************************************/
1208          void SetDclkSSCRatio(UCHAR ratio)
1209          {
1210   1      #if ENABLE_SCALER_NEW_SSC == ON
1211   1          UCHAR tmpratio, tmplevel;
1212   1      
1213   1          tmpratio = ratio >>4;
1214   1          tmplevel = ratio & 0x0F;;
1215   1      
1216   1          if (tmpratio == 0) {
1217   2              tmpratio = 15;
1218   2          }
1219   1          else {
1220   2              tmpratio = tmpratio -1;
1221   2          }
1222   1      
1223   1          if (tmplevel == 0) {
1224   2              SC_SSC_FMOD = (USHRT)((32768UL*(PANEL_DCLK_NEW_SSC_RANGE - tmpratio)/1000/63));
1225   2          }else{
1226   2              SC_SSC_FMOD = (USHRT)((32768UL*(PANEL_DCLK_NEW_SSC_RANGE - tmpratio)/1000/(tmplevel*4))/4*4);
1227   2          }
1228   1      #else
                  SC_SSC_CTRL = (SC_SSC_CTRL & 0xE1) | ratio;
              #endif
1231   1          SC_MPLL_B2C = 0x00;
1232   1      }
1233          
1234          /**************************************************************************//**
1235           * Set SSC frequency.
1236           * @param freq SSC frequency.
1237           ******************************************************************************/
1238          void SetDclkSSCFreq(UCHAR freq)
1239          {
1240   1      #if ENABLE_SCALER_NEW_SSC == ON
1241   1          if ((freq&0x0F) == 0) {
1242   2             SC_SSC_FDEV = (SC_SSC_FDEV & ~0x3F) | (63);
1243   2          }
1244   1          else {
1245   2          SC_SSC_FDEV = (SC_SSC_FDEV & ~0x3F) | ((freq&0x0F)*4);
1246   2          }
1247   1      #else
                  SC_SSC_CTRL = (SC_SSC_CTRL & 0x1F) | freq;
              #endif
1250   1          SC_MPLL_B2C = 0x00;
1251   1      }
1252          
1253          /**************************************************************************//**
1254           * Set both SSC ratio and frequency and turn SSC on.
1255           * @param value Combinational value of SSC ratio and frequency.
1256           ******************************************************************************/
1257          void SetDclkSSC(UCHAR value)
1258          {
1259   1          SetDclkSSCRatio(value);
1260   1          SetDclkSSCFreq(value);
1261   1      
1262   1      #if ENABLE_SCALER_NEW_SSC == ON
1263   1          if (UserPanelData.bEnableSSC) {
1264   2              SC_SSC_FDEV |= BIT7;
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 22  

1265   2          }
1266   1          else {
1267   2              SC_SSC_FDEV &= ~BIT7;
1268   2          }
1269   1      #endif   
1270   1      
1271   1          EnableDclkSSC();
1272   1      }
1273          
1274          #if ENABLE_SCALER_NEW_SSC == ON
1275          /**************************************************************************//**
1276           * Set SSC level for factory setting
1277           * @param value 16 step : 1~16       
1278           ******************************************************************************/
1279           
1280          #if !lrd_dis
              void ConfigSSClevel(UCHAR level)
              {
                  if (level == 16) {
                    UserPanelData.ucSpreadSpectrumCtrl = (UserPanelData.ucSpreadSpectrumCtrl & 0xF0);         
                  }
                  else {
                      UserPanelData.ucSpreadSpectrumCtrl = (UserPanelData.ucSpreadSpectrumCtrl & 0xF0) | level;
                  }
                  
                  SetDclkSSC(UserPanelData.ucSpreadSpectrumCtrl);
              }
              
              /**************************************************************************//**
               * Set SSC Range for factory setting
               * @param value 16 step : 1~16 (unit 0.1%)
               * SSC Range = Target SSC - (0.1*step)       
               ******************************************************************************/
              void ConfigSSCRange(UCHAR Range)
              {
                  if (Range == 16) {
                      UserPanelData.ucSpreadSpectrumCtrl = (UserPanelData.ucSpreadSpectrumCtrl & 0x0F);      
                  }
                  else {
                      UserPanelData.ucSpreadSpectrumCtrl = (UserPanelData.ucSpreadSpectrumCtrl & 0x0F) | Range << 4;
                  }
                  
                  SetDclkSSC(UserPanelData.ucSpreadSpectrumCtrl);
              } 
              #endif
1310          /**************************************************************************//**
1311           * Get Target SSC Range.
1312           * @param value unit 0.01%
1313           * Ex. 16 -> 1.6 %
1314           ******************************************************************************/
1315          
1316          #if !lrd_dis
              UCHAR GetTargetSSCRange(void)
              {
                  UCHAR ucsscrange = (UserPanelData.ucSpreadSpectrumCtrl >> 4);
                  if (ucsscrange == 0) {
                      return PANEL_DCLK_NEW_SSC_RANGE - 15;
                  }
                  else {
                      return (PANEL_DCLK_NEW_SSC_RANGE - (ucsscrange-1));
                  }
              }
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 23  

              /**************************************************************************//**
               * Get New SSC value for definiton ENABLE_SCALER_NEW_SSC 
               ******************************************************************************/
              UCHAR GetPanelDclkNewSSC(void)
              {
                  return UserPanelData.ucSpreadSpectrumCtrl;
              }
              #endif
1335          
1336          /**************************************************************************//**
1337           * Get Current SSC frequency. 
1338           * @param value unit 0.1kHz
1339           * Ex. 468 -> 46.8k Hz
1340           ******************************************************************************/
1341          #if !lrd_dis
              USHRT GetSSCFreq(void)
              {
                  return (USHRT)(REF_CLK/200/(SC_SSC_FDEV&0x3F)/4); //Unit 0.1kHz;
              } 
              
              /**************************************************************************//**
               * Get Current SSC Range.
               * @param value unit 0.01%
               * Ex. 156 -> 1.56 %
               ******************************************************************************/
              USHRT GetSSCRange(void)
              {    
                  return (USHRT)(((ULONG)(SC_SSC_FDEV&0x3F))*SC_SSC_FMOD*10000/32768);//Unit 0.01%;
              }
              #endif
1357          #endif
1358          
1359          /**************************************************************************//**
1360           * Set FIFO to manual lock mode if input timing is interlaced or vertical scaling down.
1361           ******************************************************************************/
1362          void CheckFIFO(void)
1363          {
1364   1      //    UCHAR backup, fifo_v;
1365   1          USHRT fifo_h;//, temp, input_vactive;
1366   1      #if IS_NT68850_SERIES || IS_NT68790_SERIES || IS_NT68658_SERIES || IS_NT68810_SERIES || IS_NT68870_SERIES
1367   1          SC_DISPLAY_HLOCK_HI &= 0x0F;
1368   1      #endif
1369   1      
1370   1          if (IsInterlaced()) { //If input is interlaced. FIFO -= half htotal
1371   2              if ((GetInputVTotal() > 593) && ((GetVCaptureSize() == 1080) || (GetDigInputVActiveImmediate() == 
             -540))) {            
1372   3                  // CEA timing 39: 1920x1080i/50Hz
1373   3                  SC_DISPLAY_VLOCK = 1;
1374   3                  fifo_h = ReadShortScaler(&SC_DISPLAY_HLOCK_LO) & 0xF000;
1375   3                  WriteShortScaler(&SC_DISPLAY_HLOCK_LO, fifo_h);
1376   3                  SC_DISPLAY_CTRL &= ~BIT6;
1377   3                  SC_DISP_DRIVE_CTRL &= ~BIT7;
1378   3              }
1379   2              else {
1380   3                  SC_DISPLAY_CTRL |= BIT6;
1381   3                  SC_DISP_DRIVE_CTRL |= BIT7;
1382   3              }
1383   2          }
1384   1          else {
1385   2      #if IS_NT68850_SERIES || IS_NT68790_SERIES || IS_NT68658_SERIES || IS_NT68810_SERIES || IS_NT68870_SERIES
1386   2          #if PANEL_WIDTH == 2560 && PANEL_HEIGHT == 1440
1387   2              if ((GetHCaptureSize() >= 800) &&(GetVCaptureSize() >= 600)) {// >= 800x600
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 24  

1388   3          #else
                      if (!((GetHCaptureSize() == 720) &&(GetVCaptureSize() == 288) && (abs(GetInputVFreq() - 500) < 10)
             -)) {// !720x288_50Hz
                  #endif
1391   3                  SC_DISPLAY_HLOCK_HI |= BIT5;
1392   3              }
1393   2      #endif
1394   2      #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
1395   2              if (SC_FRC_CTRL != 0x00) { // DFR, FRC
1396   3                  SC_DISPLAY_VLOCK = 1;
1397   3                  fifo_h = ReadShortScaler(&SC_DISPLAY_HLOCK_LO) & 0xF000;
1398   3                  WriteShortScaler(&SC_DISPLAY_HLOCK_LO, fifo_h);
1399   3                  SC_DISPLAY_CTRL &= ~BIT6;
1400   3                  SC_DISP_DRIVE_CTRL &= ~BIT7;
1401   3              }
1402   2              else
1403   2      #endif
1404   2              {
1405   3                  SC_DISPLAY_CTRL |= BIT6;
1406   3                  SC_DISP_DRIVE_CTRL &= ~BIT7;
1407   3              }
1408   2          }
1409   1      #if ENABLE_FREESYNC_DEMO == ON
              //    if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT) || (GetCurrInputInterface() == DISPLAY_PORT_INPU
             -T1)) {
                  if (bFreeSyncMode == TRUE) {
                      VCRModeLockPosition();
                  }
              #endif
1415   1      }
1416          
1417          #if ENABLE_FREESYNC_DEMO == ON
              /**************************************************************************//**
               * Set VCR mode lock position by display window vbeg.
               ******************************************************************************/
              void VCRModeLockPosition(void)
              {
                  USHRT temp, lock_v, lock_h;
                  USHRT input_htotal, input_clk;
                  USHRT dis_htotal;
              
              #if (INPUT_INTERFACE&INPUT_DP) || (INPUT_INTERFACE&INPUT_DP1) || (INPUT_INTERFACE&INPUT_DP2) || (INPUT_INT
             -ERFACE&INPUT_DP3)
                  if ((GetCurrInputInterface() == DISPLAY_PORT_INPUT) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT1
             -) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT2) || (GetCurrInputInterface() == DISPLAY_PORT_INPUT3)) {
                      input_htotal = GetDigInputHTotalImmediate();
                      input_clk = DP_GetClock();
                  }
                  else 
              #endif
                  {
                      if (GetInputSyncMode() == DIG_SYNC){
                          input_htotal = GetDigInputHTotalImmediate();
                          input_clk = TMDS_GetClock();
                      }
                      else{
                          input_htotal = InputTiming.usHTotal;
                          input_clk = (ULONG)GetInputHFreq() * input_htotal/10000;
                      }
                  }
                
C51 COMPILER V9.54   SCALER_DISPLAY                                                        01/06/2017 14:56:57 PAGE 25  

                  dis_htotal = ReadShortScaler(&SC_DH_HTOTAL_LO);
              
                  if ((SC_VCR_CTRL & BIT0) != 0x00) { //enable VCR mode   
                      temp = ReadShortScalerHighLowFilter(&SC_DISP_HLOCK_POS_R);
                      lock_v = temp >> 13;
                      lock_h = temp & 0x1FFF;
              
                      lock_h = (ULONG)(lock_h + lock_v * input_htotal) * (ulDisplayClk / 1000000) / input_clk;
                      lock_v = lock_v + (lock_h / dis_htotal) + 1;
                      if (lock_v == 1) {
                          lock_v++;
                      }
                      WriteShortScaler(&SC_DV_BG_BEG_LO, lock_v);
                      WriteShortScaler(&SC_GRAPHIC_DISP_VER_ACT_BEG_LO, lock_v);
                      
                      SC_DV_VS_WID = 1; //V begin force to 1
                  }
              }
              
              void SetFreeSyncMode(void)
              {
                  bFreeSyncMode = IsFreeSyncMode();
                  if (bFreeSyncMode == TRUE) {
                      SC_VCR_CTRL = 0x11;
                      SC_HR_CTRL = 0x10; 
                      SC_SOG_DIGITAL_GLITCH_FILTER_THREESHOLD = 0x12;// only need to disable V change fast mute when fre
             -e-sync runing
                      SC_FIFO_CTRL1 &= ~BIT5; // 0x190
                      SC_SYNC_INT_EN1 = 0x1C;
                  }
                  else {
                      SC_VCR_CTRL = 0x10;
                      SC_HR_CTRL = 0x00;
                      SC_SOG_DIGITAL_GLITCH_FILTER_THREESHOLD = 0x00;
                      SC_FIFO_CTRL1 |= BIT5;
                      SC_SYNC_INT_EN1 = 0x3C;
                  }
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5866    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      7     122
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
