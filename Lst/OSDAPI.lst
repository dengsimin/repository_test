C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE OSDAPI
OBJECT MODULE PLACED IN .\Bin\OSDAPI.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Lib\NT68810 Series\OSDAPI.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\App;
                    -.\App\OSD;.\App\User;.\Lib;.\Lib\NT68810 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Component;.\
                    -Phy\SI\NVT\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68870_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68870,NT68870_MODUL
                    -E,LVIEW_2560X1440,FLASH_BANK=8) PRINT(.\Lst\OSDAPI.lst) TABS(2) OBJECT(.\Bin\OSDAPI.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
  13          //******************************************************************************
  14          // M A C R O   D E F I N I T I O N S
  15          //******************************************************************************
  16          
  17          
  18          
  19          //******************************************************************************
  20          // G L O B A L   V A R I A B L E S
  21          //******************************************************************************
  22          
  23          //******************************************************************************
  24          // S T A T I C   V A R I A B L E S
  25          //******************************************************************************
  26          xdata UCHAR ucOSDConfig = (OSD_POS_ROT_OFF << 2) | OSD_ALIGN_LEFT; /*!< Variable for OSD indent status and
             - OSD rotation status. */
  27          xdata USHRT usOSDWinRotStatus = 0x0000; /*!< Rotation status of each OSD window. */
  28          static xdata UCHAR ucOSDFontHeight; /*!< Variable for OSD font height. */
  29          static xdata UCHAR ucOSDFontWidth;  /*!< Variable for OSD font width. */
  30          static xdata UCHAR ucOSDHeight;     /*!< Variable for OSD height. Unit is OSD font height. */
  31          static xdata UCHAR ucOSDWidth;      /*!< Variable for OSD width. Unit is OSD font width. */
  32          static xdata UCHAR ucWinUnitWidth;  /*!< Variable for the pixel number of the unit of OSD window width. */
  33          static xdata UCHAR ucWinUnitHeight; /*!< Variable for the pixel number of the unit of OSD window height. *
             -/
  34          xdata UCHAR OSDtimes ;
  35          
  36          //******************************************************************************
  37          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  38          //******************************************************************************
  39          
  40          //******************************************************************************
  41          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  42          //******************************************************************************
  43          static void OSDAPI_RotateOSDWinPosition(USHRT sx, USHRT sy, USHRT ex, USHRT ey, OSDWinDegree degree, UCHAR
             - rot);
  44          
  45          //******************************************************************************
  46          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  47          //******************************************************************************
  48          
  49          //******************************************************************************
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 2   

  50          // F U N C T I O N   B O D Y S
  51          //******************************************************************************
  52          
  53          /**************************************************************************//**
  54           * Set 1/2/3/4-bits OSD font start address in OSD sram.
  55           * @param type Bits size per font.
  56           * @param addr Start address of x-bits OSD font.
  57           ******************************************************************************/
  58          
  59          void OSDAPI_GetAttribute(USHRT i)
  60          {
  61   1          UCHAR dummy;
  62   1          SC_INDEX_CTRL = 0x88;
  63   1          SC_INDEX_ADDR_LO = i & 0xFF;
  64   1          SC_INDEX_ADDR_HI = (i >> 8) & 0xFF;
  65   1          dummy = SC_INDEX_DATA;
  66   1          dummy = SC_INDEX_DATA;
  67   1          dummy = SC_INDEX_DATA;
  68   1      }
  69          
  70          void OSDAPI_SetFontAddress(OSDFontBits type, USHRT addr)
  71          {
  72   1          switch (type) {
  73   2              case OSD_FONTBITS_1b:
  74   2                  SC_OSD_FONT1B_ADDR_LO = addr & 0x00ff;
  75   2                  SC_OSD_FONT1B_ADDR_HI = (addr & 0xff00) >> 8;
  76   2                  break;
  77   2              case OSD_FONTBITS_2b:
  78   2                  SC_OSD_FONT2B_ADDR_LO = addr & 0x00ff;
  79   2                  SC_OSD_FONT2B_ADDR_HI = (addr & 0xff00) >> 8;
  80   2                  break;
  81   2              case OSD_FONTBITS_3b:
  82   2                  SC_OSD_SEPARATE_ROW_CTRL |= BIT7;
  83   2                  SC_OSD_FONT4B_ADDR_LO = addr & 0x00ff;
  84   2                  SC_OSD_FONT4B_ADDR_HI = (addr & 0xff00) >> 8;
  85   2                  break;
  86   2              case OSD_FONTBITS_4b:
  87   2                  SC_OSD_SEPARATE_ROW_CTRL &= ~BIT7;
  88   2                  SC_OSD_FONT4B_ADDR_LO = addr & 0x00ff;
  89   2                  SC_OSD_FONT4B_ADDR_HI = (addr & 0xff00) >> 8;
  90   2                  break;
  91   2              default:
  92   2                  break;
  93   2          }
  94   1      }
  95          
  96          /**************************************************************************//**
  97           * Clear user-defined area of OSD sram by scaler.
  98           ******************************************************************************/
  99          void OSDAPI_ClearOSD(void)
 100          {
 101   1          OSDAPI_OSDPowerOn();
 102   1          SC_OSD_CODE_FC = 0x00;
 103   1          SC_OSD_CODE_FC_CTL |= BIT0;
 104   1          while ((SC_OSD_CODE_FC_CTL & BIT0) == BIT0) {
 105   2              // Do something to avoid dead loop here
 106   2          }
 107   1      }
 108          
 109          /**************************************************************************//**
 110           * Indicate OSD width.
 111           * @param width OSD width.
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 3   

 112           ******************************************************************************/
 113          void OSDAPI_SetOSDWidth(UCHAR width)
 114          {
 115   1          ucOSDWidth = width;
 116   1      }
 117          
 118          /**************************************************************************//**
 119           * Indicate OSD height.
 120           * @param height OSD height.
 121           ******************************************************************************/
 122          void OSDAPI_SetOSDHeight(UCHAR height)
 123          {
 124   1          ucOSDHeight = height;
 125   1      }
 126          
 127          /**************************************************************************//**
 128           * Get OSD width.
 129           * @return OSD width.
 130           ******************************************************************************/
 131          UCHAR OSDAPI_GetOSDWidth(void)
 132          {
 133   1          return ucOSDWidth;
 134   1      }
 135          
 136          /**************************************************************************//**
 137           * Get OSD height.
 138           * @return OSD height.
 139           ******************************************************************************/
 140          UCHAR OSDAPI_GetOSDHeight(void)
 141          {
 142   1          return ucOSDHeight;
 143   1      }
 144          
 145          /**************************************************************************//**
 146           * Indicate OSD font size. There are four types of OSD font size,
 147           * 10x16, 10x18, 12x16, 12x18.
 148           * @param size OSD font size.
 149           ******************************************************************************/
 150          void OSDAPI_SetFontSize(OSDFontSize size)
 151          {
 152   1          UCHAR ctrl;
 153   1          ctrl = SC_OSD_SPACE_CTL & 0x3F;
 154   1          switch (size) {
 155   2              case OSD_FONT_10X16:
 156   2                  ucOSDFontWidth = 10;
 157   2                  ucOSDFontHeight = 16;
 158   2                  SC_OSD_SPACE_CTL = ctrl | BIT7 | BIT6;
 159   2                  break;
 160   2              case OSD_FONT_10X18:
 161   2                  ucOSDFontWidth = 10;
 162   2                  ucOSDFontHeight = 18;
 163   2                  SC_OSD_SPACE_CTL = ctrl | BIT6;
 164   2                  break;
 165   2              case OSD_FONT_12X16:
 166   2                  ucOSDFontWidth = 12;
 167   2                  ucOSDFontHeight = 16;
 168   2                  SC_OSD_SPACE_CTL = ctrl | BIT7;
 169   2                  break;
 170   2              case OSD_FONT_12X18:
 171   2                  ucOSDFontWidth = 12;
 172   2                  ucOSDFontHeight = 18;
 173   2                  SC_OSD_SPACE_CTL = ctrl;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 4   

 174   2                  break;
 175   2              default:
 176   2                  break;
 177   2          };
 178   1      }
 179          
 180          /**************************************************************************//**
 181           * Get OSD font width. The value is \a 10 or \a 12.
 182           * @return OSD font width.
 183           ******************************************************************************/
 184          UCHAR OSDAPI_GetOSDFontWidth(void)
 185          {
 186   1          return ucOSDFontWidth;
 187   1      }
 188          
 189          /**************************************************************************//**
 190           * Get OSD font height. The value is \a 16 or \a 18.
 191           * @return OSD font height.
 192           ******************************************************************************/
 193          UCHAR OSDAPI_GetOSDFontHeight(void)
 194          {
 195   1          return ucOSDFontHeight;
 196   1      }
 197          
 198          /**************************************************************************//**
 199           * Set OSD rotation.
 200           * @param rot OSD rotation mode.
 201           ******************************************************************************/
 202          void OSDAPI_RotateOSDPosition(OSDPosRotation rot)
 203          {
 204   1          SetOSDPosRot(rot);
 205   1      }
 206          
 207          /**************************************************************************//**
 208           * Set OSD position on screen.
 209           * @param x x position of OSD on screen. Step unit is font width.
 210           * @param y y position of OSD on screen. Step unit is font height.
 211           ******************************************************************************/
 212          void OSDAPI_SetPosition(USHRT x, USHRT y)
 213          {
 214   1      #define OSDPOS_BOUNDRY(a,b,c) ((a < (b * c)) ? 0 : (a - b * c))
 215   1      
 216   1          USHRT fw, fh, ow, oh;
 217   1          USHRT xy;
 218   1      
 219   1          OSDAPI_OSDPowerOn(); 
 220   1          fw = OSDAPI_GetOSDFontWidth();
 221   1          fh = OSDAPI_GetOSDFontHeight();
 222   1          ow = OSDAPI_GetOSDWidth();
 223   1          oh = OSDAPI_GetOSDHeight();
 224   1      
 225   1          switch(GetOSDPosRot()) {
 226   2              //case OSD_POS_ROT_90: // 90
 227   2              //    break;
 228   2              //case OSD_POS_ROT_180: //180
 229   2              //    break;
 230   2              case OSD_POS_ROT_270: //270
 231   2                  xy = PANEL_WIDTH - OSD_YPOS_TOP_OFFSET - OSD_YPOS_BOTTOM_OFFSET;
 232   2                  xy = (ULONG) OSDPOS_BOUNDRY(xy, fh, oh) * (OSD_POS_STEPS - y) / OSD_POS_STEPS;
 233   2                  xy += OSD_YPOS_TOP_OFFSET;
 234   2                  SC_OSD_HS_LO = (xy & 0x00FF);
 235   2                  SC_OSD_HS_HI = (xy & 0xFF00) >> 8;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 5   

 236   2                  SC_OSD_HW = ow - 1;
 237   2                  xy = PANEL_HEIGHT - OSD_XPOS_LEFT_OFFSET - OSD_XPOS_RIGHT_OFFSET;
 238   2                  xy = (ULONG) OSDPOS_BOUNDRY(xy, fw, ow) * x / OSD_POS_STEPS;
 239   2                  xy += OSD_XPOS_RIGHT_OFFSET;
 240   2                  SC_OSD_VS_LO = (xy & 0x00FF);
 241   2                  SC_OSD_VS_HI = (xy & 0xFF00) >> 8;
 242   2                  SC_OSD_VH = oh - 1;
 243   2                  break;
 244   2              default:
 245   2                  xy = PANEL_WIDTH - OSD_XPOS_LEFT_OFFSET - OSD_XPOS_RIGHT_OFFSET;
 246   2                  xy = (ULONG) OSDPOS_BOUNDRY(xy, fw, ow) * x / OSD_POS_STEPS;
 247   2                  xy += OSD_XPOS_LEFT_OFFSET;
 248   2                  SC_OSD_HS_LO = (xy & 0x00FF);
 249   2                  SC_OSD_HS_HI = (xy & 0xFF00) >> 8;
 250   2                  SC_OSD_HW = ow - 1;
 251   2                  xy = PANEL_HEIGHT - OSD_YPOS_TOP_OFFSET - OSD_YPOS_BOTTOM_OFFSET;
 252   2                  xy = (ULONG) OSDPOS_BOUNDRY(xy, fh, oh) * (OSD_POS_STEPS - y) / OSD_POS_STEPS;
 253   2                  xy += OSD_YPOS_TOP_OFFSET;
 254   2                  SC_OSD_VS_LO = (xy & 0x00FF);
 255   2                  SC_OSD_VS_HI = (xy & 0xFF00) >> 8;
 256   2                  SC_OSD_VH = oh - 1;
 257   2                  break;
 258   2          }
 259   1      
 260   1          WaitDisVSync();  // Always waiting display VSync to insure OSD H/V has been
 261   1                           // loaded into scaler.
 262   1                           // Jude 2010/10/08
 263   1      #undef OSDPOS_BOUNDRY
 264   1      }
 265          
 266          /**************************************************************************//**
 267           * Set OSD position on screen.
 268           * @param x x position of OSD on screen. Step unit is one pixel.
 269           * @param y y position of OSD on screen. Step unit is one pixel.
 270           ******************************************************************************/
 271          void OSDAPI_SetRowPosition(USHRT x, USHRT y)
 272          {
 273   1          SC_OSD_HS_LO = (x & 0x00FF);
 274   1          SC_OSD_HS_HI = (x & 0xFF00) >> 8;
 275   1          SC_OSD_HW = ucOSDWidth - 1;
 276   1          SC_OSD_VS_LO = (y & 0x00FF);
 277   1          SC_OSD_VS_HI = (y & 0xFF00) >> 8;
 278   1          SC_OSD_VH = ucOSDHeight - 1;
 279   1          WaitDisVSync();
 280   1      }
 281          #if 0 //lrd :ÒÆ¶¯µ½ÁËcomom
              /**************************************************************************//**
               * Show string at (x,y) on OSD.
               * @param attr Set OSD attributes at font(x,y).
               * @param x x position of string on OSD.
               * @param y y position of string on OSD.
               * @param len Number of characters of the string.
               * @param pstr Point to a list of font index.
               ******************************************************************************/
              void OSDAPI_WriteXYString(BOOL attr, UCHAR x, UCHAR y, UCHAR len, UCHAR *pstr)
              {
                  UCHAR i;
                  USHRT m;
              
                  ResetWDTimer();
                  m = (USHRT) y * ucOSDWidth + x;
              
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 6   

                  if (attr == TRUE) {
                      SC_INDEX_CTRL = 0x90;
                  }
                  else {
                      SC_INDEX_CTRL = 0x40;
                  }
                  SC_INDEX_ADDR_LO = (UCHAR) m;
                  SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
              
                  for (i = 0; i < len; i++) {
                      SC_INDEX_DATA = pstr[i];//0xe3,
                  }
                  ResetWDTimer();
              }
              #endif
 313          /**************************************************************************//**
 314           * Show string at (x,y) on OSD with specified alignment.
 315           * @param attr Set OSD attributes at OSD(x,y).
 316           * @param x x position of string on OSD.
 317           * @param y y position of string on OSD.
 318           * @param len Length of the string.
 319           * @param pstr Point to a list of font index.
 320           * @param align_len Length of the alignment.
 321           ******************************************************************************/
 322          /*
 323          void OSDAPI_WriteXYStringAlign(BOOL attr, UCHAR x, UCHAR y, UCHAR len, UCHAR *pstr, UCHAR align_len)
 324          {
 325              UCHAR new_x;
 326          
 327              if (align_len < len) { //Error handling
 328                  align_len = len;
 329              }
 330          
 331              switch (GetIndentAlign()) {
 332                  case OSD_ALIGN_LEFT:
 333                      new_x = x;
 334                      break;
 335          
 336                  case OSD_ALIGN_RIGHT:
 337                      new_x = x + (align_len-len);
 338                      break;
 339          
 340                  case OSD_ALIGN_CENTER:
 341                      new_x = x + (align_len-len)/2;
 342                      break;
 343              }
 344          
 345              OSDAPI_WriteXYRepeatChar(attr, x, y, align_len, 0x00);
 346              OSDAPI_WriteXYString(attr, new_x, y, len, pstr);
 347          }
 348          */
 349          
 350          /**************************************************************************//**
 351           * Show string. The x/y information is composed in the string.
 352           * @param attr Set OSD attributes.
 353           * @param pstr point to a list of font index with (x,y,len).
 354           ******************************************************************************/
 355          /*
 356          void OSDAPI_WriteString(BOOL attr, UCHAR *pstr)
 357          {
 358              UCHAR i, l;
 359              USHRT m;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 7   

 360          
 361              ResetWDTimer();
 362              m = pstr[2] * ucOSDWidth + pstr[1];
 363          
 364              if (attr == TRUE) {
 365                  SC_INDEX_CTRL = 0x90;
 366              }
 367              else {
 368                  SC_INDEX_CTRL = 0x40;
 369              }
 370              SC_INDEX_ADDR_LO = (UCHAR) m;
 371              SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
 372          
 373              l = pstr[0] + 1;
 374              for (i = 3; i < l; i++) {
 375                  SC_INDEX_DATA = pstr[i];
 376              }
 377              ResetWDTimer();
 378          }
 379          */
 380          
 381          /**************************************************************************//**
 382           * Show a string with same characters on OSD.
 383           * @param attr Set OSD attributes.
 384           * @param x x position of string on OSD.
 385           * @param y y position of string on OSD.
 386           * @param num Number of characters to be displayed on OSD.
 387           * @param ch The character to be showed on OSD.
 388           ******************************************************************************/
 389          void OSDAPI_WriteXYRepeatChar(BOOL attr, UCHAR x, UCHAR y, UCHAR num, UCHAR ch)
 390          {
 391   1          UCHAR i;
 392   1          USHRT m;
 393   1      
 394   1          ResetWDTimer();
 395   1          m = y * ucOSDWidth + x;
 396   1      
 397   1          if (attr == TRUE) {
 398   2              SC_INDEX_CTRL = 0x90;
 399   2          }
 400   1          else {
 401   2              SC_INDEX_CTRL = 0x40;
 402   2          }
 403   1          SC_INDEX_ADDR_LO = (UCHAR) m;
 404   1          SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
 405   1      
 406   1          for (i = 0; i < num; i++) {
 407   2              SC_INDEX_DATA = ch;
 408   2          }
 409   1          ResetWDTimer();
 410   1      }
 411          
 412          /**************************************************************************//**
 413           * Show character at OSD(x,y).
 414           * @param attr Set OSD attributes.
 415           * @param x x position of char on OSD.
 416           * @param y y position of char on OSD.
 417           * @param ch The character to be showed on OSD.
 418           ******************************************************************************/
 419          
 420          void OSDAPI_WriteXYChar(BOOL attr, UCHAR x, UCHAR y, UCHAR ch)
 421          {
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 8   

 422   1          USHRT m;
 423   1      
 424   1          ResetWDTimer();
 425   1          m = y * ucOSDWidth + x;
 426   1      
 427   1          if (attr == TRUE) {
 428   2              SC_INDEX_CTRL = 0x90;    
 429   2          }
 430   1          else {
 431   2              SC_INDEX_CTRL = 0x40;
 432   2          }
 433   1          SC_INDEX_ADDR_LO = (UCHAR) m;
 434   1          SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
 435   1          SC_INDEX_DATA = ch;
 436   1          ResetWDTimer();
 437   1      }
 438          
 439          
 440          /**************************************************************************//**
 441           * Set same OSD font attributes to a string at OSD(x,y).
 442           * @param x x position of a string on OSD.
 443           * @param y y position of a string on OSD.
 444           * @param num Length of a string.
 445           * @param attr Set OSD attributes.
 446           ******************************************************************************/
 447          void OSDAPI_FillLineAttr(UCHAR x, UCHAR y, UCHAR num, USHRT attr)
 448          {
 449   1          UCHAR i;
 450   1          USHRT m;
 451   1      
 452   1          ResetWDTimer();
 453   1          m = y * ucOSDWidth + x;
 454   1      
 455   1          SC_INDEX_CTRL = 0x70;
 456   1          SC_INDEX_ADDR_LO = (UCHAR) m;
 457   1          SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
 458   1          for (i = 0; i < num; i++) {
 459   2              SC_INDEX_DATA = (UCHAR) attr;
 460   2              SC_INDEX_DATA = (UCHAR)(attr >> 8);
 461   2          }
 462   1          ResetWDTimer();
 463   1      }
 464          
 465          #if !lrd_dis
              /**************************************************************************//**
               * Set font attributes with a list of attribute settings.
               * @param x x start position of a string on OSD.
               * @param y y start position of a string on OSD.
               * @param num Length of a string.
               * @param ptr Pointer to the list of font attributes.
               ******************************************************************************/
              void OSDAPI_FillLineAttrList(UCHAR x, UCHAR y, UCHAR num, USHRT *ptr)
              {
                  UCHAR i;
                  USHRT m;
              
                  ResetWDTimer();
                  m = y * ucOSDWidth + x;
              
                  SC_INDEX_CTRL = 0x70;
                  SC_INDEX_ADDR_LO = (UCHAR) m;
                  SC_INDEX_ADDR_HI = (UCHAR)(m >> 8);
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 9   

              
                  for (i = 0; i < num; i++) {
                      SC_INDEX_DATA = (UCHAR) *ptr;
                      SC_INDEX_DATA = (UCHAR)(*ptr >> 8);
                      ptr++;
                  }
                  ResetWDTimer();
              }
              #endif
 493          /**************************************************************************//**
 494           * Indicate position alignment, right, left or center, on OSD.
 495           * @param algn Position alignment on OSD.
 496           ******************************************************************************/
 497          void OSDAPI_SetAlignType(OSDAlignment algn)
 498          {
 499   1          SetIndentAlign(algn);
 500   1      }
 501          
 502          /**************************************************************************//**
 503           * Return position alignment, right, left or center, on OSD.
 504           * @return Position alignment. OSD_ALIGN_LEFT, OSD_ALIGN_RIGHT or OSD_ALIGN_CENTER.
 505           ******************************************************************************/
 506          UCHAR OSDAPI_GetAlignType(void)
 507          {
 508   1          return GetIndentAlign();
 509   1      }
 510          
 511          #if ENABLE_OSD_ROTATION == ON
 512          /**************************************************************************//**
 513           * Rotate OSD font.
 514           * @param[out] des Pointer to destination font buffer.
 515           * @param[in] src Pointer to source font buffer.
 516           ******************************************************************************/
 517          void OSDAPI_RotateFont(UCHAR *src)
 518          {
 519   1      #define B0(a) (a&0x01)
 520   1      #define B1(a) ((a&0x02)>>1)
 521   1      #define B2(a) ((a&0x04)>>2)
 522   1      #define B3(a) ((a&0x08)>>3)
 523   1      #define B4(a) ((a&0x10)>>4)
 524   1      #define B5(a) ((a&0x20)>>5)
 525   1      #define B6(a) ((a&0x40)>>6)
 526   1      #define B7(a) ((a&0x80)>>7)
 527   1      
 528   1              SC_INDEX_DATA = (B7(src[11])<<7) | (B3(src[10])<<6) | (B7(src[ 8])<<5) | (B3(src[ 7])<<4) | 
 529   1                              (B7(src[ 5])<<3) | (B3(src[ 4])<<2) | (B7(src[ 2])<<1) | (B3(src[ 1])<<0);
 530   1              SC_INDEX_DATA = (B7(src[23])<<7) | (B3(src[22])<<6) | (B7(src[20])<<5) | (B3(src[19])<<4) | 
 531   1                              (B7(src[17])<<3) | (B3(src[16])<<2) | (B7(src[14])<<1) | (B3(src[13])<<0);
 532   1              SC_INDEX_DATA = (B6(src[ 8])<<7) | (B2(src[ 7])<<6) | (B6(src[ 5])<<5) | (B2(src[ 4])<<4) | 
 533   1                              (B6(src[ 2])<<3) | (B2(src[ 1])<<2) | (B7(src[26])<<1) | (B3(src[25])<<0);
 534   1              SC_INDEX_DATA = (B6(src[20])<<7) | (B2(src[19])<<6) | (B6(src[17])<<5) | (B2(src[16])<<4) | 
 535   1                              (B6(src[14])<<3) | (B2(src[13])<<2) | (B6(src[11])<<1) | (B2(src[10])<<0);
 536   1              SC_INDEX_DATA = (B5(src[ 5])<<7) | (B1(src[ 4])<<6) | (B5(src[ 2])<<5) | (B1(src[ 1])<<4) | 
 537   1                              (B6(src[26])<<3) | (B2(src[25])<<2) | (B6(src[23])<<1) | (B2(src[22])<<0);
 538   1              SC_INDEX_DATA = (B5(src[17])<<7) | (B1(src[16])<<6) | (B5(src[14])<<5) | (B1(src[13])<<4) | 
 539   1                              (B5(src[11])<<3) | (B1(src[10])<<2) | (B5(src[ 8])<<1) | (B1(src[ 7])<<0);
 540   1              SC_INDEX_DATA = (B4(src[ 2])<<7) | (B0(src[ 1])<<6) | (B5(src[26])<<5) | (B1(src[25])<<4) | 
 541   1                              (B5(src[23])<<3) | (B1(src[22])<<2) | (B5(src[20])<<1) | (B1(src[19])<<0);
 542   1              SC_INDEX_DATA = (B4(src[14])<<7) | (B0(src[13])<<6) | (B4(src[11])<<5) | (B0(src[10])<<4) | 
 543   1                              (B4(src[ 8])<<3) | (B0(src[ 7])<<2) | (B4(src[ 5])<<1) | (B0(src[ 4])<<0);
 544   1              SC_INDEX_DATA = (B4(src[26])<<7) | (B0(src[25])<<6) | (B4(src[23])<<5) | (B0(src[22])<<4) | 
 545   1                              (B4(src[20])<<3) | (B0(src[19])<<2) | (B4(src[17])<<1) | (B0(src[16])<<0);
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 10  

 546   1              SC_INDEX_DATA = (B3(src[11])<<7) | (B7(src[ 9])<<6) | (B3(src[ 8])<<5) | (B7(src[ 6])<<4) | 
 547   1                              (B3(src[ 5])<<3) | (B7(src[ 3])<<2) | (B3(src[ 2])<<1) | (B7(src[ 0])<<0);    
 548   1              SC_INDEX_DATA = (B3(src[23])<<7) | (B7(src[21])<<6) | (B3(src[20])<<5) | (B7(src[18])<<4) | 
 549   1                              (B3(src[17])<<3) | (B7(src[15])<<2) | (B3(src[14])<<1) | (B7(src[12])<<0);
 550   1              SC_INDEX_DATA = (B2(src[ 8])<<7) | (B6(src[ 6])<<6) | (B2(src[ 5])<<5) | (B6(src[ 3])<<4) | 
 551   1                              (B2(src[ 2])<<3) | (B6(src[ 0])<<2) | (B3(src[26])<<1) | (B7(src[24])<<0);
 552   1              SC_INDEX_DATA = (B2(src[20])<<7) | (B6(src[18])<<6) | (B2(src[17])<<5) | (B6(src[15])<<4) | 
 553   1                              (B2(src[14])<<3) | (B6(src[12])<<2) | (B2(src[11])<<1) | (B6(src[ 9])<<0);
 554   1              SC_INDEX_DATA = (B1(src[ 5])<<7) | (B5(src[ 3])<<6) | (B1(src[ 2])<<5) | (B5(src[ 0])<<4) | 
 555   1                              (B2(src[26])<<3) | (B6(src[24])<<2) | (B2(src[23])<<1) | (B6(src[21])<<0);
 556   1              SC_INDEX_DATA = (B1(src[17])<<7) | (B5(src[15])<<6) | (B1(src[14])<<5) | (B5(src[12])<<4) | 
 557   1                              (B1(src[11])<<3) | (B5(src[ 9])<<2) | (B1(src[ 8])<<1) | (B5(src[ 6])<<0);
 558   1              SC_INDEX_DATA = (B0(src[ 2])<<7) | (B4(src[ 0])<<6) | (B1(src[26])<<5) | (B5(src[24])<<4) | 
 559   1                              (B1(src[23])<<3) | (B5(src[21])<<2) | (B1(src[20])<<1) | (B5(src[18])<<0);
 560   1              SC_INDEX_DATA = (B0(src[14])<<7) | (B4(src[12])<<6) | (B0(src[11])<<5) | (B4(src[ 9])<<4) | 
 561   1                              (B0(src[ 8])<<3) | (B4(src[ 6])<<2) | (B0(src[ 5])<<1) | (B4(src[ 3])<<0);   
 562   1              SC_INDEX_DATA = (B0(src[26])<<7) | (B4(src[24])<<6) | (B0(src[23])<<5) | (B4(src[21])<<4) | 
 563   1                              (B0(src[20])<<3) | (B4(src[18])<<2) | (B0(src[17])<<1) | (B4(src[15])<<0);  
 564   1              SC_INDEX_DATA = (B7(src[10])<<7) | (B3(src[ 9])<<6) | (B7(src[ 7])<<5) | (B3(src[ 6])<<4) | 
 565   1                              (B7(src[ 4])<<3) | (B3(src[ 3])<<2) | (B7(src[ 1])<<1) | (B3(src[ 0])<<0);
 566   1              SC_INDEX_DATA = (B7(src[22])<<7) | (B3(src[21])<<6) | (B7(src[19])<<5) | (B3(src[18])<<4) | 
 567   1                              (B7(src[16])<<3) | (B3(src[15])<<2) | (B7(src[13])<<1) | (B3(src[12])<<0);
 568   1              SC_INDEX_DATA = (B6(src[ 7])<<7) | (B2(src[ 6])<<6) | (B6(src[ 4])<<5) | (B2(src[ 3])<<4) | 
 569   1                              (B6(src[ 1])<<3) | (B2(src[ 0])<<2) | (B7(src[25])<<1) | (B3(src[24])<<0);
 570   1              SC_INDEX_DATA = (B6(src[19])<<7) | (B2(src[18])<<6) | (B6(src[16])<<5) | (B2(src[15])<<4) | 
 571   1                              (B6(src[13])<<3) | (B2(src[12])<<2) | (B6(src[10])<<1) | (B2(src[ 9])<<0);
 572   1              SC_INDEX_DATA = (B5(src[ 4])<<7) | (B1(src[ 3])<<6) | (B5(src[ 1])<<5) | (B1(src[ 0])<<4) | 
 573   1                              (B6(src[25])<<3) | (B2(src[24])<<2) | (B6(src[22])<<1) | (B2(src[21])<<0);
 574   1              SC_INDEX_DATA = (B5(src[16])<<7) | (B1(src[15])<<6) | (B5(src[13])<<5) | (B1(src[12])<<4) | 
 575   1                              (B5(src[10])<<3) | (B1(src[ 9])<<2) | (B5(src[ 7])<<1) | (B1(src[ 6])<<0);
 576   1              SC_INDEX_DATA = (B4(src[ 1])<<7) | (B0(src[ 0])<<6) | (B5(src[25])<<5) | (B1(src[24])<<4) | 
 577   1                              (B5(src[22])<<3) | (B1(src[21])<<2) | (B5(src[19])<<1) | (B1(src[18])<<0);
 578   1              SC_INDEX_DATA = (B4(src[13])<<7) | (B0(src[12])<<6) | (B4(src[10])<<5) | (B0(src[ 9])<<4) | 
 579   1                              (B4(src[ 7])<<3) | (B0(src[ 6])<<2) | (B4(src[ 4])<<1) | (B0(src[ 3])<<0);
 580   1              SC_INDEX_DATA = (B4(src[25])<<7) | (B0(src[24])<<6) | (B4(src[22])<<5) | (B0(src[21])<<4) | 
 581   1                              (B4(src[19])<<3) | (B0(src[18])<<2) | (B4(src[16])<<1) | (B0(src[15])<<0);
 582   1      #undef B0
 583   1      #undef B1
 584   1      #undef B2
 585   1      #undef B3
 586   1      #undef B4
 587   1      #undef B5
 588   1      #undef B6
 589   1      #undef B7
 590   1      }
 591          
 592          /**************************************************************************//**
 593           * Rotate indent OSD font.
 594           * @param[out] des Pointer to destination font buffer.
 595           * @param[in] src Pointer to source font buffer.
 596           ******************************************************************************/
 597          void OSDAPI_RotateIdentFont(USHRT *src)
 598          {
 599   1          UCHAR i,buffer[27];
 600   1      
 601   1          for (i = 0; i < 9; i++) {
 602   2              buffer[3*i]   = (UCHAR)(src[2*i]>>4);
 603   2              buffer[3*i+1] = (UCHAR)((src[2*i+1]&0x00F0) | (src[2*i]>>12));
 604   2              buffer[3*i+2] = (UCHAR)(src[2*i+1]>>8);
 605   2          }
 606   1          OSDAPI_RotateFont(buffer);
 607   1      }
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 11  

 608          #endif //ENABLE_OSD_ROTATION == ON
 609          
 610          #if ENABLE_OSD_MIRROR == ON
              /**************************************************************************//**
               * Reverse the bit string of a character.
               * @param target The original character.
               * @return Reversed character.
               ******************************************************************************/
              static UCHAR OSDAPI_ReverseChar(UCHAR target)
              {
                  UCHAR tmp,i;
                  
                  tmp = 0;    
                  for (i = 0; i < 8; i++) {
                      tmp = (tmp << 1) | ((target>>i)&0x01);
                  }
                      
                  return tmp;
              }
              
              /**************************************************************************//**
               * Reverse the bit string of a short(2 x character).
               * @param target The original short.
               * @return Reversed short.
               ******************************************************************************/
              static USHRT OSDAPI_ReverseShort(USHRT target)
              {
                  USHRT tmp;
                  UCHAR i;
                  tmp = 0;
                      
                  for (i = 0; i < 16; i++) {
                      tmp = (tmp << 1) | ((target>>i)&0x01);
                  }
                  
                  return tmp;
              }
              
              /**************************************************************************//**
               * Mirror one OSD font.
               * @param[out] des Pointer to destination font buffer.
               * @param[in] src Pointer to source font buffer.
               * @param width OSD font width (10 or 12).
               ******************************************************************************/
              void OSDAPI_MirrorFont(UCHAR *des, UCHAR *src, UCHAR width)
              {
                  UCHAR i;
                  UCHAR tmp1,tmp2,tmp3;
                  UCHAR mrr1,mrr2,mrr3;
              
                  for (i = 0; i < 9; i++) {
                      tmp1 = OSDAPI_ReverseChar(src[i*3+0]);
                      tmp2 = OSDAPI_ReverseChar(src[i*3+1]);
                      tmp3 = OSDAPI_ReverseChar(src[i*3+2]);
                      mrr1 = ((tmp2&0xf0) >> 4) | ((tmp1&0x0f) << 4);
                      mrr2 = ((tmp1&0xf0) >> 4) | ((tmp3&0x0f) << 4);
                      mrr3 = ((tmp3&0xf0) >> 4) | ((tmp2&0x0f) << 4);
                      des[i*3+0] = (mrr1 << (12-width));
                      des[i*3+1] = (mrr2 << (12-width));
                      des[i*3+2] = (mrr3 << (12-width));
                  }
              }
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 12  

              
              /**************************************************************************//**
               * Mirror one indent OSD font.
               * @param[out] des Pointer to destination font buffer.
               * @param[in] src Pointer to source font buffer.
               * @param width indent OSD font width.
               ******************************************************************************/
              void OSDAPI_MirrorIdentFont(USHRT *des, USHRT *src, UCHAR width)
              {
                  UCHAR i;
                  for (i = 0; i < 18; i++) {
                      des[i] = (OSDAPI_ReverseShort(src[i]) << (16-width));
                  }
              }
              #endif //ENABLE_OSD_MIRROR == ON
 685          
 686          #if ENABLE_OSD_FLIP == ON
              /**************************************************************************//**
               * Flip one OSD font.
               * @param[out] des Pointer to destination font buffer.
               * @param[in] src Pointer to source font buffer.
               * @param height OSD font height.
               ******************************************************************************/
              void OSDAPI_FlipFont(UCHAR *des, UCHAR *src, UCHAR height)
              {
                  UCHAR buffer[27], i;
                  
                  for (i = 0; i < (height/2*3); i++) {
                      buffer[i] = src[height/2*3-1-i];
                  }
                  for (i = 0; i < height/2; i++) {
                      des[i*3]   = ((buffer[i*3+1]&0xf0)>>4)+((buffer[i*3]&0x0f)<<4);
                      des[i*3+1] = ((buffer[i*3]&0xf0)>>4)+((buffer[i*3+2]&0x0f)<<4);
                      des[i*3+2] = ((buffer[i*3+2]&0xf0)>>4)+((buffer[i*3+1]&0x0f)<<4);
                  }
              }
              
              /**************************************************************************//**
               * Flip one indent OSD font.
               * @param[out] des Pointer to destination font buffer.
               * @param[in] src Pointer to source font buffer.
               * @param height indent OSD font height.
               ******************************************************************************/
              void OSDAPI_FlipIdentFont(USHRT *des, USHRT *src, UCHAR height)
              {
                  UCHAR i;
                  
                  for (i = 0; i < (height/2); i++) {
                      des[i] = src[height-1-i];
                      des[height-1-i] = src[i];
                  }
              }
              #endif //ENABLE_OSD_FLIP == ON
 723          
 724          #if ENABLE_OSD_WINDOWS == ON
 725          /**************************************************************************//**
 726           * Turn on OSD window.
 727           * @param id Window ID.
 728           ******************************************************************************/
 729          void OSDAPI_OSDWinOn(OSDWindow id)
 730          {
 731   1          switch (id) {
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 13  

 732   2              case OSD_WINDOW1:
 733   2                  SC_OSD_CTRL1 |= BIT1;
 734   2                  break;
 735   2              case OSD_WINDOW2:
 736   2                  SC_OSD_CTRL1 |= BIT2;
 737   2                  break;
 738   2              case OSD_WINDOW3:
 739   2                  SC_OSD_CTRL1 |= BIT3;
 740   2                  break;
 741   2              case OSD_WINDOW4:
 742   2                  SC_OSD_CTRL1 |= BIT4;
 743   2                  break;
 744   2              case OSD_WINDOW5:
 745   2                  SC_OSD_WIN_SEL |= BIT4;
 746   2                  break;
 747   2              case OSD_WINDOW6:
 748   2                  SC_OSD_WIN_SEL |= BIT5;
 749   2                  break;
 750   2              case OSD_WINDOW7:
 751   2                  SC_OSD_WIN_SEL |= BIT6;
 752   2                  break;
 753   2              case OSD_WINDOW8:
 754   2                  SC_OSD_WIN_SEL |= BIT7;
 755   2                  break;
 756   2              default:
 757   2                  break;
 758   2          }
 759   1      }
 760          
 761          /**************************************************************************//**
 762           * Turn off OSD window.
 763           * @param id Window ID.
 764           ******************************************************************************/
 765          void OSDAPI_OSDWinOff(OSDWindow id)
 766          {
 767   1          switch (id) {
 768   2              case OSD_WINDOW1:
 769   2                  SC_OSD_CTRL1 &= ~BIT1;
 770   2                  break;
 771   2              case OSD_WINDOW2:
 772   2                  SC_OSD_CTRL1 &= ~BIT2;
 773   2                  break;
 774   2              case OSD_WINDOW3:
 775   2                  SC_OSD_CTRL1 &= ~BIT3;
 776   2                  break;
 777   2              case OSD_WINDOW4:
 778   2                  SC_OSD_CTRL1 &= ~BIT4;
 779   2                  break;
 780   2              case OSD_WINDOW5:
 781   2                  SC_OSD_WIN_SEL &= ~BIT4;
 782   2                  break;
 783   2              case OSD_WINDOW6:
 784   2                  SC_OSD_WIN_SEL &= ~BIT5;
 785   2                  break;
 786   2              case OSD_WINDOW7:
 787   2                  SC_OSD_WIN_SEL &= ~BIT6;
 788   2                  break;
 789   2              case OSD_WINDOW8:
 790   2                  SC_OSD_WIN_SEL &= ~BIT7;
 791   2                  break;
 792   2              case OSD_WIN_OFF:
 793   2              default:
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 14  

 794   2                  SC_OSD_CTRL1 &= 0xE1;
 795   2                  SC_OSD_WIN_SEL &= 0x0F;
 796   2                  break;
 797   2          }
 798   1      }
 799          
 800          /**************************************************************************//**
 801           * Select the accessible OSD window.
 802           * @param id Window ID.
 803           ******************************************************************************/
 804          void OSDAPI_SelOSDWin(OSDWindow id)
 805          {
 806   1          if (id > OSD_WINDOW8)
 807   1              return;
 808   1          SC_OSD_WIN_SEL = (SC_OSD_WIN_SEL & 0xf8) | id;
 809   1      }
 810          
 811          /**************************************************************************//**
 812           * Set OSD window width/height unit.
 813           * @param width Set unit size (number of pixels) of window width.
 814           * @param height Set unit size(number of pixels) of window height.
 815           ******************************************************************************/
 816          void OSDAPI_SetOSDWinSizeUnit(UCHAR width, UCHAR height)
 817          {
 818   1          ucWinUnitWidth  = width;
 819   1          ucWinUnitHeight = height;
 820   1      }
 821          /**************************************************************************//**
 822           * Set OSD window position and size.
 823           * The units of position and size are set by OSDAPI_SetOSDWinSizeUnit.
 824           * @param sx Start position of x.
 825           * @param sy Start position of y.
 826           * @param ex End position of x.
 827           * @param ey End position of y.
 828           ******************************************************************************/
 829          void OSDAPI_SetOSDWinSize(USHRT sx, USHRT sy, USHRT ex, USHRT ey)
 830          {
 831   1      #if ENABLE_OSD_ROTATION == ON
 832   1          UCHAR id, rot;
 833   1      
 834   1          sx = sx * ucWinUnitWidth;
 835   1          ex = (ex + 1) * ucWinUnitWidth;
 836   1          sy = sy * ucWinUnitHeight;
 837   1          ey = (ey + 1) * ucWinUnitHeight;
 838   1      
 839   1          switch(GetOSDPosRot()) {
 840   2              case OSD_POS_ROT_90:
 841   2                  OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_90, FALSE);
 842   2                  break;
 843   2              case OSD_POS_ROT_180:
 844   2                  OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_180, FALSE);
 845   2                  break;
 846   2              case OSD_POS_ROT_270:
 847   2                  OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_270, FALSE);
 848   2                  break;
 849   2              default :
 850   2                  OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_0, FALSE);
 851   2                  break;
 852   2          }
 853   1      
 854   1          id = (SC_OSD_WIN_SEL & 0x07);
 855   1          rot = GetOSDPosRot();
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 15  

 856   1          SetOSDWinRotStatus(id, rot);
 857   1      #else
                  USHRT tmp1;
              
                  sx = sx * ucWinUnitWidth;
                  ex = (ex + 1) * ucWinUnitWidth;
                  sy = sy * ucWinUnitHeight;
                  ey = (ey + 1) * ucWinUnitHeight;
              
                  SC_OSD_WIN_HOR_START_LO = (UCHAR)sx;
                  SC_OSD_WIN_HOR_END_LO = (UCHAR)ex;
                  tmp1 = ((sx >> 8) & 0x000F) | ((ex >> 4) & 0x00F0);
                  SC_OSD_WIN_HOR_HI = (UCHAR)tmp1;
                  SC_OSD_WIN_VER_START_LO = (UCHAR)sy;
                  SC_OSD_WIN_VER_END_LO = (UCHAR)ey;
                  tmp1 = ((sy >> 8) & 0x000F) | ((ey >> 4) & 0x00F0);
                  SC_OSD_WIN_VER_HI = (UCHAR)tmp1;
              
                  WaitDisVSync();
              #endif //ENABLE_OSD_ROTATION == ON
 876   1      }
 877          #if !lrd_dis
              void OSDAPI_SetOSDWinSizeByPixel(USHRT sx, USHRT sy, USHRT ex, USHRT ey)
              {
              
              #if ENABLE_OSD_ROTATION == ON
                  UCHAR id, rot;
                  sx = sx;
                  ex = (ex);
                  sy = sy ;
                  ey = (ey);
                  switch(GetOSDPosRot()) {
                      case OSD_POS_ROT_90:
                          OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_90, FALSE);
                          break;
                      case OSD_POS_ROT_180:
                          OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_180, FALSE);
                          break;
                      case OSD_POS_ROT_270:
                          OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_270, FALSE);
                          break;
                      default :
                          OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, OSD_WIN_DEGREE_0, FALSE);
                          break;
                  }
              
                  id = (SC_OSD_WIN_SEL & 0x07);
                  rot = GetOSDPosRot();
                  SetOSDWinRotStatus(id, rot);
              #else
                  USHRT tmp1;
              
                  sx = sx;
                  ex = (ex);
                  sy = sy;
                  ey = (ey);
              
                  SC_OSD_WIN_HOR_START_LO = (UCHAR)sx;
                  SC_OSD_WIN_HOR_END_LO = (UCHAR)ex;
                  tmp1 = ((sx >> 8) & 0x000F) | ((ex >> 4) & 0x00F0);
                  SC_OSD_WIN_HOR_HI = (UCHAR)tmp1;
                  SC_OSD_WIN_VER_START_LO = (UCHAR)sy;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 16  

                  SC_OSD_WIN_VER_END_LO = (UCHAR)ey;
                  tmp1 = ((sy >> 8) & 0x000F) | ((ey >> 4) & 0x00F0);
                  SC_OSD_WIN_VER_HI = (UCHAR)tmp1;
              
                  WaitDisVSync();
              #endif //ENABLE_OSD_ROTATION == ON
              
              
              }
              
              #endif
 929          
 930          /**************************************************************************//**
 931           * Set attribute of the selected window.
 932           * @param attr OSD window attribute.
 933           ******************************************************************************/
 934          void OSDAPI_SetOSDWinAttr(OSDWinAttr attr)
 935          {
 936   1          SC_OSD_WIN_COLOR = attr.ucWinClr;
 937   1          if (CHK_WINATTR_BEVEL(attr)) {
 938   2              SC_OSD_WIN_ATTRIBUTE |= BIT7;
 939   2          }
 940   1          else {
 941   2              SC_OSD_WIN_ATTRIBUTE &= ~BIT7;
 942   2          }
 943   1          
 944   1          if (CHK_WINATTR_FADEINOUT(attr)) {
 945   2              SC_OSD_WIN_ATTRIBUTE |= BIT0;
 946   2          }
 947   1          else {
 948   2              SC_OSD_WIN_ATTRIBUTE &= ~BIT0;
 949   2          }
 950   1      
 951   1          if (CHK_WINATTR_SHADOW(attr)) {
 952   2              SC_OSD_WIN_ATTRIBUTE |= BIT1;
 953   2          }
 954   1          else {
 955   2              SC_OSD_WIN_ATTRIBUTE &= ~BIT1;
 956   2          }
 957   1      
 958   1          if (CHK_WINATTR_BEVEL_SHADOW_TRANS(attr)) {
 959   2              SC_OSD_CODE_FC_CTL |= BIT2;
 960   2          }
 961   1          else {
 962   2              SC_OSD_CODE_FC_CTL &= ~BIT2;
 963   2          }
 964   1      
 965   1          SC_OSD_WIN_ATTRIBUTE |= BIT4;   // Force translucent for window
 966   1          SC_OSD_WIN_ATTRIBUTE |= ((attr.ucBorderAttr & 0x30) << 1); // Bevel Type
 967   1          SC_OSD_WIN_BEVEL_WIDTH = attr.ucBorderAttr & 0x07; // Bevel Width
 968   1          SC_OSD_WIN_BEVEL_COLOR_R = attr.ucRBorderClr;
 969   1          SC_OSD_WIN_BEVEL_COLOR_L = attr.ucLBorderClr;
 970   1      }
 971          
 972          /**************************************************************************//**
 973           * Set OSD window transparency.
 974           * @param tran Level of OSD window transparency. Range is 0 to 8.
 975           ******************************************************************************/
 976          void OSDAPI_SetOSDWinTran(UCHAR tran)
 977          {
 978   1          if (tran == 0xFF) {
 979   2              return;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 17  

 980   2          }
 981   1          else if (tran > 8) {
 982   2              tran = 8;
 983   2          }
 984   1      
 985   1          if (tran == 0) {
 986   2              SC_OSD_TRANSLUCENT_CTL &= 0xC7;//TP_LEVEL_TWO
 987   2              SC_OSD_WIN_ATTRIBUTE &= ~BIT4;//WIN_MIX
 988   2          }
 989   1          else {
 990   2              SC_OSD_TRANSLUCENT_CTL = (SC_OSD_TRANSLUCENT_CTL & 0xC7) | ((tran - 1) << 3);//TP_LEVEL_TWO
 991   2              SC_OSD_WIN_ATTRIBUTE |= BIT4;//WIN_MIX
 992   2          }
 993   1      }
 994          
 995          /**************************************************************************//**
 996           * Set gradient color of window.
 997           * @param dir Left-right or top-button direction.
 998           * @param inc Increase or decrease gray variance.
 999           * @param step Increase/decrease gray levels per step.
1000           * @param pixel Number of pixel per step.
1001           ******************************************************************************/
1002          #if !lrd_dis
              void OSDAPI_SetOSDWinGrad(UCHAR dir, UCHAR inc, UCHAR step, UCHAR pixel)
              {
              #if ENABLE_OSD_ROTATION == ON
                  switch(GetOSDPosRot()) {
                      case OSD_POS_ROT_90:
                          dir = ~dir;
                          break;
                      case OSD_POS_ROT_180:
                          inc = ~inc;
                          break;
                      case OSD_POS_ROT_270:
                          dir = ~dir;
                          //inc = ~inc;
                          break;
                      default:
                          break;
                  }
              #endif //ENABLE_OSD_ROTATION == ON
              
                  SC_OSD_WIN_GRADIENT_CTRL = 0x00;
                  OSDAPI_TurnOnOffOSDWinGrad(ON);
                  SC_OSD_WIN_GRADIENT_CTRL |= ((dir&BIT0)<<4);
                  SC_OSD_WIN_GRADIENT_RED_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
                  SC_OSD_WIN_GRADIENT_GREEN_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
                  SC_OSD_WIN_GRADIENT_BLUE_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
                  SC_OSD_WIN_GRADIENT_RED_STEP = step;
                  SC_OSD_WIN_GRADIENT_GREEN_STEP = step;
                  SC_OSD_WIN_GRADIENT_BLUE_STEP = step;
              }
              #endif
1033          /**************************************************************************//**
1034           * Turn on/off OSD gradient function.
1035           * @param on On/off OSD gradient.
1036           ******************************************************************************/
1037          #if !lrd_dis
              void OSDAPI_TurnOnOffOSDWinGrad(UCHAR on)
              {
                  if (on) {
                      SC_OSD_WIN_GRADIENT_CTRL |= 0x2F;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 18  

                  }
                  else {
                      SC_OSD_WIN_GRADIENT_CTRL &= 0xD0;
                  }
              }
              #endif
1048          #if ENABLE_OSD_ROTATION == ON
1049          /**************************************************************************//**
1050           * Rotate selected OSD window.
1051           * @param id Window ID.
1052           * @param rot Rotation degree.
1053           ******************************************************************************/
1054          void OSDAPI_RotateOSDWin(OSDWindow id, OSDPosRotation rot)
1055          {
1056   1          USHRT sx, sy, ex, ey, tmp;
1057   1          UCHAR dir;
1058   1          OSDPosRotation prev_rot;
1059   1          OSDWinDegree degree;
1060   1      
1061   1          if (id > OSD_WINDOW8) {
1062   2              return;
1063   2          }
1064   1      
1065   1          OSDAPI_SelOSDWin(id);
1066   1      
1067   1          tmp = (USHRT)SC_OSD_WIN_HOR_HI;
1068   1          sx = ((tmp & 0x0F) << 8) + SC_OSD_WIN_HOR_START_LO;
1069   1          ex = ((tmp & 0xF0) << 4) + SC_OSD_WIN_HOR_END_LO;
1070   1          tmp = (USHRT)SC_OSD_WIN_VER_HI;
1071   1          sy = ((tmp & 0x0F) << 8) + SC_OSD_WIN_VER_START_LO;
1072   1          ey = ((tmp & 0xF0) << 4) + SC_OSD_WIN_VER_END_LO;
1073   1      
1074   1          prev_rot = GetOSDWinRotStatus(id);
1075   1          degree = (NUM_OSD_WIN_DEGREE + rot - prev_rot) % NUM_OSD_WIN_DEGREE;
1076   1      
1077   1          if ((prev_rot == OSD_POS_ROT_90) || (prev_rot == OSD_POS_ROT_270)) {
1078   2              dir = TRUE;
1079   2          }
1080   1          else {
1081   2              dir = FALSE;
1082   2          }
1083   1          OSDAPI_RotateOSDWinPosition(sx, sy, ex, ey, degree, dir);
1084   1      
1085   1          if ((degree == OSD_WIN_DEGREE_90) || (degree == OSD_WIN_DEGREE_270)) {
1086   2              dir = !(SC_OSD_WIN_GRADIENT_CTRL & BIT4);
1087   2              SC_OSD_WIN_GRADIENT_CTRL &= ~BIT4;
1088   2              SC_OSD_WIN_GRADIENT_CTRL |= (dir << 4);
1089   2          }
1090   1      
1091   1      //    SC_OSD_WIN_GRADIENT_RED_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
1092   1      //    SC_OSD_WIN_GRADIENT_GREEN_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
1093   1      //    SC_OSD_WIN_GRADIENT_BLUE_COLOR = ((pixel&0x1F) | ((inc&BIT0) << 7));
1094   1      
1095   1          SetOSDWinRotStatus(id, rot);
1096   1      }
1097          #if ENABLE_OSD_ROTATION == ON
1098          
1099          /**************************************************************************//**
1100           * Set the position of OSD window with rotation.
1101           * @param sx Start position of x.
1102           * @param sy Start position of y.
1103           * @param ex End position of x.
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 19  

1104           * @param ey End position of y.
1105           * @param degree Rotation degree.
1106           * @param rot TRUE if OSD has been rotated 90/270 degree. Otherwise FALSE.
1107           ******************************************************************************/
1108          #if !lrd_dis
              static void OSDAPI_RotateOSDWinPosition(USHRT sx, USHRT sy, USHRT ex, USHRT ey, OSDWinDegree degree, UCHAR
             - rot)
              {
                  USHRT fw, fh, ow, oh;
                  USHRT tmp1, tmp2;
                  UCHAR border;
              
                  if (rot) {
                      fh = OSDAPI_GetOSDFontWidth();
                      fw = OSDAPI_GetOSDFontHeight();
                      oh = OSDAPI_GetOSDWidth();
                      ow = OSDAPI_GetOSDHeight();
                  }
                  else {
                      fw = OSDAPI_GetOSDFontWidth();
                      fh = OSDAPI_GetOSDFontHeight();
                      ow = OSDAPI_GetOSDWidth();
                      oh = OSDAPI_GetOSDHeight();
                  }
              
                  border = 0;
                  if (SC_OSD_WIN_ATTRIBUTE & BIT7) {
                      border = (SC_OSD_WIN_BEVEL_WIDTH & 0x07) + 1;
                  }
              
                  switch (degree) {
                      case OSD_WIN_DEGREE_90 :
                          tmp1 = sx;
                          tmp2 = ex;
                          sx = fh * oh - ey;
                          if (sx >= border) {
                              sx -= border;
                          }
                          ex = fh * oh - sy - border;
                          sy = tmp1;
                          ey = tmp2;
                          break;
                      case OSD_WIN_DEGREE_180 :
                          tmp1 = sx;
                          tmp2 = ex;
                          sx = fw * ow - tmp2;
                          if (sx >= border) {
                              sx -= border;
                          }
                          ex = fw * ow - tmp1 - border;
                          tmp1 = sy;
                          tmp2 = ey;
                          sy = fh * oh - tmp2;
                          if (sy >= border) {
                              sy -= border;
                          }
                          ey = fh * oh - tmp1 - border;
                          break;
                      case OSD_WIN_DEGREE_270 :
                          tmp1 = sx;
                          tmp2 = ex;
                          sx = sy;
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 20  

                          ex = ey;
                          sy = fw * ow - tmp2;
                          if (sy >= border) {
                              sy -= border;
                          }
                          ey = fw * ow - tmp1 - border;
                          break;
                      default :
                          break;
                  }
              
                  SC_OSD_WIN_HOR_START_LO = (UCHAR)sx;
                  SC_OSD_WIN_HOR_END_LO = (UCHAR)ex;
                  tmp1 = ((sx >> 8) & 0x000F) | ((ex >> 4) & 0x00F0);
                  SC_OSD_WIN_HOR_HI = (UCHAR)tmp1;
                  SC_OSD_WIN_VER_START_LO = (UCHAR)sy;
                  SC_OSD_WIN_VER_END_LO = (UCHAR)ey;
                  tmp1 = ((sy >> 8) & 0x000F) | ((ey >> 4) & 0x00F0);
                  SC_OSD_WIN_VER_HI = (UCHAR)tmp1;
              
                  WaitDisVSync();
              }
              #endif
1188          #endif
1189          #endif //ENABLE_OSD_ROTATION == ON
1190          #endif //ENABLE_OSD_WINDOWS == ON
1191          
1192          /**************************************************************************//**
1193           * Set OSD zoom times.
1194           * @param times OSD zoom times. The range is 0~3.
1195           ******************************************************************************/
1196          void OSDAPI_SetHVZoom(UCHAR times)
1197          {
1198   1      
1199   1          OSDtimes = times;
1200   1          if (times == 0) {
1201   2              SC_OSD_ZOOM_CTL &= ~(BIT1|BIT0);
1202   2          } 
1203   1          else {
1204   2              SC_OSD_ZOOM_CTL |= (BIT1|BIT0);
1205   2              SC_OSD_VHGLOB_ZMRNG = 0x55*times;
1206   2          }
1207   1      }
1208          
1209          
1210          /**************************************************************************//**
1211           * Set OSD foreground and background transparency.
1212           * @param tran Level of OSD fg/bg transparency. Range is 0 to 8.
1213           ******************************************************************************/
1214          void OSDAPI_SetOSDFgBgTran(UCHAR tran)
1215          {
1216   1          if (tran == 0xFF) {
1217   2              return;
1218   2          }
1219   1          else if (tran > 8) {
1220   2              tran = 8;
1221   2          }
1222   1      
1223   1          if (tran == 0) {
1224   2              SC_OSD_TRANSLUCENT_CTL &= 0xF8;//TP_LEVEL_ONE
1225   2              SC_OSD_CODE_FC_CTL &= ~0x30;//BG_MIX_EN and FG_MIX_EN
1226   2          }
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 21  

1227   1          else {
1228   2              SC_OSD_TRANSLUCENT_CTL = (SC_OSD_TRANSLUCENT_CTL & 0xF8) | (tran - 1);//TP_LEVEL_ONE
1229   2              SC_OSD_CODE_FC_CTL |= 0x30;//BG_MIX_EN and FG_MIX_EN
1230   2          }
1231   1      }
1232          /**************************************************************************//**
1233           * Set OSD special background transparency.
1234           * @param tran Level of OSD special BG transparency. Range is 0 to 8.
1235           ******************************************************************************/
1236          void OSDAPI_SetOSDSpecialBgTran(UCHAR tran)
1237          {
1238   1          if (tran == 0xFF) {
1239   2              return;
1240   2              }
1241   1          else if (tran > 8) {
1242   2              tran = 8;
1243   2          }
1244   1          // NOTE:
1245   1          // This function works ONLY when the BG_INDEX[3:0] = b'0001!
1246   1          // and it can't be separately configured from WINDOW transparency! (commonly used)
1247   1          if (tran == 0) {
1248   2              SC_OSD_TRANSLUCENT_CTL &= 0xC7;//TP_LEVEL_TWO
1249   2              SC_OSD_CODE_FC_CTL &= ~BIT5;//BG_MIX_EN
1250   2          }
1251   1          else {
1252   2              SC_OSD_TRANSLUCENT_CTL = (SC_OSD_TRANSLUCENT_CTL & 0xC7) | ((tran - 1) << 3);//TP_LEVEL_TWO
1253   2              SC_OSD_CODE_FC_CTL |= BIT5;//BG_MIX_EN
1254   2          }
1255   1      }
1256          
1257          /**************************************************************************//**
1258           * Set OSD fade in/out.
1259           * @param vspeed OSD fade in/out vertical frecuency for every step
1260           * @param hspeed OSD fade in/out horizontal frecuency for every step
1261           * @param vstep OSD fade in/out vertical step
1262           * @param hstep OSD fade in/out horizontal step
1263           * @param dir OSD fade in/out direction select
1264           ******************************************************************************/
1265          #if !lrd_dis
              void OSDAPI_SetOSDFadeInOut(UCHAR vspeed, UCHAR hspeed, UCHAR vstep, UCHAR hstep, UCHAR dir)
              {
                  if (vstep == 0 && hstep == 0) {//disable fade in/out function
                      SC_OSD_FADE_STEP = 0x00;
                      SC_OSD_FADE_FREQ = 0x00;
                      }
                  else {
                      SC_OSD_CODE_FC_CTL |= (dir & 0x03) << 6;
                      SC_OSD_FADE_STEP = ((vstep & 0x0f) << 4) | (hstep & 0x0f);
                      SC_OSD_FADE_FREQ = ((vspeed & 0x07) << 4) | (hspeed & 0x0f) | BIT7;
                  }
              }
              #endif
1279          
1280          #if OSDTYPE == OSD_BENQ_V1 || OSDTYPE == OSD_BENQ_V2
1281          void OSDAPI_DisableSplit(void)
1282          {
1283   1          SC_OSD_HOR_SPLIT_START_LO = 0;
1284   1          SC_OSD_HOR_SPLIT_WIDTH_LO = 0;
1285   1          SC_OSD_VER_SPLIT_START_LO = 0;
1286   1          SC_OSD_VER_SPLIT_WIDTH_LO = 0;
1287   1      }
1288          #endif
C51 COMPILER V9.54   OSDAPI                                                                01/06/2017 14:57:13 PAGE 22  

1289          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4505    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
